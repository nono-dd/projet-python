
<!DOCTYPE html>

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="6. Expressions" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/reference/expressions.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Ce chapitre explique la signification des éléments des expressions en Python. Notes sur la syntaxe : dans ce chapitre et le suivant, nous utilisons la notation BNF étendue pour décrire la syntaxe, ..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Ce chapitre explique la signification des éléments des expressions en Python. Notes sur la syntaxe : dans ce chapitre et le suivant, nous utilisons la notation BNF étendue pour décrire la syntaxe, ..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>6. Expressions &#8212; Documentation Python 3.12.0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=b37c26da2f7529d09fe70b41c4b2133fe4931a90" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Recherchez dans Documentation Python 3.12.0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="À propos de ces documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="7. Les instructions simples" href="simple_stmts.html" />
    <link rel="prev" title="5. Le système d&#39;importation" href="import.html" />
    <link rel="canonical" href="https://docs.python.org/3/reference/expressions.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" />
                <input type="submit" value="Go"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#">6. Expressions</a><ul>
<li><a class="reference internal" href="#arithmetic-conversions">6.1. Conversions arithmétiques</a></li>
<li><a class="reference internal" href="#atoms">6.2. Atomes</a><ul>
<li><a class="reference internal" href="#atom-identifiers">6.2.1. Identifiants (noms)</a></li>
<li><a class="reference internal" href="#literals">6.2.2. Littéraux</a></li>
<li><a class="reference internal" href="#parenthesized-forms">6.2.3. Formes parenthésées</a></li>
<li><a class="reference internal" href="#displays-for-lists-sets-and-dictionaries">6.2.4. Agencements des listes, ensembles et dictionnaires</a></li>
<li><a class="reference internal" href="#list-displays">6.2.5. Agencements de listes</a></li>
<li><a class="reference internal" href="#set-displays">6.2.6. Agencements d'ensembles</a></li>
<li><a class="reference internal" href="#dictionary-displays">6.2.7. Agencements de dictionnaires</a></li>
<li><a class="reference internal" href="#generator-expressions">6.2.8. Expressions génératrices</a></li>
<li><a class="reference internal" href="#yield-expressions">6.2.9. Expressions <code class="docutils literal notranslate"><span class="pre">yield</span></code></a><ul>
<li><a class="reference internal" href="#generator-iterator-methods">6.2.9.1. Méthodes des générateurs-itérateurs</a></li>
<li><a class="reference internal" href="#examples">6.2.9.2. Exemples</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">6.2.9.3. Fonctions génératrices asynchrones</a></li>
<li><a class="reference internal" href="#asynchronous-generator-iterator-methods">6.2.9.4. Méthodes des générateurs-itérateurs asynchrones</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#primaries">6.3. Primaires</a><ul>
<li><a class="reference internal" href="#attribute-references">6.3.1. Références à des attributs</a></li>
<li><a class="reference internal" href="#subscriptions">6.3.2. Indiçage (ou sélections)</a></li>
<li><a class="reference internal" href="#slicings">6.3.3. Tranches</a></li>
<li><a class="reference internal" href="#calls">6.3.4. Appels</a></li>
</ul>
</li>
<li><a class="reference internal" href="#await-expression">6.4. Expression <code class="docutils literal notranslate"><span class="pre">await</span></code></a></li>
<li><a class="reference internal" href="#the-power-operator">6.5. L'opérateur puissance</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operations">6.6. Arithmétique unaire et opérations sur les bits</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operations">6.7. Opérations arithmétiques binaires</a></li>
<li><a class="reference internal" href="#shifting-operations">6.8. Opérations de décalage</a></li>
<li><a class="reference internal" href="#binary-bitwise-operations">6.9. Opérations binaires bit à bit</a></li>
<li><a class="reference internal" href="#comparisons">6.10. Comparaisons</a><ul>
<li><a class="reference internal" href="#value-comparisons">6.10.1. Comparaisons de valeurs</a></li>
<li><a class="reference internal" href="#membership-test-operations">6.10.2. Opérations de tests d’appartenance à un ensemble</a></li>
<li><a class="reference internal" href="#is-not">6.10.3. Comparaisons d'identifiants</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-operations">6.11. Opérations booléennes</a></li>
<li><a class="reference internal" href="#assignment-expressions">6.12. Expressions d'affectation</a></li>
<li><a class="reference internal" href="#conditional-expressions">6.13. Expressions conditionnelles</a></li>
<li><a class="reference internal" href="#lambda">6.14. Expressions lambda</a></li>
<li><a class="reference internal" href="#expression-lists">6.15. Listes d'expressions</a></li>
<li><a class="reference internal" href="#evaluation-order">6.16. Ordre d'évaluation</a></li>
<li><a class="reference internal" href="#operator-precedence">6.17. Priorités des opérateurs</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="import.html"
                          title="Chapitre précédent"><span class="section-number">5. </span>Le système d'importation</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="simple_stmts.html"
                          title="Chapitre suivant"><span class="section-number">7. </span>Les instructions simples</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/expressions.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. Les instructions simples"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. Le système d&#39;importation"
             accesskey="P">précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">La référence du langage Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">6. </span>Expressions</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="expressions">
<span id="id1"></span><h1><span class="section-number">6. </span>Expressions<a class="headerlink" href="#expressions" title="Lien permanent vers ce titre">¶</a></h1>
<p id="index-0">Ce chapitre explique la signification des éléments des expressions en Python.</p>
<p><strong>Notes sur la syntaxe :</strong> dans ce chapitre et le suivant, nous utilisons la notation BNF étendue pour décrire la syntaxe, pas l'analyse lexicale. Quand une règle de syntaxe est de la forme</p>
<pre>
<strong id="grammar-token-python-grammar-name"><span id="grammar-token-name"></span>name</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">othername</span></code>
</pre>
<p>et qu'aucune sémantique n'est donnée, la sémantique de <code class="docutils literal notranslate"><span class="pre">name</span></code> est la même que celle de <code class="docutils literal notranslate"><span class="pre">othername</span></code>.</p>
<section id="arithmetic-conversions">
<span id="conversions"></span><h2><span class="section-number">6.1. </span>Conversions arithmétiques<a class="headerlink" href="#arithmetic-conversions" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-1">Quand la description d'un opérateur arithmétique ci-dessous utilise la phrase « les arguments numériques sont convertis vers un type commun », cela signifie que l'implémentation de l'opérateur fonctionne de la manière suivante pour les types natifs :</p>
<ul class="simple">
<li><p>Si l'un des deux arguments est du type nombre complexe, l'autre est converti en nombre complexe ;</p></li>
<li><p>sinon, si l'un des arguments est un nombre à virgule flottante, l'autre est converti en nombre à virgule flottante ;</p></li>
<li><p>sinon, les deux doivent être des entiers et aucune conversion n'est nécessaire.</p></li>
</ul>
<p>Des règles supplémentaires s'appliquent pour certains opérateurs (par exemple, une chaîne comme opérande de gauche pour l'opérateur <code class="docutils literal notranslate"><span class="pre">%</span></code>). Les extensions doivent définir leurs propres règles de conversion.</p>
</section>
<section id="atoms">
<span id="id2"></span><h2><span class="section-number">6.2. </span>Atomes<a class="headerlink" href="#atoms" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-2">Les atomes sont les éléments de base des expressions. Les atomes les plus simples sont les identifiants et les littéraux. Les expressions entre parenthèses, crochets ou accolades sont aussi classées syntaxiquement comme des atomes. La syntaxe pour les atomes est :</p>
<pre>
<strong id="grammar-token-python-grammar-atom"><span id="grammar-token-atom"></span>atom     </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-literal"><code class="xref docutils literal notranslate"><span class="pre">literal</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-enclosure"><code class="xref docutils literal notranslate"><span class="pre">enclosure</span></code></a>
<strong id="grammar-token-python-grammar-enclosure"><span id="grammar-token-enclosure"></span>enclosure</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-parenth_form"><code class="xref docutils literal notranslate"><span class="pre">parenth_form</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-list_display"><code class="xref docutils literal notranslate"><span class="pre">list_display</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-dict_display"><code class="xref docutils literal notranslate"><span class="pre">dict_display</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-set_display"><code class="xref docutils literal notranslate"><span class="pre">set_display</span></code></a>
               | <a class="reference internal" href="#grammar-token-python-grammar-generator_expression"><code class="xref docutils literal notranslate"><span class="pre">generator_expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-yield_atom"><code class="xref docutils literal notranslate"><span class="pre">yield_atom</span></code></a>
</pre>
<section id="atom-identifiers">
<span id="identifiers-names"></span><h3><span class="section-number">6.2.1. </span>Identifiants (noms)<a class="headerlink" href="#atom-identifiers" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-3">Un identifiant qui apparaît en tant qu'atome est un nom. Lisez la section <a class="reference internal" href="lexical_analysis.html#identifiers"><span class="std std-ref">Identifiants et mots-clés</span></a> pour la définition lexicale et la section <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">Noms et liaisons</span></a> pour la documentation sur les noms et les liaisons afférentes.</p>
<p id="index-4">Quand un nom est lié à un objet, l'évaluation de l'atome produit cet objet. Quand le nom n'est pas lié, toute tentative de l'évaluer lève une exception <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>.</p>
<span class="target" id="private-name-mangling"></span><p id="index-5"><strong>Transformation des noms privés :</strong> lorsqu'un identificateur qui apparaît textuellement dans la définition d'une classe commence par deux (ou plus) caractères de soulignement et ne se termine pas par deux (ou plus) caractères de soulignement, il est considéré comme un <em class="dfn">nom privé &lt;private name&gt;</em> de cette classe. Les noms privés sont transformés en une forme plus longue avant que le code ne soit généré pour eux. La transformation insère le nom de la classe, avec les soulignés enlevés et un seul souligné inséré devant le nom. Par exemple, l'identificateur <code class="docutils literal notranslate"><span class="pre">__spam</span></code> apparaissant dans une classe nommée <code class="docutils literal notranslate"><span class="pre">Ham</span></code> est transformé en <code class="docutils literal notranslate"><span class="pre">_Ham__spam</span></code>. Cette transformation est indépendante du contexte syntaxique dans lequel l'identificateur est utilisé. Si le nom transformé est extrêmement long (plus de 255 caractères), l'implémentation peut le tronquer. Si le nom de la classe est constitué uniquement de traits de soulignement, aucune transformation n'est effectuée.</p>
</section>
<section id="literals">
<span id="atom-literals"></span><h3><span class="section-number">6.2.2. </span>Littéraux<a class="headerlink" href="#literals" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-6">Python gère les littéraux de chaînes de caractères, de chaînes d'octets et de plusieurs autres types numériques :</p>
<pre>
<strong id="grammar-token-python-grammar-literal"><span id="grammar-token-literal"></span>literal</strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-stringliteral"><code class="xref docutils literal notranslate"><span class="pre">stringliteral</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-bytesliteral"><code class="xref docutils literal notranslate"><span class="pre">bytesliteral</span></code></a>
             | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-integer"><code class="xref docutils literal notranslate"><span class="pre">integer</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-floatnumber"><code class="xref docutils literal notranslate"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-imagnumber"><code class="xref docutils literal notranslate"><span class="pre">imagnumber</span></code></a>
</pre>
<p>L'évaluation d'un littéral produit un objet du type donné (chaîne de caractères, chaîne d'octets, entier, nombre à virgule flottante, nombre complexe) avec la valeur donnée. La valeur peut être approximée dans le cas des nombres à virgule flottante et des nombres imaginaires (complexes). Reportez-vous à la section <a class="reference internal" href="lexical_analysis.html#literals"><span class="std std-ref">Littéraux</span></a> pour les détails.</p>
<p id="index-7">Tous les littéraux sont de types immuables et donc l'identifiant de l'objet est moins important que sa valeur. Des évaluations multiples de littéraux avec la même valeur (soit la même occurrence dans le texte du programme, soit une autre occurrence) résultent dans le même objet ou un objet différent avec la même valeur.</p>
</section>
<section id="parenthesized-forms">
<span id="parenthesized"></span><h3><span class="section-number">6.2.3. </span>Formes parenthésées<a class="headerlink" href="#parenthesized-forms" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-8">Une forme parenthésée est une liste d'expressions (cette liste est en fait optionnelle) placée à l'intérieur de parenthèses :</p>
<pre>
<strong id="grammar-token-python-grammar-parenth_form"><span id="grammar-token-parenth-form"></span>parenth_form</strong> ::=  &quot;(&quot; [<a class="reference internal" href="#grammar-token-python-grammar-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a>] &quot;)&quot;
</pre>
<p>Une liste d'expressions entre parenthèses produit ce que la liste de ces expressions produirait : si la liste contient au moins une virgule, elle produit un <em>n</em>-uplet (type <em>n</em>-uplet) ; sinon, elle produit l'expression elle-même (qui constitue donc elle-même la liste d'expressions).</p>
<p id="index-9">Une paire de parenthèses vide produit un objet <em>n</em>-uplet vide. Comme les n-uplets sont immuables, la même règle que pour les littéraux s'applique (c'est-à-dire que deux occurrences du <em>n</em>-uplet vide peuvent, ou pas, produire le même objet).</p>
<p id="index-10">Note that tuples are not formed by the parentheses, but rather by use of the
comma.  The exception is the empty tuple, for which parentheses <em>are</em>
required --- allowing unparenthesized &quot;nothing&quot; in expressions would cause
ambiguities and allow common typos to pass uncaught.</p>
</section>
<section id="displays-for-lists-sets-and-dictionaries">
<span id="comprehensions"></span><h3><span class="section-number">6.2.4. </span>Agencements des listes, ensembles et dictionnaires<a class="headerlink" href="#displays-for-lists-sets-and-dictionaries" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-11">Pour construire une liste, un ensemble ou un dictionnaire, Python fournit des syntaxes spéciales dites « agencements » (<em>displays</em> en anglais), chaque agencement comportant deux variantes :</p>
<ul class="simple">
<li><p>soit le contenu du conteneur est listé explicitement,</p></li>
<li><p>soit il est calculé à l'aide de la combinaison d'une boucle et d'instructions de filtrage, appelée une <em class="dfn">compréhension</em> (dans le sens de ce qui sert à définir un concept, par opposition à <em>extension</em>).</p></li>
</ul>
<p id="index-12">Les compréhensions sont constituées des éléments de syntaxe communs suivants :</p>
<pre>
<strong id="grammar-token-python-grammar-comprehension"><span id="grammar-token-comprehension"></span>comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
<strong id="grammar-token-python-grammar-comp_for"><span id="grammar-token-comp-for"></span>comp_for     </strong> ::=  [&quot;async&quot;] &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-python-grammar-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="#grammar-token-python-grammar-comp_iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
<strong id="grammar-token-python-grammar-comp_iter"><span id="grammar-token-comp-iter"></span>comp_iter    </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-comp_if"><code class="xref docutils literal notranslate"><span class="pre">comp_if</span></code></a>
<strong id="grammar-token-python-grammar-comp_if"><span id="grammar-token-comp-if"></span>comp_if      </strong> ::=  &quot;if&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="#grammar-token-python-grammar-comp_iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
</pre>
<p>Une compréhension est constituée par une seule expression suivie par au moins une clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> et zéro ou plus clauses <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> ou <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code>. Dans ce cas, les éléments du nouveau conteneur sont ceux qui auraient été produits si l'on avait considéré toutes les clauses <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> ou <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> comme des blocs, imbriqués de la gauche vers la droite, et évalué l'expression pour produire un élément à chaque fois que le bloc le plus imbriqué était atteint.</p>
<p>Cependant, à part l'expression de l'itérable dans la clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> la plus à gauche, la compréhension est exécutée dans une portée séparée, implicitement imbriquée. Ceci assure que les noms assignés dans la liste cible ne « fuient » pas en dehors de cette portée.</p>
<p>L'expression de l'itérable dans la clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> la plus à gauche est évaluée directement dans la portée englobante puis passée en tant qu'argument à la portée implicite imbriquée. Les clauses <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> suivantes et les filtres conditionnels de la clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> la plus à gauche ne peuvent pas être évalués dans la portée englobante, car ils peuvent dépendre de valeurs obtenues à partir de l'itérable le plus à gauche. Par exemple : <code class="docutils literal notranslate"><span class="pre">[x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">range(x,</span> <span class="pre">x+10)]</span></code>.</p>
<p>Pour assurer que le résultat de la compréhension soit un conteneur du type approprié, les expressions <code class="docutils literal notranslate"><span class="pre">yield</span></code> et <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> sont interdites dans la portée implicite imbriquée.</p>
<p id="index-13">Depuis Python 3.6, dans une fonction <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>, une clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> peut être utilisée pour itérer sur un <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">itérateur asynchrone</span></a>. Une compréhension dans une fonction <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> consiste alors à avoir, après cette expression de tête, une clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> ou <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> suivie par des clauses <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> ou <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> additionnelles facultatives et, possiblement, des expressions <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>. Si la compréhension contient des clauses <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>, des expressions <code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code> ou d'autres compréhensions asynchrones, elle est appelée <em class="dfn">compréhension asynchrone</em>. Une compréhension asynchrone peut suspendre l'exécution de la fonction coroutine dans laquelle elle apparaît. Voir aussi la <span class="target" id="index-111"></span><a class="pep reference external" href="https://peps.python.org/pep-0530/"><strong>PEP 530</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.6: </span>Les compréhensions asynchrones ont été introduites.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.8: </span><code class="docutils literal notranslate"><span class="pre">yield</span></code> et <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> sont interdites dans la portée implicite imbriquée.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>les compréhensions asynchrones sont maintenant autorisées dans les compréhensions des fonctions asynchrones. Les compréhensions englobantes deviennent implicitement asynchrones.</p>
</div>
</section>
<section id="list-displays">
<span id="lists"></span><h3><span class="section-number">6.2.5. </span>Agencements de listes<a class="headerlink" href="#list-displays" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-15">Un agencement de liste est une suite (possiblement vide) d'expressions à l'intérieur de crochets :</p>
<pre>
<strong id="grammar-token-python-grammar-list_display"><span id="grammar-token-list-display"></span>list_display</strong> ::=  &quot;[&quot; [<a class="reference internal" href="#grammar-token-python-grammar-starred_list"><code class="xref docutils literal notranslate"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;]&quot;
</pre>
<p>Un agencement de liste produit un nouvel objet liste, dont le contenu est spécifié soit par une liste d'expression soit par une compréhension. Quand une liste d'expressions (dont les éléments sont séparés par des virgules) est fournie, ces éléments sont évalués de la gauche vers la droite et placés dans l'objet liste, dans cet ordre. Quand c'est une compréhension qui est fournie, la liste est construite à partir des éléments produits par la compréhension.</p>
</section>
<section id="set-displays">
<span id="set"></span><h3><span class="section-number">6.2.6. </span>Agencements d'ensembles<a class="headerlink" href="#set-displays" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-16">Un agencement d'ensemble (type <em>set</em>) est délimité par des accolades et se distingue de l'agencement d'un dictionnaire par le fait qu'il n'y a pas de « deux points » <code class="docutils literal notranslate"><span class="pre">:</span></code> pour séparer les clés et les valeurs :</p>
<pre>
<strong id="grammar-token-python-grammar-set_display"><span id="grammar-token-set-display"></span>set_display</strong> ::=  &quot;{&quot; (<a class="reference internal" href="#grammar-token-python-grammar-starred_list"><code class="xref docutils literal notranslate"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>) &quot;}&quot;
</pre>
<p>Un agencement d'ensemble produit un nouvel objet ensemble muable, le contenu étant spécifié soit par une séquence d'expression, soit par une compréhension. Quand une liste (dont les éléments sont séparés par des virgules) est fournie, ses éléments sont évalués de la gauche vers la droite et ajoutés à l'objet ensemble. Quand une compréhension est fournie, l'ensemble est construit à partir des éléments produits par la compréhension.</p>
<p>Un ensemble vide ne peut pas être construit par <code class="docutils literal notranslate"><span class="pre">{}</span></code> ; cette écriture construit un dictionnaire vide.</p>
</section>
<section id="dictionary-displays">
<span id="dict"></span><h3><span class="section-number">6.2.7. </span>Agencements de dictionnaires<a class="headerlink" href="#dictionary-displays" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-17">A dictionary display is a possibly empty series of dict items (key/value pairs)
enclosed in curly braces:</p>
<pre>
<strong id="grammar-token-python-grammar-dict_display"><span id="grammar-token-dict-display"></span>dict_display      </strong> ::=  &quot;{&quot; [<a class="reference internal" href="#grammar-token-python-grammar-dict_item_list"><code class="xref docutils literal notranslate"><span class="pre">dict_item_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-dict_comprehension"><code class="xref docutils literal notranslate"><span class="pre">dict_comprehension</span></code></a>] &quot;}&quot;
<strong id="grammar-token-python-grammar-dict_item_list"><span id="grammar-token-dict-item-list"></span>dict_item_list    </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-dict_item"><code class="xref docutils literal notranslate"><span class="pre">dict_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-dict_item"><code class="xref docutils literal notranslate"><span class="pre">dict_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-dict_item"><span id="grammar-token-dict-item"></span>dict_item         </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
<strong id="grammar-token-python-grammar-dict_comprehension"><span id="grammar-token-dict-comprehension"></span>dict_comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
</pre>
<p>Un agencement de dictionnaire produit un nouvel objet dictionnaire.</p>
<p>If a comma-separated sequence of dict items is given, they are evaluated
from left to right to define the entries of the dictionary: each key object is
used as a key into the dictionary to store the corresponding value.  This means
that you can specify the same key multiple times in the dict item list, and the
final dictionary's value for that key will be the last one given.</p>
<p id="index-18">A double asterisk <code class="docutils literal notranslate"><span class="pre">**</span></code> denotes <em class="dfn">dictionary unpacking</em>.
Its operand must be a <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>.  Each mapping item is added
to the new dictionary.  Later values replace values already set by
earlier dict items and earlier dictionary unpackings.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.5: </span>le dépaquetage peut se faire vers un agencement de dictionnaire, proposé à l'origine par la <span class="target" id="index-112"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a>.</p>
</div>
<p>Une compréhension de dictionnaire, au contraire des compréhensions de listes ou d'ensembles, requiert deux expressions séparées par une virgule et suivies par les clauses usuelles &quot;for&quot; et &quot;if&quot;. Quand la compréhension est exécutée, les éléments clés-valeurs sont insérés dans le nouveau dictionnaire dans l'ordre dans lequel ils sont produits.</p>
<p id="index-20">Restrictions on the types of the key values are listed earlier in section
<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">Hiérarchie des types standards</span></a>.  (To summarize, the key type should be <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>, which excludes
all mutable objects.)  Clashes between duplicate keys are not detected; the last
value (textually rightmost in the display) stored for a given key value
prevails.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.8: </span>Avant Python 3.8, dans les compréhensions de dictionnaires, l'ordre d'évaluation entre les clés et les valeurs n'était pas bien défini. Dans CPython, la valeur était évaluée avant la clé. À partir de la version 3.8, la clé est évaluée avant la valeur, comme proposé par la <span class="target" id="index-113"></span><a class="pep reference external" href="https://peps.python.org/pep-0572/"><strong>PEP 572</strong></a>.</p>
</div>
</section>
<section id="generator-expressions">
<span id="genexpr"></span><h3><span class="section-number">6.2.8. </span>Expressions génératrices<a class="headerlink" href="#generator-expressions" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-22">Une expression génératrice est une notation concise pour un générateur, entourée de parenthèses :</p>
<pre>
<strong id="grammar-token-python-grammar-generator_expression"><span id="grammar-token-generator-expression"></span>generator_expression</strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> &quot;)&quot;
</pre>
<p>Une expression génératrice produit un nouvel objet générateur. Sa syntaxe est la même que celle des compréhensions, sauf qu'elle est entourée de parenthèses au lieu de crochets ou d'accolades.</p>
<p>Les variables utilisées dans une expression génératrice sont évaluées paresseusement, au moment où la méthode <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> de l'objet générateur est appelée (de la même manière que pour les générateurs classiques). Cependant, l'expression de l'itérable dans la clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> la plus à gauche est immédiatement évaluée, de manière à ce qu'une erreur dans cette partie soit signalée à l'endroit où l'expression génératrice est définie plutôt qu'à l'endroit où la première valeur est récupérée. Les clauses <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> suivantes ne peuvent pas être évaluées dans la portée implicite imbriquée car elles peuvent dépendre de valeurs obtenues à partir de boucles <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> plus à gauche. Par exemple, <code class="docutils literal notranslate"><span class="pre">(x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">range(x,</span> <span class="pre">x+10))</span></code>.</p>
<p>Les parenthèses peuvent être omises pour les appels qui ne possèdent qu'un seul argument. Voir la section <a class="reference internal" href="#calls"><span class="std std-ref">Appels</span></a> pour les détails.</p>
<p>Pour éviter d'interférer avec l'opération attendue de l'expression génératrice elle-même, les expressions <code class="docutils literal notranslate"><span class="pre">yield</span></code> et <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> sont interdites dans les générateurs définis de manière implicite.</p>
<p>Si une expression génératrice contient  une ou des expressions <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> ou <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>, elle est appelée <em class="dfn">expression génératrice asynchrone &lt;asynchronous generator expression&gt;</em>. Une expression génératrice asynchrone produit un nouvel objet générateur asynchrone qui est un itérateur asynchrone (voir <a class="reference internal" href="datamodel.html#async-iterators"><span class="std std-ref">Itérateurs asynchrones</span></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.6: </span>les expressions génératrices asynchrones ont été introduites.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>Avant Python 3.7, les expressions génératrices asynchrones ne pouvaient apparaître que dans les coroutines <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>. À partir de la version 3.7, toute fonction peut utiliser des expressions génératrices asynchrones.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.8: </span><code class="docutils literal notranslate"><span class="pre">yield</span></code> et <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> sont interdites dans la portée implicite imbriquée.</p>
</div>
</section>
<section id="yield-expressions">
<span id="yieldexpr"></span><h3><span class="section-number">6.2.9. </span>Expressions <code class="docutils literal notranslate"><span class="pre">yield</span></code><a class="headerlink" href="#yield-expressions" title="Lien permanent vers ce titre">¶</a></h3>
<pre id="index-23">
<strong id="grammar-token-python-grammar-yield_atom"><span id="grammar-token-yield-atom"></span>yield_atom      </strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-python-grammar-yield_expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a> &quot;)&quot;
<strong id="grammar-token-python-grammar-yield_expression"><span id="grammar-token-yield-expression"></span>yield_expression</strong> ::=  &quot;yield&quot; [<a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> | &quot;from&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
</pre>
<p>Une expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> est utilisée pour définir une <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">fonction génératrice</span></a> ou une <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">fonction génératrice asynchrone</span></a> et ne peut donc être utilisée que dans le corps de la définition d'une fonction. L'utilisation d'une expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> dans le corps d'une fonction entraîne que cette fonction devient une fonction génératrice et son utilisation dans le corps d'une fonction <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> entraine que cette fonction coroutine devient une fonction génératrice asynchrone. Par exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>  <span class="c1"># defines a generator function</span>
    <span class="k">yield</span> <span class="mi">123</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">agen</span><span class="p">():</span> <span class="c1"># defines an asynchronous generator function</span>
    <span class="k">yield</span> <span class="mi">123</span>
</pre></div>
</div>
<p>En raison des effets de bords sur la portée contenant, les expressions <code class="docutils literal notranslate"><span class="pre">yield</span></code> ne sont pas autorisées dans la portée implicite utilisée dans l'implémentation des compréhensions et des expressions génératrices.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.8: </span>Les expressions <code class="docutils literal notranslate"><span class="pre">yield</span></code> sont interdites dans la portée implicite imbriquée utilisée dans l'implémentation des compréhensions et des expressions génératrices.</p>
</div>
<p>Les fonctions génératrices sont décrites plus loin alors que les fonctions générateurs asynchrones sont décrites séparément dans la section <a class="reference internal" href="#asynchronous-generator-functions"><span class="std std-ref">Fonctions génératrices asynchrones</span></a>.</p>
<p>When a generator function is called, it returns an iterator known as a
generator.  That generator then controls the execution of the generator
function.  The execution starts when one of the generator's methods is called.
At that time, the execution proceeds to the first yield expression, where it is
suspended again, returning the value of <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a>
to the generator's caller,
or <code class="docutils literal notranslate"><span class="pre">None</span></code> if <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> is omitted.
By suspended, we mean that all local state is
retained, including the current bindings of local variables, the instruction
pointer, the internal evaluation stack, and the state of any exception handling.
When the execution is resumed by calling one of the generator's methods, the
function can proceed exactly as if the yield expression were just another
external call.  The value of the yield expression after resuming depends on the
method which resumed the execution.  If <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> is used
(typically via either a <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> or the <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> builtin) then the
result is <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.  Otherwise, if <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> is used, then
the result will be the value passed in to that method.</p>
<p id="index-24">Tout ceci rend les fonctions génératrices très similaires aux coroutines : elles produisent plusieurs objets <em>via</em> des expressions <code class="docutils literal notranslate"><span class="pre">yield</span></code>, elles possèdent plus qu'un seul point d'entrée et leur exécution peut être suspendue. La seule différence est qu'une fonction génératrice ne peut pas contrôler où l'exécution doit se poursuivre après une instruction <code class="docutils literal notranslate"><span class="pre">yield</span></code> ; ce contrôle est toujours du ressort de l'appelant au générateur.</p>
<p>Les expressions <code class="docutils literal notranslate"><span class="pre">yield</span></code> sont autorisées partout dans un bloc <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>. Si l'exécution du générateur ne reprend pas avant qu'il ne soit finalisé (parce que son compteur de référence est tombé à zéro ou parce qu'il est nettoyé par le ramasse-miettes), la méthode <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> du générateur-itérateur est appelée, ce qui permet l'exécution de toutes les clauses <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> en attente.</p>
<p id="index-25">L'expression passée à <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> doit être un itérateur. Toutes les valeurs produites par cet itérateur sont directement passées à l'appelant des méthodes du générateur courant. Toute valeur passée par <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> ou toute exception passée par <a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> est transmise à l'itérateur sous-jacent s'il possède les méthodes appropriées. Si ce n'est pas le cas, alors <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> lève une <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> ou une <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, alors que <a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> ne fait que propager l'exception immédiatement.</p>
<p>Quand l'itérateur sous-jacent a terminé, l'attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> de l'instance <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> qui a été levée devient la valeur produite par l'expression <code class="docutils literal notranslate"><span class="pre">yield</span></code>. Elle peut être définie explicitement quand vous levez <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> ou automatiquement que le sous-itérateur est un générateur (en renvoyant une valeur par le sous-générateur).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.3: </span><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> a été ajoutée pour déléguer le contrôle du flot d'exécution à un sous-itérateur.</p>
</div>
<p>Les parenthèses peuvent être omises quand l'expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> est la seule expression à droite de l'instruction de l'instruction d'affectation.</p>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<dl class="simple">
<dt><span class="target" id="index-114"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a> : générateurs simples</dt><dd><p>La proposition d'ajouter à Python des générateurs et l'instruction <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>.</p>
</dd>
<dt><span class="target" id="index-115"></span><a class="pep reference external" href="https://peps.python.org/pep-0342/"><strong>PEP 342</strong></a> -- Coroutines <em>via</em> des générateurs améliorés</dt><dd><p>Proposition d'améliorer l'API et la syntaxe des générateurs, de manière à pouvoir les utiliser comme de simples coroutines.</p>
</dd>
<dt><span class="target" id="index-116"></span><a class="pep reference external" href="https://peps.python.org/pep-0380/"><strong>PEP 380</strong></a> -- Syntaxe pour déléguer à un sous-générateur</dt><dd><p>Proposition d'introduire la syntaxe <code class="xref std std-token docutils literal notranslate"><span class="pre">yield_from</span></code>, de manière à déléguer facilement l'exécution à un sous-générateur.</p>
</dd>
<dt><span class="target" id="index-117"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a> : Générateurs asynchrones</dt><dd><p>La proposition qui a amélioré la <span class="target" id="index-118"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> en ajoutant des capacités de générateur pour les coroutines.</p>
</dd>
</dl>
</div>
<section id="generator-iterator-methods">
<span id="generator-methods"></span><span id="index-31"></span><h4><span class="section-number">6.2.9.1. </span>Méthodes des générateurs-itérateurs<a class="headerlink" href="#generator-iterator-methods" title="Lien permanent vers ce titre">¶</a></h4>
<p>Cette sous-section décrit les méthodes des générateurs-itérateurs. Elles peuvent être utilisées pour contrôler l'exécution des fonctions génératrices.</p>
<p>Notez que l'appel à une méthode ci-dessous d'un générateur alors que le générateur est déjà en cours d'exécution lève une exception <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<span class="target" id="index-32"></span><dl class="py method">
<dt class="sig sig-object py" id="generator.__next__">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">__next__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.__next__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Démarre l'exécution d'une fonction génératrice ou la reprend à la dernière expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> exécutée. Quand une fonction génératrice est reprise par une méthode <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a>, l'expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> en cours s'évalue toujours à <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>. L'exécution continue ensuite jusqu'à l'expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> suivante, où le générateur est à nouveau suspendu et la valeur de <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> est renvoyée à la méthode <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> de l'appelant. Si le générateur termine sans donner une autre valeur, une exception <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> est levée.</p>
<p>Cette méthode est normalement appelée implicitement, par exemple par une boucle <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> ou par la fonction native <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="generator.send">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#generator.send" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Reprend l'exécution et « envoie » une valeur à la fonction génératrice. L'argument <em>value</em> devient le résultat de l'expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> courante. La méthode <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> renvoie la valeur suivante produite par le générateur ou lève <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> si le générateur termine sans produire de nouvelle valeur. Quand <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> est utilisée pour démarrer le générateur, elle doit avoir <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> comme argument, car il n'y a aucune expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> qui peut recevoir la valeur.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="generator.throw">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#generator.throw" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Lève une exception à l'endroit où le générateur est en pause et renvoie la valeur suivante produite par la fonction génératrice. Si le générateur termine sans produire de nouvelle valeur, une exception <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> est levée. Si la fonction génératrice ne gère pas l'exception passée ou lève une autre exception, alors cette exception est propagée vers l'appelant.</p>
<p>Dans son utilisation typique, elle est appelée avec une seule instance d'exception, de façon similaire à l'utilisation du mot-clé <a class="reference internal" href="simple_stmts.html#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a>.</p>
<p>For backwards compatibility, however, the second signature is
supported, following a convention from older versions of Python.
The <em>type</em> argument should be an exception class, and <em>value</em>
should be an exception instance. If the <em>value</em> is not provided, the
<em>type</em> constructor is called to get an instance. If <em>traceback</em>
is provided, it is set on the exception, otherwise any existing
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code> attribute stored in <em>value</em> may
be cleared.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.12: </span>The second signature (type[, value[, traceback]]) is deprecated and
may be removed in a future version of Python.</p>
</div>
</dd></dl>

<span class="target" id="index-33"></span><dl class="py method">
<dt class="sig sig-object py" id="generator.close">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.close" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Lève une <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> à l'endroit où la fonction génératrice a été mise en pause. Si la fonction génératrice termine, est déjà fermée ou lève <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> (parce qu'elle ne gère pas l'exception), <em>close</em> revient vers l'appelant. Si le générateur produit une valeur, une  <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> est levée. Si le générateur lève une autre exception, elle est propagée à l'appelant. La méthode <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> ne fait rien si le générateur a déjà terminé en raison d'une exception ou d'une fin normale.</p>
</dd></dl>

</section>
<section id="examples">
<span id="index-34"></span><h4><span class="section-number">6.2.9.2. </span>Exemples<a class="headerlink" href="#examples" title="Lien permanent vers ce titre">¶</a></h4>
<p>Voici un exemple simple qui montre le comportement des générateurs et des fonctions génératrices :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Execution starts when &#39;next()&#39; is called for the first time.&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="n">e</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Don&#39;t forget to clean up when &#39;close()&#39; is called.&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span> <span class="o">=</span> <span class="n">echo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">Execution starts when &#39;next()&#39; is called for the first time.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">generator</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="s2">&quot;spam&quot;</span><span class="p">)</span>
<span class="go">TypeError(&#39;spam&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">Don&#39;t forget to clean up when &#39;close()&#39; is called.</span>
</pre></div>
</div>
<p>Pour des exemples d'utilisation de <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>, lisez la <a class="reference internal" href="../whatsnew/3.3.html#pep-380"><span class="std std-ref">PEP 380: Syntax for Delegating to a Subgenerator</span></a> dans « Les nouveautés de Python ».</p>
</section>
<section id="asynchronous-generator-functions">
<span id="id3"></span><h4><span class="section-number">6.2.9.3. </span>Fonctions génératrices asynchrones<a class="headerlink" href="#asynchronous-generator-functions" title="Lien permanent vers ce titre">¶</a></h4>
<p>La présence d'une expression <em>yield</em> dans une fonction ou une méthode définie en utilisant <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> transforme cette fonction en fonction <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">générateur asynchrone</span></a>.</p>
<p>Quand une fonction génératrice asynchrone est appelée, elle renvoie un itérateur asynchrone, autrement appelé objet générateur asynchrone. Cet objet contrôle l'exécution de la fonction génératrice. Un objet générateur asynchrone est typiquement utilisé dans une instruction <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> à l'intérieur d'une fonction coroutine de la même manière qu'un objet générateur serait utilisé dans une instruction <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>.</p>
<p>L'appel d'une méthode du générateur asynchrone renvoie un objet <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> et l'exécution commence au moment où l'on atteint une instruction <code class="docutils literal notranslate"><span class="pre">await</span></code> le concernant. À ce moment, l'exécution se déroule jusqu'à la première expression <code class="docutils literal notranslate"><span class="pre">yield</span></code>, où elle est suspendue et renvoie la valeur de <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> à la coroutine en attente. Comme pour un générateur, la suspension signifie que tous les états locaux sont conservés, y compris les liaisons des variables locales, le pointeur d'instruction, la pile d'évaluation interne et l'état de tous les gestionnaires d'exceptions. Lorsque l'exécution reprend parce que l'appelant a atteint une instruction <code class="docutils literal notranslate"><span class="pre">await</span></code> sur l'objet suivant retourné par les méthodes du générateur asynchrone, la fonction s'exécute exactement comme si l'expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> n'avait été qu'un simple appel externe. La valeur de l'expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> au moment de la reprise dépend de la méthode qui a relancé l'exécution. Si c'est <a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> qui a été utilisée, alors le résultat est <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>. Sinon, si c'est <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> qui a été utilisée, alors le résultat est la valeur transmise à cette méthode.</p>
<p>Si un générateur asynchrone se termine précipitamment en raison d'un <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a>, de l'annulation de la tâche de l'appelant ou d'une exception, le code de nettoyage du générateur asynchrone est exécuté et lève possiblement des exceptions, accède à des variables de contexte dans un contexte inattendu — peut-être parce que la tâche de laquelle il dépend est finie, ou pendant la fermeture de la boucle d'événements quand le point d'entrée du ramasse-miettes a déjà été appelé. Afin d'éviter cette situation, l'appelant doit explicitement fermer le générateur asynchrone en appelant la méthode <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> pour « finaliser » le générateur et le détacher de la boucle d'événements.</p>
<p>Dans une fonction génératrice asynchrone, les expressions <code class="docutils literal notranslate"><span class="pre">yield</span></code> sont autorisées n'importe où dans une construction <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>. Cependant, si l'exécution d'un générateur asynchrone n'a pas repris avant que le générateur ne soit finalisé (parce que son compteur de référence a atteint zéro ou parce qu'il est nettoyé par le ramasse-miettes), alors une expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> dans une construction <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> pourrait ne pas atteindre la clause <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> en attente. Dans ce cas, c'est la responsabilité de la boucle d'événements ou du programmateur exécutant le générateur asynchrone d'appeler la méthode <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> du générateur asynchrone et d'exécuter l'objet coroutine résultant, permettant ainsi à toute clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> en attente d'être exécutée.</p>
<p>Pour effectuer correctement la finalisation, une boucle d'événements doit définir une fonction <em>finalizer</em> qui prend un générateur-itérateur asynchrone, appelle sans doute <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> et exécute la coroutine. Ce <em>finalizer</em> peut s'enregistrer en appelant <a class="reference internal" href="../library/sys.html#sys.set_asyncgen_hooks" title="sys.set_asyncgen_hooks"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_asyncgen_hooks()</span></code></a>. Lors de la première itération, un générateur-itérateur asynchrone stocke le <em>finalizer</em> enregistré à appeler lors de la finalisation. Pour un exemple de référence relatif à une méthode de <em>finalizer</em>, regardez l'implémentation de <code class="docutils literal notranslate"><span class="pre">asyncio.Loop.shutdown_asyncgens</span></code> dans <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a>.</p>
<p>L'expression <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> produit une erreur de syntaxe quand elle est utilisée dans une fonction génératrice asynchrone.</p>
</section>
<section id="asynchronous-generator-iterator-methods">
<span id="asynchronous-generator-methods"></span><span id="index-35"></span><h4><span class="section-number">6.2.9.4. </span>Méthodes des générateurs-itérateurs asynchrones<a class="headerlink" href="#asynchronous-generator-iterator-methods" title="Lien permanent vers ce titre">¶</a></h4>
<p>Cette sous-section décrit les méthodes des générateurs-itérateurs asynchrones. Elles sont utilisées pour contrôler l’exécution des fonctions génératrices.</p>
<span class="target" id="index-36"></span><dl class="py method">
<dt class="sig sig-object py" id="agen.__anext__">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">__anext__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.__anext__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un <em>awaitable</em> qui, quand il a la main, démarre l'exécution du générateur asynchrone ou reprend son exécution à l'endroit de la dernière expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> exécutée. Quand une fonction génératrice asynchrone est reprise par une méthode <a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>, l’expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> en cours s’évalue toujours à <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> dans le <em>awaitable</em> renvoyé, et elle continue son exécution jusqu’à l’expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> suivante. La valeur de <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> de l'expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> est la valeur de l'exception <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> levée par la coroutine qui termine. Si le générateur asynchrone termine sans produire d'autre valeur, le <em>awaitable</em> lève une exception <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> qui signale que l'itération asynchrone est terminée.</p>
<p>Cette méthode est normalement appelée implicitement par une boucle <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="agen.asend">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">asend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#agen.asend" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un <em>awaitable</em> qui, lorsqu'il a la main, reprend l'exécution du générateur asynchrone. Comme pour la méthode <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> d'un générateur, elle « envoie » une valeur <em>value</em> à la fonction génératrice asynchrone et cet argument devient le résultat de l'expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> courante. Le <em>awaitable</em> renvoyé par la méthode <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> renvoie la valeur suivante produite par le générateur comme valeur de l'exception <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> levée ou lève <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> si le générateur asynchrone termine sans produire de nouvelle valeur. Quand <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> est appelée pour démarrer le générateur asynchrone, l'argument doit être <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> car il n'y a pas d'expression <code class="docutils literal notranslate"><span class="pre">yield</span></code> pour recevoir la valeur.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="agen.athrow">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">athrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#agen.athrow" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">athrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Renvoie un <em>awaitable</em> qui lève une exception du type <code class="docutils literal notranslate"><span class="pre">type</span></code> à l'endroit où le générateur asynchrone a été mis en pause et renvoie la valeur suivante produite par la fonction génératrice comme valeur de l'exception <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> qui a été levée. Si le générateur asynchrone termine sans produire de nouvelle valeur, une exception <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> est levée par le <em>awaitable</em>. Si la fonction génératrice ne traite pas l'exception reçue ou lève une autre exception alors, quand le <em>awaitable</em> est lancé, cette exception est propagée vers l'appelant du <em>awaitable</em>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.12: </span>The second signature (type[, value[, traceback]]) is deprecated and
may be removed in a future version of Python.</p>
</div>
</dd></dl>

<span class="target" id="index-37"></span><dl class="py method">
<dt class="sig sig-object py" id="agen.aclose">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.aclose" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un <em>awaitable</em> qui, quand il s'exécute, lève une exception <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> dans la fonction génératrice asynchrone à l'endroit où le générateur était en pause. Si la fonction génératrice asynchrone termine normalement, est déjà fermée ou lève <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> (parce qu'elle ne gère pas l'exception), alors le <em>awaitable</em> renvoyé lève une exception <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>. Tout nouveau <em>awaitable</em> produit par un appel postérieur au générateur asynchrone lève une exception <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a>. Si le générateur asynchrone produit une valeur, une <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> est levée par le <em>awaitable</em>. Si le générateur asynchrone lève une autre exception, elle est propagée à l'appelant du <em>awaitable</em>. Si le générateur asynchrone a déjà terminé (soit par une exception, soit normalement), alors tout nouvel appel à <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> renvoie un <em>awaitable</em> qui ne fait rien.</p>
</dd></dl>

</section>
</section>
</section>
<section id="primaries">
<span id="id4"></span><h2><span class="section-number">6.3. </span>Primaires<a class="headerlink" href="#primaries" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-38">Les primaires (<em>primary</em> dans la grammaire formelle ci-dessous) représentent les opérations qui se lient au plus proche dans le langage. Leur syntaxe est :</p>
<pre>
<strong id="grammar-token-python-grammar-primary"><span id="grammar-token-primary"></span>primary</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-atom"><code class="xref docutils literal notranslate"><span class="pre">atom</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-attributeref"><code class="xref docutils literal notranslate"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-subscription"><code class="xref docutils literal notranslate"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-slicing"><code class="xref docutils literal notranslate"><span class="pre">slicing</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-call"><code class="xref docutils literal notranslate"><span class="pre">call</span></code></a>
</pre>
<section id="attribute-references">
<span id="id5"></span><h3><span class="section-number">6.3.1. </span>Références à des attributs<a class="headerlink" href="#attribute-references" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-39">Une référence à un attribut (<em>attributeref</em> dans la grammaire formelle ci-dessous) est une primaire suivie par un point et un nom :</p>
<pre>
<strong id="grammar-token-python-grammar-attributeref"><span id="grammar-token-attributeref"></span>attributeref</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;.&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p id="index-40">La primaire doit s'évaluer à un objet d'un type qui gère les références aux attributs, ce qui est le cas de la plupart des objets. Cet objet doit alors produire l'attribut dont le nom est « identifier ». Cette production peut être personnalisée en surchargeant la méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code>. Si l'attribut n'est pas disponible, une exception <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> est levée. Sinon, le type et la valeur de l'objet produit sont déterminés par l'objet. Plusieurs évaluations successives d'une référence à un même attribut peuvent produire différents objets.</p>
</section>
<section id="subscriptions">
<span id="id6"></span><h3><span class="section-number">6.3.2. </span>Indiçage (ou sélections)<a class="headerlink" href="#subscriptions" title="Lien permanent vers ce titre">¶</a></h3>
<span class="target" id="index-41"></span><p id="index-42">L'indiçage d'une instance de <a class="reference internal" href="datamodel.html#sequence-types"><span class="std std-ref">classe containeur</span></a> sélectionne généralement un élément du conteneur. L'indiçage d'une <a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">classe générique</span></a> renvoie généralement un objet <a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias</span></a>.</p>
<pre>
<strong id="grammar-token-python-grammar-subscription"><span id="grammar-token-subscription"></span>subscription</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> &quot;]&quot;
</pre>
<p>Lorsqu'on accède à l'indice d'un objet, l'interpréteur évalue la primaire et la liste d'expressions.</p>
<p>L'évaluation de la primaire doit produire un objet qui gère l'indiçage. Un objet est susceptible de gérer l'indiçage s'il définit la ou les deux méthodes <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> et <a class="reference internal" href="datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>. Quand on spécifie un indice du primaire, le résultat de l'évaluation de la liste d'expression est passé à l'une de ces méthodes. Pour plus de détails sur le choix de <code class="docutils literal notranslate"><span class="pre">__class_getitem__</span></code> ou <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> pour l'appel, lisez <a class="reference internal" href="datamodel.html#classgetitem-versus-getitem"><span class="std std-ref">__class_getitem__ contre __getitem__</span></a>.</p>
<p>Si la liste d'expressions contient au moins une virgule, elle est considérée comme un <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">n-uplet</span></code></a> contenant les éléments de la liste d'expressions. Sinon, la liste d'expressions est évaluée à la valeur du seul membre de la liste.</p>
<p>Pour les objets natifs, deux types d'objets gèrent la sélection <em>via</em> <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> :</p>
<ol class="arabic simple">
<li><p>Si la primaire est un <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">tableau de correspondances</span></a>, la liste d'expressions (<em>expression_list</em> dans la grammaire formelle ci-dessous) doit pouvoir être évaluée comme un objet dont la valeur est une des clés du tableau de correspondances et la sélection désigne la valeur qui correspond à cette clé. Un exemple de classe implémentant le concept de tableau de correspondances est la classe <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.</p></li>
<li><p>Si la primaire est une <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">séquence</span></a>, la liste d'expressions (<em>expression_list</em> dans la grammaire) doit pouvoir être évaluée comme un <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">entier</span></code></a> ou une <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">tranche</span></code></a> (comme expliqué dans la section suivante). Des exemples de classes natives implémentant le concept de séquence sont les <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">chaînes</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">listes</span></code></a> et les <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">n-uplets</span></code></a>.</p></li>
</ol>
<p>The formal syntax makes no special provision for negative indices in
<a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequences</span></a>. However, built-in sequences all provide a <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>
method that interprets negative indices by adding the length of the sequence
to the index so that, for example, <code class="docutils literal notranslate"><span class="pre">x[-1]</span></code> selects the last item of <code class="docutils literal notranslate"><span class="pre">x</span></code>. The
resulting value must be a nonnegative integer less than the number of items in
the sequence, and the subscription selects the item whose index is that value
(counting from zero). Since the support for negative indices and slicing
occurs in the object's <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method, subclasses overriding
this method will need to explicitly add that support.</p>
<p id="index-43">Une <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">chaîne</span></code></a> est une espèce particulière de séquence dont les éléments sont des <em>caractères</em>. Un caractère n'est pas un type en tant que tel, c'est une chaîne de longueur un.</p>
</section>
<section id="slicings">
<span id="id7"></span><h3><span class="section-number">6.3.3. </span>Tranches<a class="headerlink" href="#slicings" title="Lien permanent vers ce titre">¶</a></h3>
<span class="target" id="index-44"></span><p id="index-45">Une tranche (<em>slicing</em> dans la grammaire formelle ci-dessous) sélectionne un intervalle d'éléments d'un objet séquence (par exemple une chaîne, un n-uplet ou une liste, respectivement les types <em>string</em>, <em>tuple</em> et <em>list</em>). Les tranches peuvent être utilisées comme des expressions ou des cibles dans les affectations ou les instructions <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a>. La syntaxe est la suivante :</p>
<pre>
<strong id="grammar-token-python-grammar-slicing"><span id="grammar-token-slicing"></span>slicing     </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-python-grammar-slice_list"><code class="xref docutils literal notranslate"><span class="pre">slice_list</span></code></a> &quot;]&quot;
<strong id="grammar-token-python-grammar-slice_list"><span id="grammar-token-slice-list"></span>slice_list  </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-slice_item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-slice_item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-slice_item"><span id="grammar-token-slice-item"></span>slice_item  </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-proper_slice"><code class="xref docutils literal notranslate"><span class="pre">proper_slice</span></code></a>
<strong id="grammar-token-python-grammar-proper_slice"><span id="grammar-token-proper-slice"></span>proper_slice</strong> ::=  [<a class="reference internal" href="#grammar-token-python-grammar-lower_bound"><code class="xref docutils literal notranslate"><span class="pre">lower_bound</span></code></a>] &quot;:&quot; [<a class="reference internal" href="#grammar-token-python-grammar-upper_bound"><code class="xref docutils literal notranslate"><span class="pre">upper_bound</span></code></a>] [ &quot;:&quot; [<a class="reference internal" href="#grammar-token-python-grammar-stride"><code class="xref docutils literal notranslate"><span class="pre">stride</span></code></a>] ]
<strong id="grammar-token-python-grammar-lower_bound"><span id="grammar-token-lower-bound"></span>lower_bound </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-upper_bound"><span id="grammar-token-upper-bound"></span>upper_bound </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-stride"><span id="grammar-token-stride"></span>stride      </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>Il existe une ambigüité dans la syntaxe formelle ci-dessus : tout ce qui ressemble à une liste d'expressions (<em>expression_list</em> vue avant) ressemble aussi à une liste de tranches (<em>slice_list</em> dans la grammaire ci-dessus). En conséquence, toute sélection (<em>subscription</em> dans la grammaire) peut être interprétée comme une tranche. Plutôt que de compliquer encore la syntaxe, l'ambigüité est levée en disant que, dans ce cas, l'interprétation en tant que sélection (<em>subscription</em>) est prioritaire sur l'interprétation en tant que tranche (c'est le cas si la liste de tranches (<em>slice_list</em>) ne contient aucune tranche en tant que telle).</p>
<p id="index-46">The semantics for a slicing are as follows.  The primary is indexed (using the
same <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method as
normal subscription) with a key that is constructed from the slice list, as
follows.  If the slice list contains at least one comma, the key is a tuple
containing the conversion of the slice items; otherwise, the conversion of the
lone slice item is the key.  The conversion of a slice item that is an
expression is that expression.  The conversion of a proper slice is a slice
object (see section <a class="reference internal" href="datamodel.html#types"><span class="std std-ref">Hiérarchie des types standards</span></a>) whose <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> attributes are the values of the
expressions given as lower bound, upper bound and stride, respectively,
substituting <code class="docutils literal notranslate"><span class="pre">None</span></code> for missing expressions.</p>
</section>
<section id="calls">
<span id="index-47"></span><span id="id8"></span><h3><span class="section-number">6.3.4. </span>Appels<a class="headerlink" href="#calls" title="Lien permanent vers ce titre">¶</a></h3>
<p>Un appel (<em>call</em> dans la grammaire ci-dessous) appelle un objet appelable (par exemple, une <a class="reference internal" href="../glossary.html#term-function"><span class="xref std std-term">fonction</span></a>) avec, possiblement, une liste d'<a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">arguments</span></a> :</p>
<pre>
<strong id="grammar-token-python-grammar-call"><span id="grammar-token-call"></span>call                </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-python-grammar-argument_list"><code class="xref docutils literal notranslate"><span class="pre">argument_list</span></code></a> [&quot;,&quot;] | <a class="reference internal" href="#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;)&quot;
<strong id="grammar-token-python-grammar-argument_list"><span id="grammar-token-argument-list"></span>argument_list       </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-positional_arguments"><code class="xref docutils literal notranslate"><span class="pre">positional_arguments</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-starred_and_keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a>]
                            [&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-python-grammar-starred_and_keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>
<strong id="grammar-token-python-grammar-positional_arguments"><span id="grammar-token-positional-arguments"></span>positional_arguments</strong> ::=  positional_item (&quot;,&quot; positional_item)*
<strong id="grammar-token-python-grammar-positional_item"><span id="grammar-token-positional-item"></span>positional_item     </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-starred_and_keywords"><span id="grammar-token-starred-and-keywords"></span>starred_and_keywords</strong> ::=  (&quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)
                          (&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)*
<strong id="grammar-token-python-grammar-keywords_arguments"><span id="grammar-token-keywords-arguments"></span>keywords_arguments  </strong> ::=  (<a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)
                          (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)*
<strong id="grammar-token-python-grammar-keyword_item"><span id="grammar-token-keyword-item"></span>keyword_item        </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>Une virgule finale (optionnelle) peut être présente, après les arguments positionnels et nommés, mais elle n'affecte pas la sémantique.</p>
<p id="index-48">La primaire doit s'évaluer à un objet appelable (une fonction définie par l'utilisateur, une fonction native, une méthode d'objet natif, un objet de classe, une méthode d'instance de classe ou tout objet possédant une méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code> est un appelable). Toutes les expressions des arguments sont évaluées avant que l'appel ne soit exécuté. Référez-vous à la section <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Définition de fonctions</span></a> pour la syntaxe des listes de <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">paramètres</span></a> formels.</p>
<p>Si des arguments par mots-clés sont présents, ils sont d'abord convertis en arguments positionnels, comme suit. Pour commencer, une liste de <em>slots</em> vides est créée pour les paramètres formels. S'il y a N arguments positionnels, ils sont placés dans les N premiers <em>slots</em>. Ensuite, pour chaque argument par mot-clé, l'identifiant est utilisé pour déterminer le <em>slot</em> correspondant (si l'identifiant est le même que le nom du premier paramètre formel, le premier <em>slot</em> est utilisé, et ainsi de suite). Si le <em>slot</em> est déjà rempli, une exception <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> est levée. Sinon, l'argument est placé dans le <em>slot</em>, ce qui le remplit (même si l'expression est <code class="docutils literal notranslate"><span class="pre">None</span></code>, cela remplit le <em>slot</em>). Quand tous les arguments ont été traités, les <em>slots</em> qui sont toujours vides sont remplis avec la valeur par défaut correspondante dans la définition de la fonction (les valeurs par défaut sont calculées, une seule fois, lorsque la fonction est définie ; ainsi, un objet mutable tel qu'une liste ou un dictionnaire utilisé en tant valeur par défaut sera partagé entre tous les appels qui ne spécifient pas de valeur d argument pour ce <em>slot</em> ; on évite généralement de faire ça). S'il reste des <em>slots</em> pour lesquels aucune valeur par défaut n'est définie, une exception <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> est levée. Sinon, la liste des <em>slots</em> remplie est utilisée en tant que liste des arguments pour l'appel.</p>
<div class="impl-detail compound">
<p><strong>Particularité de l'implémentation CPython :</strong> Une implémentation peut fournir des fonctions natives dont les paramètres positionnels n'ont pas de nom, même s'ils sont « nommés » pour les besoins de la documentation. Ils ne peuvent donc pas être spécifiés par mot-clé. En CPython, les fonctions implémentées en C qui utilisent <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> pour analyser leurs arguments en font partie.</p>
</div>
<p>S'il y a plus d'arguments positionnels que de <em>slots</em> de paramètres formels, une exception <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> est levée, à moins qu'un paramètre formel n'utilise la syntaxe <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> ; dans ce cas, le paramètre formel reçoit un <em>n</em>-uplet contenant les arguments positionnels en supplément (ou un <em>n</em>-uplet vide s'il n'y avait pas d'argument positionnel en trop).</p>
<p>Si un argument par mot-clé ne correspond à aucun nom de paramètre formel, une exception <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> est levée, à moins qu'un paramètre formel n'utilise la syntaxe <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> ; dans ce cas, le paramètre formel reçoit un dictionnaire contenant les arguments par mot-clé en trop (en utilisant les mots-clés comme clés et les arguments comme valeurs pour ce dictionnaire), ou un (nouveau) dictionnaire vide s'il n'y a pas d'argument par mot-clé en trop.</p>
<p id="index-49">Si la syntaxe <code class="docutils literal notranslate"><span class="pre">*expression</span></code> apparaît dans l'appel de la fonction, <code class="docutils literal notranslate"><span class="pre">expression</span></code> doit pouvoir s'évaluer à un <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">itérable</span></a>. Les éléments de ces itérables sont traités comme s'ils étaient des arguments positionnels supplémentaires. Pour l'appel <code class="docutils literal notranslate"><span class="pre">f(x1,</span> <span class="pre">x2,</span> <span class="pre">*y,</span> <span class="pre">x3,</span> <span class="pre">x4)</span></code>, si <em>y</em> s'évalue comme une séquence <em>y1</em> … <em>yM</em>, c'est équivalent à un appel avec M+4 arguments positionnels <em>x1</em>, <em>x2</em>, <em>y1</em> … <em>yM</em>, <em>x3</em>, <em>x4</em>.</p>
<p>Une conséquence est que bien que la syntaxe <code class="docutils literal notranslate"><span class="pre">*expression</span></code> puisse apparaître <em>après</em> les arguments par nommés explicites, ils sont traités <em>avant</em> les arguments nommés (et avant tout argument <code class="docutils literal notranslate"><span class="pre">**expression</span></code> -- voir ci-dessous). Ainsi :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">2 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">f() got multiple values for keyword argument &#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">1 2</span>
</pre></div>
</div>
<p>Il est inhabituel que les syntaxes d'arguments par mots-clés et <code class="docutils literal notranslate"><span class="pre">*expression</span></code> soient utilisés simultanément dans un même appel, ce qui fait que la confusion reste rare.</p>
<p id="index-50">If the syntax <code class="docutils literal notranslate"><span class="pre">**expression</span></code> appears in the function call, <code class="docutils literal notranslate"><span class="pre">expression</span></code> must
evaluate to a <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>, the contents of which are treated as
additional keyword arguments. If a parameter matching a key has already been
given a value (by an explicit keyword argument, or from another unpacking),
a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception is raised.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">**expression</span></code> is used, each key in this mapping must be
a string.
Each value from the mapping is assigned to the first formal parameter
eligible for keyword assignment whose name is equal to the key.
A key need not be a Python identifier (e.g. <code class="docutils literal notranslate"><span class="pre">&quot;max-temp</span> <span class="pre">°F&quot;</span></code> is acceptable,
although it will not match any formal parameter that could be declared).
If there is no match to a formal parameter
the key-value pair is collected by the <code class="docutils literal notranslate"><span class="pre">**</span></code> parameter, if there is one,
or if there is not, a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception is raised.</p>
<p>Les paramètres formels qui utilisent la syntaxe <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> ou <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> ne peuvent pas être utilisés comme arguments positionnels ou comme noms d'arguments par mots-clés.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>Les appels de fonction acceptent n'importe quel nombre de dépaquetages par <code class="docutils literal notranslate"><span class="pre">*</span></code> ou <code class="docutils literal notranslate"><span class="pre">**</span></code>. Des arguments positionnels peuvent suivre les dépaquetages d'itérables (<code class="docutils literal notranslate"><span class="pre">*</span></code>) et les arguments par mots-clés peuvent suivre les dépaquetages de dictionnaires (<code class="docutils literal notranslate"><span class="pre">**</span></code>). Proposé pour la première fois par la <span class="target" id="index-119"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a>.</p>
</div>
<p>Un appel renvoie toujours une valeur, possiblement <code class="docutils literal notranslate"><span class="pre">None</span></code>, à moins qu'il ne lève une exception. La façon dont celle valeur est calculée dépend du type de l'objet appelable.</p>
<p>Si c'est</p>
<dl>
<dt>une fonction définie par l'utilisateur :</dt><dd><p id="index-52">le bloc de code de la fonction est exécuté, il reçoit la liste des arguments. La première chose que le bloc de code fait est de lier les paramètres formels aux arguments ; ceci est décrit dans la section <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Définition de fonctions</span></a>. Quand le bloc de code exécute l'instruction <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>, cela spécifie la valeur de retour de l'appel de la fonction.</p>
</dd>
<dt>une fonction ou une méthode native :</dt><dd><p id="index-53">le résultat dépend de l'interpréteur ; lisez <a class="reference internal" href="../library/functions.html#built-in-funcs"><span class="std std-ref">Fonctions natives</span></a> pour une description des fonctions et méthodes natives.</p>
</dd>
<dt>un objet classe :</dt><dd><p id="index-54">une nouvelle instance de cette classe est renvoyée.</p>
</dd>
<dt>une méthode d'instance de classe :</dt><dd><p id="index-55">la fonction correspondante définie par l'utilisateur est appelée, avec la liste d'arguments qui est plus grande d'un élément que la liste des arguments de l'appel : l'instance est placée en tête des arguments.</p>
</dd>
<dt>une instance de classe :</dt><dd><p id="index-56">la classe doit définir une méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code> ; l'effet est le même que si cette méthode était appelée.</p>
</dd>
</dl>
</section>
</section>
<section id="await-expression">
<span id="await"></span><span id="index-57"></span><h2><span class="section-number">6.4. </span>Expression <code class="docutils literal notranslate"><span class="pre">await</span></code><a class="headerlink" href="#await-expression" title="Lien permanent vers ce titre">¶</a></h2>
<p>Suspend l'exécution de la <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> sur un objet <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a>. Ne peut être utilisée qu'à l'intérieur d'une <a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">coroutine function</span></a>.</p>
<pre>
<strong id="grammar-token-python-grammar-await_expr"><span id="grammar-token-await-expr"></span>await_expr</strong> ::=  &quot;await&quot; <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a>
</pre>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.5.</span></p>
</div>
</section>
<section id="the-power-operator">
<span id="power"></span><h2><span class="section-number">6.5. </span>L'opérateur puissance<a class="headerlink" href="#the-power-operator" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-58">L'opérateur puissance est plus prioritaire que les opérateurs unaires sur sa gauche ; il est moins prioritaire que les opérateurs unaires sur sa droite. La syntaxe est :</p>
<pre>
<strong id="grammar-token-python-grammar-power"><span id="grammar-token-power"></span>power</strong> ::=  (<a class="reference internal" href="#grammar-token-python-grammar-await_expr"><code class="xref docutils literal notranslate"><span class="pre">await_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a>) [&quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>]
</pre>
<p>Ainsi, dans une séquence sans parenthèse de puissance et d'opérateurs unaires, les opérateurs sont évalués de droite à gauche (ceci ne contraint pas l'ordre d'évaluation des opérandes) : <code class="docutils literal notranslate"><span class="pre">-1**2</span></code> donne <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
<p>L'opérateur puissance possède la même sémantique que la fonction native <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> lorsqu'elle est appelée avec deux arguments : il produit son argument de gauche élevé à la puissance de son argument de droite. Les arguments numériques sont d'abord convertis vers un type commun et le résultat est de ce type.</p>
<p>Pour les opérandes entiers, le résultat est du même type à moins que le deuxième argument ne soit négatif ; dans ce cas, tous les arguments sont convertis en nombres à virgule flottante et le résultat est un nombre à virgule flottante. Par exemple, <code class="docutils literal notranslate"><span class="pre">10**2</span></code> renvoie <code class="docutils literal notranslate"><span class="pre">100</span></code> mais <code class="docutils literal notranslate"><span class="pre">10**-2</span></code> renvoie <code class="docutils literal notranslate"><span class="pre">0.01</span></code>.</p>
<p>Élever <code class="docutils literal notranslate"><span class="pre">0.0</span></code> à une puissance négative entraîne une <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a>. Élever un nombre négatif à une puissance fractionnaire renvoie un nombre <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complexe</span></code></a> (dans les versions antérieures, cela levait une <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>).</p>
<p>La méthode spéciale qui permet de surcharger cet opérateur est <code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code>.</p>
</section>
<section id="unary-arithmetic-and-bitwise-operations">
<span id="unary"></span><h2><span class="section-number">6.6. </span>Arithmétique unaire et opérations sur les bits<a class="headerlink" href="#unary-arithmetic-and-bitwise-operations" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-59">Toute l'arithmétique unaire et les opérations sur les bits ont la même priorité :</p>
<pre>
<strong id="grammar-token-python-grammar-u_expr"><span id="grammar-token-u-expr"></span>u_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-power"><code class="xref docutils literal notranslate"><span class="pre">power</span></code></a> | &quot;-&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;+&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;~&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
</pre>
<p id="index-60">L'opérateur unaire <code class="docutils literal notranslate"><span class="pre">-</span></code> (moins) produit l'opposé de son argument numérique (la méthode spéciale qui le surcharge est <code class="xref py py-meth docutils literal notranslate"><span class="pre">__neg__()</span></code>) ;</p>
<p id="index-61">L'opérateur unaire <code class="docutils literal notranslate"><span class="pre">+</span></code> (plus) produit son argument numérique inchangé (surcharge par la méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">__pos__()</span></code>) ;</p>
<p id="index-62">L'opérateur unaire <code class="docutils literal notranslate"><span class="pre">~</span></code> (inversion) produit l'inversion bit à bit de son argument entier. L'inversion bit à bit de <code class="docutils literal notranslate"><span class="pre">x</span></code> est définie comme <code class="docutils literal notranslate"><span class="pre">-(x+1)</span></code>. Elle ne s'applique qu'aux nombres entiers et aux objets personnalisés qui surchargent la méthode spéciale <code class="xref py py-meth docutils literal notranslate"><span class="pre">__invert__()</span></code>.</p>
<p id="index-63">Dans ces trois cas, si l'argument n'est pas du bon type, une exception <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> est levée.</p>
</section>
<section id="binary-arithmetic-operations">
<span id="binary"></span><h2><span class="section-number">6.7. </span>Opérations arithmétiques binaires<a class="headerlink" href="#binary-arithmetic-operations" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-64">Les opérations arithmétiques binaires suivent les conventions pour les priorités. Notez que certaines de ces opérations s'appliquent aussi à des types non numériques. À part l'opérateur puissance, il n'y a que deux niveaux, le premier pour les opérateurs multiplicatifs et le second pour les opérateurs additifs :</p>
<pre>
<strong id="grammar-token-python-grammar-m_expr"><span id="grammar-token-m-expr"></span>m_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;&#64;&quot; <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> |
            <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;//&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;/&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> |
            <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;%&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
<strong id="grammar-token-python-grammar-a_expr"><span id="grammar-token-a-expr"></span>a_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;+&quot; <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;-&quot; <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a>
</pre>
<p id="index-65">L'opérateur <code class="docutils literal notranslate"><span class="pre">*</span></code> (multiplication) produit le produit de ses arguments. Les deux arguments doivent être des nombres ou alors le premier argument doit être un entier et l'autre doit être une séquence. Dans le premier cas, les nombres sont convertis dans un type commun puis sont multipliés entre eux. Dans le dernier cas, la séquence est répétée ; une répétition négative produit une séquence vide.</p>
<p>Les méthodes spéciales qui permettent de surcharger cet opérateur sont <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code> et <code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code>.</p>
<p id="index-66">L'opérateur <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> (prononcé <em>at</em> en anglais) a vocation à multiplier des matrices. Aucun type Python natif n'implémente cet opérateur.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.5.</span></p>
</div>
<p id="index-67">Les opérateurs <code class="docutils literal notranslate"><span class="pre">/</span></code> (division) et <code class="docutils literal notranslate"><span class="pre">//</span></code> (division entière ou <em>floor division</em> en anglais) produisent le quotient de leurs arguments. Les arguments numériques sont d'abord convertis vers un type commun. La division d'entiers produit un nombre à virgule flottante alors que la division entière d'entiers produit un entier ; le résultat est celui de la division mathématique suivie de la fonction <code class="docutils literal notranslate"><span class="pre">floor</span></code> appliquée au résultat. Une division par zéro lève une exception <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a>.</p>
<p>Les méthodes spéciales qui permettent de surcharger ces opérations sont <code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code> et <code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code>.</p>
<p id="index-68">L'opérateur <code class="docutils literal notranslate"><span class="pre">%</span></code> (modulo) produit le reste de la division entière du premier argument par le second. Les arguments numériques sont d'abord convertis vers un type commun. Un zéro en second argument lève une exception <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a>. Les arguments peuvent être des nombres à virgule flottante, par exemple <code class="docutils literal notranslate"><span class="pre">3.14%0.7</span></code> vaut <code class="docutils literal notranslate"><span class="pre">0.34</span></code> (puisque <code class="docutils literal notranslate"><span class="pre">3.14</span></code> égale <code class="docutils literal notranslate"><span class="pre">4*0.7+0.34</span></code>). L'opérateur modulo produit toujours un résultat du même signe que le second opérande (ou zéro) ; la valeur absolue du résultat est strictement inférieure à la valeur absolue du second opérande <a class="footnote-reference brackets" href="#id17" id="id9">1</a>.</p>
<p>Les opérateurs division entière et modulo sont liés par la relation suivante : <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x//y)*y</span> <span class="pre">+</span> <span class="pre">(x%y)</span></code>. La division entière et le module sont aussi liés à la fonction native  <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> : <code class="docutils literal notranslate"><span class="pre">divmod(x,</span> <span class="pre">y)</span> <span class="pre">==</span> <span class="pre">(x//y,</span> <span class="pre">x%y)</span></code> <a class="footnote-reference brackets" href="#id18" id="id10">2</a>.</p>
<p>En plus de calculer le modulo sur les nombres, l'opérateur <code class="docutils literal notranslate"><span class="pre">%</span></code> est aussi surchargé par les objets chaînes de caractères pour effectuer le formatage de chaîne « à l'ancienne ». La syntaxe pour le formatage de chaînes est décrit dans la référence de la bibliothèque Python, dans la section  <a class="reference internal" href="../library/stdtypes.html#old-string-formatting"><span class="std std-ref">Formatage de chaines à la printf</span></a>.</p>
<p>La méthode spéciale qui permet de surcharger cette opération est <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code>.</p>
<p>L'opérateur de division entière, l'opérateur modulo et la fonction  <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> ne sont pas définis pour les nombres complexes. À la place, vous pouvez, si cela a du sens pour ce que vous voulez faire, les convertir vers des nombres à virgule flottante en utilisant la fonction <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a>.</p>
<p id="index-69">L'opérateur <code class="docutils literal notranslate"><span class="pre">+</span></code> (addition) produit la somme de ses arguments. Les arguments doivent être tous les deux des nombres ou des séquences du même type. Dans le premier cas, les nombres sont convertis vers un type commun puis sont additionnés entre eux. Dans le dernier cas, les séquences sont concaténées.</p>
<p>Les méthodes spéciales qui permettent de surcharger cette opération sont <code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code> et <code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code>.</p>
<p id="index-70">L'opérateur <code class="docutils literal notranslate"><span class="pre">-</span></code> (soustraction) produit la différence entre ses arguments. Les arguments numériques sont d'abord convertis vers un type commun.</p>
<p>La méthode spéciale qui permet de surcharger cette opération est <code class="xref py py-meth docutils literal notranslate"><span class="pre">__sub__()</span></code>.</p>
</section>
<section id="shifting-operations">
<span id="shifting"></span><h2><span class="section-number">6.8. </span>Opérations de décalage<a class="headerlink" href="#shifting-operations" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-71">Les opérations de décalage sont moins prioritaires que les opérations arithmétiques :</p>
<pre>
<strong id="grammar-token-python-grammar-shift_expr"><span id="grammar-token-shift-expr"></span>shift_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> (&quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot;) <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a>
</pre>
<p>Ces opérateurs prennent des entiers comme arguments. Ils décalent le premier argument vers la gauche ou vers la droite du nombre de bits donné par le deuxième argument.</p>
<p>Les méthodes spéciales qui permettent de surcharger ces opérations sont <code class="xref py py-meth docutils literal notranslate"><span class="pre">__lshift__()</span></code> et <code class="xref py py-meth docutils literal notranslate"><span class="pre">__rshift__()</span></code>.</p>
<p id="index-72">Un décalage à droite de <em>n</em> bits est défini comme la division entière par <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code>. Un décalage à gauche de <em>n</em> bits est défini comme la multiplication par <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code>.</p>
</section>
<section id="binary-bitwise-operations">
<span id="bitwise"></span><h2><span class="section-number">6.9. </span>Opérations binaires bit à bit<a class="headerlink" href="#binary-bitwise-operations" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-73">Chacune des trois opérations binaires bit à bit possède une priorité différente :</p>
<pre>
<strong id="grammar-token-python-grammar-and_expr"><span id="grammar-token-and-expr"></span>and_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> &quot;&amp;&quot; <a class="reference internal" href="#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a>
<strong id="grammar-token-python-grammar-xor_expr"><span id="grammar-token-xor-expr"></span>xor_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> &quot;^&quot; <a class="reference internal" href="#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a>
<strong id="grammar-token-python-grammar-or_expr"><span id="grammar-token-or-expr"></span>or_expr </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a>
</pre>
<p id="index-74">L'opérateur <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> produit le ET logique de ses arguments. Ils doivent être des entiers, sauf si celui de gauche surcharge la méthode spéciale <code class="xref py py-meth docutils literal notranslate"><span class="pre">__and__()</span></code>, ou celui de droite la méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">__rand__()</span></code>.</p>
<p id="index-75">L'opérateur <code class="docutils literal notranslate"><span class="pre">^</span></code> produit le OU EXCLUSIF (XOR) logique de ses arguments. Ils doivent être des entiers, sauf à surcharger <code class="xref py py-meth docutils literal notranslate"><span class="pre">__xor__()</span></code> ou <code class="xref py py-meth docutils literal notranslate"><span class="pre">__rxor__()</span></code>.</p>
<p id="index-76">L'opérateur <code class="docutils literal notranslate"><span class="pre">|</span></code> produit le OU logique de ses arguments. Ils doivent être des entiers, sauf à surcharger <code class="xref py py-meth docutils literal notranslate"><span class="pre">__or__()</span></code> ou <code class="xref py py-meth docutils literal notranslate"><span class="pre">__ror__()</span></code>.</p>
</section>
<section id="comparisons">
<span id="id11"></span><h2><span class="section-number">6.10. </span>Comparaisons<a class="headerlink" href="#comparisons" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-77">Au contraire du C, toutes les opérations de comparaison en Python possèdent la même priorité, qui est plus faible que celle des opérations arithmétiques, décalages ou binaires bit à bit. Toujours contrairement au C, les expressions telles que <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">c</span></code> sont interprétées comme elles le seraient conventionnellement en mathématiques :</p>
<pre>
<strong id="grammar-token-python-grammar-comparison"><span id="grammar-token-comparison"></span>comparison   </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> (<a class="reference internal" href="#grammar-token-python-grammar-comp_operator"><code class="xref docutils literal notranslate"><span class="pre">comp_operator</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>)*
<strong id="grammar-token-python-grammar-comp_operator"><span id="grammar-token-comp-operator"></span>comp_operator</strong> ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;!=&quot;
                   | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;
</pre>
<p>Les comparaisons donnent des valeurs booléennes (<code class="docutils literal notranslate"><span class="pre">True</span></code> ou <code class="docutils literal notranslate"><span class="pre">False</span></code>). Cependant, les <em class="dfn">méthodes de comparaison riche</em> définies par l'utilisateur peuvent renvoyer des non-booléens. Dans ce cas, le résultat de la comparaison est converti en booléen avec <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> dans les contextes qui attendent un booléen.</p>
<p id="index-78">Les comparaisons peuvent être enchaînées arbitrairement, par exemple <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> est équivalent à <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code>, sauf que <code class="docutils literal notranslate"><span class="pre">y</span></code> est évalué seulement une fois (mais dans les deux cas, <code class="docutils literal notranslate"><span class="pre">z</span></code> n'est pas évalué du tout si <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> s'avère être faux).</p>
<p>Formellement, si <em>a</em>, <em>b</em>, <em>c</em> … <em>y</em>, <em>z</em> sont des expressions et <em>op1</em>, <em>op2</em> … <em>opN</em> sont des opérateurs de comparaison, alors <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">…</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> est équivalent à <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">and</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">and</span> <span class="pre">…</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code>, sauf que chaque expression est évaluée au maximum une fois.</p>
<p>Notez que <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span></code> n'implique aucune comparaison entre <em>a</em> et <em>c</em>. Ainsi, par exemple, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> est parfaitement légal (mais peut-être pas très élégant).</p>
<section id="value-comparisons">
<span id="expressions-value-comparisons"></span><h3><span class="section-number">6.10.1. </span>Comparaisons de valeurs<a class="headerlink" href="#value-comparisons" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les opérateurs <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> et  <code class="docutils literal notranslate"><span class="pre">!=</span></code> comparent les valeurs de deux objets. Les objets n'ont pas besoin d'être du même type.</p>
<p>Le chapitre <a class="reference internal" href="datamodel.html#objects"><span class="std std-ref">Objets, valeurs et types</span></a> indique que les objets ont une valeur (en plus d'un type et d'un identifiant). La valeur d'un objet est une notion plutôt abstraite en Python : par exemple, il n'existe pas de méthode canonique pour accéder à la valeur d'un objet. De la même manière, il n'y a aucune obligation concernant la construction de la valeur d'un objet, par exemple qu'elle prenne en compte toutes les données de ses attributs. Les opérateurs de comparaison implémentent une notion particulière de ce qu'est la valeur d'un objet. Vous pouvez vous le représenter comme une définition indirecte de la valeur d'un objet, <em>via</em> l'implémentation de leur comparaison.</p>
<p>Comme tous les types sont des sous-types (directs ou indirects) de la classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>, ils héritent du comportement de comparaison par défaut de <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>.  Les types peuvent personnaliser le comportement des comparaisons en implémentant des <em class="dfn">méthodes de comparaisons riches</em>, comme <code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code>, décrites dans <a class="reference internal" href="datamodel.html#customization"><span class="std std-ref">Personnalisation de base</span></a>.</p>
<p>Le comportement par défaut pour le test d'égalité (<code class="docutils literal notranslate"><span class="pre">==</span></code> et <code class="docutils literal notranslate"><span class="pre">!=</span></code>) se base sur les identifiants des objets. Ainsi, un test d'égalité entre deux instances qui ont le même identifiant est vrai, un test d'égalité entre deux instances qui ont des identifiants différents est faux. La raison de ce choix est que Python souhaite que tous les objets soient réflexifs, c'est-à-dire que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> implique <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>.</p>
<p>La relation d'ordre (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> et <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) n'est pas fournie par défaut ; une tentative se solde par une <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. La raison de ce choix est qu'il n'existe pas d'invariant similaire à celui de l'égalité.</p>
<p>Le comportement du test d'égalité par défaut, à savoir que les instances avec des identités différentes ne sont jamais égales, peut être en contradiction avec les types qui définissent la « valeur » d'un objet et se basent sur cette « valeur » pour l'égalité. De tels types doivent personnaliser leurs tests de comparaison et, en fait, c'est ce qu'ont fait un certain nombre de types natifs.</p>
<p>La liste suivante décrit le comportement des tests d'égalité pour les types natifs les plus importants.</p>
<ul>
<li><p>Beaucoup de types numériques natifs (<a class="reference internal" href="../library/stdtypes.html#typesnumeric"><span class="std std-ref">Types numériques — int, float, complex</span></a>) et de types de la bibliothèque standard <a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> ainsi que <code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.decimal</span></code> peuvent être comparés, au sein de leur propre classe ou avec d'autres objets de classes différentes. Une exception notable concerne les nombres complexes qui ne gèrent pas la relation d'ordre. Dans les limites des types concernés, la comparaison mathématique équivaut à la comparaison algorithmique, sans perte de précision.</p>
<p>Les valeurs non numériques <code class="docutils literal notranslate"><span class="pre">float('NaN')</span></code> et <code class="docutils literal notranslate"><span class="pre">decimal.Decimal('NaN')</span></code> sont spéciales : toute comparaison entre un nombre et une valeur non numérique est fausse. Une implication contre-intuitive à cela est que les valeurs non numériques ne sont pas égales à elles-mêmes. Par exemple, avec <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">float('NaN')</span></code>, les expressions <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">&lt;</span> <span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> et <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></code> sont toutes fausses, mais l’expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">x</span></code> est vraie. Ce comportement est en accord avec IEEE 754.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> et <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> sont des singletons. <span class="target" id="index-120"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a> conseille de toujours comparer les singletons en utilisant soit <code class="docutils literal notranslate"><span class="pre">is</span></code> soit <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code>, jamais les autres opérateurs.</p></li>
<li><p>Les séquences binaires (instances du type <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> ou <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) peuvent être comparées au sein de la classe et entre classes. La comparaison est lexicographique, en utilisant la valeur numérique des éléments.</p></li>
<li><p>Les chaînes de caractères (instances de <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) respectent l'ordre lexicographique en utilisant la valeur Unicode (le résultat de la fonction native <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a>) des caractères <a class="footnote-reference brackets" href="#id19" id="id12">3</a>.</p>
<p>Les chaînes de caractères et les séquences binaires ne peuvent pas être comparées directement.</p>
</li>
<li><p>Les séquences (instances de <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> ou <a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a>) peuvent être comparées uniquement entre instances de même type, en sachant que les intervalles (<em>range</em>) ne gèrent pas la relation d'ordre. Le test d'égalité entre ces types renvoie faux et une comparaison entre instances de types différents lève une  <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p>Les séquences se comparent lexicographiquement en comparant les éléments correspondants. Les conteneurs natifs supposent généralement que les objets identiques sont égaux à eux-mêmes. Cela leur permet d'économiser les tests d’égalité pour des objets identiques afin d’améliorer les performances et de conserver leurs invariants internes.</p>
<p>L'ordre lexicographique pour les collections natives fonctionne comme suit :</p>
<ul class="simple">
<li><p>Deux collections sont égales si elles sont du même type, ont la même longueur et si les éléments correspondants de chaque paire sont égaux. Par exemple, <code class="docutils literal notranslate"><span class="pre">[1,2]</span> <span class="pre">==</span> <span class="pre">(1,2)</span></code> est faux car les types sont différents.</p></li>
<li><p>Les collections qui gèrent la relation d'ordre sont ordonnées comme leur premier élément différent (par exemple, <code class="docutils literal notranslate"><span class="pre">[1,2,x]</span> <span class="pre">&lt;=</span> <span class="pre">[1,2,y]</span></code> a la même valeur que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code>). Si un élément n'a pas de correspondant, la collection la plus courte est la plus petite (par exemple, <code class="docutils literal notranslate"><span class="pre">[1,2]</span> <span class="pre">&lt;</span> <span class="pre">[1,2,3]</span></code> est vrai).</p></li>
</ul>
</li>
<li><p>Mappings (instances of <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) compare equal if and only if they have
equal <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> pairs. Equality comparison of the keys and values
enforces reflexivity.</p>
<p>Les comparaisons (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> et <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) lèvent <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
</li>
<li><p>Les ensembles (instances de <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> ou <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>) peuvent être comparés au sein de leur propre type et entre types différents.</p>
<p>Les opérateurs d'inclusion et de sur-ensemble sont définis. Ces relations ne sont pas des relations d'ordre total (par exemple, les deux ensembles <code class="docutils literal notranslate"><span class="pre">{1,2}</span></code> et <code class="docutils literal notranslate"><span class="pre">{2,3}</span></code> ne sont pas égaux, l'un n'est pas inclus dans l'autre, l'un n'est pas un sur-ensemble de l'autre). Ainsi, les ensembles ne sont pas des arguments appropriés pour les fonctions qui dépendent d'un ordre total (par exemple, les fonctions <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> et <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> produisent des résultats indéfinis si on leur donne des listes d'ensembles en entrée).</p>
<p>La comparaison des ensembles met en œuvre la réflexivité des éléments.</p>
</li>
<li><p>La plupart des autres types natifs n'implémentent pas de méthodes de comparaisons, ils héritent donc du comportement par défaut.</p></li>
</ul>
<p>Les classes définies par l'utilisateur qui particularisent les opérations de comparaison doivent, si possible, respecter quelques règles pour la cohérence :</p>
<ul>
<li><p>Le test d'égalité doit être réflexif. En d'autres termes, des objets identiques doivent être égaux :</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> implique <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code></p>
</div></blockquote>
</li>
<li><p>La comparaison doit être symétrique. En d'autres termes, les expressions suivantes doivent donner le même résultat :</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> et <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code> et <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">!=</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> et <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> et <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x</span></code></p>
</div></blockquote>
</li>
<li><p>La comparaison doit être transitive. Les exemples suivants (liste non exhaustive) illustrent ce concept :</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> implique <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">z</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> implique <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">z</span></code></p>
</div></blockquote>
</li>
<li><p>Si vous inversez la comparaison, cela doit en produire la négation booléenne. En d'autres termes, les expressions suivantes doivent produire le même résultat :</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> et <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> et <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code> (pour une relation d'ordre total)</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> et <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> (pour une relation d'ordre total)</p>
</div></blockquote>
<p>Ces deux dernières expressions s'appliquent pour les collections totalement ordonnées (par exemple, les séquences mais pas les ensembles ou les tableaux de correspondances). Regardez aussi le décorateur <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">total_ordering()</span></code></a>.</p>
</li>
<li><p>Le résultat de <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> doit être cohérent avec l'égalité. Les objets qui sont égaux doivent avoir la même empreinte ou être marqués comme non-hachables.</p></li>
</ul>
<p>Python ne vérifie pas ces règles de cohérence. En fait, l'utilisation de valeurs non numériques est un exemple de non-respect de ces règles.</p>
</section>
<section id="membership-test-operations">
<span id="membership-test-details"></span><span id="not-in"></span><span id="in"></span><h3><span class="section-number">6.10.2. </span>Opérations de tests d’appartenance à un ensemble<a class="headerlink" href="#membership-test-operations" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les opérateurs <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> et <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> testent l’appartenance. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> s’évalue à <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>x</em> appartient à <em>s</em> et à <code class="docutils literal notranslate"><span class="pre">False</span></code> sinon. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code> renvoie la négation de <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code>. Tous les types séquences et ensembles natifs gèrent ces opérateurs, ainsi que les dictionnaires pour lesquels <code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> teste si dictionnaire possède une clé donnée. Pour les types conteneurs tels que les listes, <em>n</em>-uplets (<em>tuple</em>), ensembles (<em>set</em>), ensembles figés (<em>frozen set</em>), dictionnaires (<em>dict</em>) ou <em>collections.deque</em>, l’expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> est équivalente à <code class="docutils literal notranslate"><span class="pre">any(x</span> <span class="pre">is</span> <span class="pre">e</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">e</span> <span class="pre">for</span> <span class="pre">e</span> <span class="pre">in</span> <span class="pre">y)</span></code>.</p>
<p>Pour les chaînes de caractères et chaînes d'octets, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> vaut <code class="docutils literal notranslate"><span class="pre">True</span></code> si et seulement si <em>x</em> est une sous-chaîne de <em>y</em>. Un test équivalent est <code class="docutils literal notranslate"><span class="pre">y.find(x)</span> <span class="pre">!=</span> <span class="pre">-1</span></code>. Une chaîne vide est considérée comme une sous-chaîne de toute autre chaîne, ainsi <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></code> renvoie <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>Pour les classes définies par l'utilisateur qui définissent la méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> renvoie <code class="docutils literal notranslate"><span class="pre">True</span></code> si <code class="docutils literal notranslate"><span class="pre">y.__contains__(x)</span></code> renvoie vrai, et <code class="docutils literal notranslate"><span class="pre">False</span></code> sinon.</p>
<p>Pour les classes définies par l'utilisateur qui ne définissent pas <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code> mais qui définissent <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> vaut <code class="docutils literal notranslate"><span class="pre">True</span></code> s'il existe une valeur <code class="docutils literal notranslate"><span class="pre">z</span></code> telle que l'expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">z</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">z</span></code> renvoie vrai lors de l'itération sur <code class="docutils literal notranslate"><span class="pre">y</span></code>. Si une exception est levée pendant l'itération, c'est comme si <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> avait levé cette exception.</p>
<p>Lastly, the old-style iteration protocol is tried: if a class defines
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> if and only if there is a non-negative
integer index <em>i</em> such that <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y[i]</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y[i]</span></code>, and no lower integer index
raises the <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> exception.  (If any other exception is raised, it is as
if <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> raised that exception).</p>
<p id="index-80">L'opérateur <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> est défini comme produisant le contraire de <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>.</p>
</section>
<section id="is-not">
<span id="is"></span><span id="index-81"></span><span id="identity-comparisons"></span><h3><span class="section-number">6.10.3. </span>Comparaisons d'identifiants<a class="headerlink" href="#is-not" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les opérateurs <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> et <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a> testent l'égalité des identifiants des objets : <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> est vrai si et seulement si <em>x</em> et <em>y</em> sont le même objet. L'identifiant d'un objet est déterminé en utilisant la fonction <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id()</span></code></a>. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">y</span></code> renvoie le résultat contraire de l'égalité des identifiants <a class="footnote-reference brackets" href="#id20" id="id13">4</a>.</p>
</section>
</section>
<section id="boolean-operations">
<span id="not"></span><span id="or"></span><span id="and"></span><span id="booleans"></span><h2><span class="section-number">6.11. </span>Opérations booléennes<a class="headerlink" href="#boolean-operations" title="Lien permanent vers ce titre">¶</a></h2>
<pre id="index-82">
<strong id="grammar-token-python-grammar-or_test"><span id="grammar-token-or-test"></span>or_test </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;or&quot; <a class="reference internal" href="#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a>
<strong id="grammar-token-python-grammar-and_test"><span id="grammar-token-and-test"></span>and_test</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> &quot;and&quot; <a class="reference internal" href="#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
<strong id="grammar-token-python-grammar-not_test"><span id="grammar-token-not-test"></span>not_test</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-comparison"><code class="xref docutils literal notranslate"><span class="pre">comparison</span></code></a> | &quot;not&quot; <a class="reference internal" href="#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
</pre>
<p>In the context of Boolean operations, and also when expressions are used by
control flow statements, the following values are interpreted as false:
<code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>, numeric zero of all types, and empty strings and containers
(including strings, tuples, lists, dictionaries, sets and frozensets).  All
other values are interpreted as true.  User-defined objects can customize their
truth value by providing a <a class="reference internal" href="datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> method.</p>
<p id="index-83">L'opérateur <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> produit <code class="docutils literal notranslate"><span class="pre">True</span></code> si son argument est faux, <code class="docutils literal notranslate"><span class="pre">False</span></code> sinon.</p>
<p id="index-84">L'expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code> commence par évaluer <em>x</em> ; si <em>x</em> est faux, sa valeur est renvoyée ; sinon, <em>y</em> est évalué et la valeur résultante est renvoyée.</p>
<p id="index-85">L'expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code> commence par évaluer <em>x</em> ; si <em>x</em> est vrai, sa valeur est renvoyée ; sinon, <em>y</em> est évalué et la valeur résultante est renvoyée.</p>
<p>Notez que ni <a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a> ni <a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a> ne restreignent la valeur et le type qu'ils renvoient à <code class="docutils literal notranslate"><span class="pre">False</span></code> et <code class="docutils literal notranslate"><span class="pre">True</span></code> : ils renvoient le dernier argument évalué. Ceci peut être utile, par exemple : si une chaîne <code class="docutils literal notranslate"><span class="pre">s</span></code> doit être remplacée par une valeur par défaut si elle est vide, l'expression <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">or</span> <span class="pre">'truc'</span></code> produit la valeur voulue. Comme <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> doit créer une nouvelle valeur, il renvoie une valeur booléenne quel que soit le type de son argument (par exemple, <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">'truc'</span></code> produit <code class="docutils literal notranslate"><span class="pre">False</span></code> plutôt que <code class="docutils literal notranslate"><span class="pre">''</span></code>.</p>
</section>
<section id="assignment-expressions">
<span id="index-86"></span><h2><span class="section-number">6.12. </span>Expressions d'affectation<a class="headerlink" href="#assignment-expressions" title="Lien permanent vers ce titre">¶</a></h2>
<pre>
<strong id="grammar-token-python-grammar-assignment_expression"><span id="grammar-token-assignment-expression"></span>assignment_expression</strong> ::=  [<a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;:=&quot;] <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>Une expression d'affectation (parfois aussi appelée « expression nommée » ou « expression morse ») affecte l'<a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression</span></code></a> à un <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref std std-token docutils literal notranslate"><span class="pre">identifiant</span></code></a> et renvoie la valeur de l'<a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression</span></code></a>.</p>
<p>Une utilisation classique concerne les correspondances d'expressions rationnelles :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">matching</span> <span class="o">:=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">(</span><span class="n">matching</span><span class="p">)</span>
</pre></div>
</div>
<p>Ou lorsqu'on traite le contenu d'un fichier par morceaux :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">chunk</span> <span class="o">:=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">9000</span><span class="p">):</span>
    <span class="n">process</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</pre></div>
</div>
<p>Assignment expressions must be surrounded by parentheses when used
as sub-expressions in slicing, conditional, lambda,
keyword-argument, and comprehension-if expressions
and in <code class="docutils literal notranslate"><span class="pre">assert</span></code> and <code class="docutils literal notranslate"><span class="pre">with</span></code> statements.
In all other places where they can be used, parentheses are not required,
including in <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code> statements.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.8: </span>Voir la <span class="target" id="index-121"></span><a class="pep reference external" href="https://peps.python.org/pep-0572/"><strong>PEP 572</strong></a> pour plus de détails sur les expressions d’affectation.</p>
</div>
</section>
<section id="conditional-expressions">
<span id="if-expr"></span><h2><span class="section-number">6.13. </span>Expressions conditionnelles<a class="headerlink" href="#conditional-expressions" title="Lien permanent vers ce titre">¶</a></h2>
<pre id="index-88">
<strong id="grammar-token-python-grammar-conditional_expression"><span id="grammar-token-conditional-expression"></span>conditional_expression</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [&quot;if&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-python-grammar-expression"><span id="grammar-token-expression"></span>expression            </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-conditional_expression"><code class="xref docutils literal notranslate"><span class="pre">conditional_expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-lambda_expr"><code class="xref docutils literal notranslate"><span class="pre">lambda_expr</span></code></a>
</pre>
<p>Les expressions conditionnelles (parfois appelées « opérateur ternaire ») sont les moins prioritaires de toutes les opérations Python.</p>
<p>L'expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">if</span> <span class="pre">C</span> <span class="pre">else</span> <span class="pre">y</span></code> commence par évaluer la condition <em>C</em>. Si <em>C</em> est vrai, alors <em>x</em> est évalué et sa valeur est renvoyée ; sinon, <em>y</em> est évalué et sa valeur est renvoyée.</p>
<p>Voir la <span class="target" id="index-122"></span><a class="pep reference external" href="https://peps.python.org/pep-0308/"><strong>PEP 308</strong></a> pour plus de détails sur les expressions conditionnelles.</p>
</section>
<section id="lambda">
<span id="lambdas"></span><span id="id14"></span><h2><span class="section-number">6.14. </span>Expressions lambda<a class="headerlink" href="#lambda" title="Lien permanent vers ce titre">¶</a></h2>
<pre id="index-90">
<strong id="grammar-token-python-grammar-lambda_expr"><span id="grammar-token-lambda-expr"></span>lambda_expr</strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-python-grammar-parameter_list"><code class="xref docutils literal notranslate"><span class="pre">parameter_list</span></code></a>] &quot;:&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>Les expressions lambda sont utilisées pour créer des fonctions anonymes. L'expression <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">parameters:</span> <span class="pre">expression</span></code> produit un objet fonction. Cet objet anonyme se comporte comme un objet fonction défini par :</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def &lt;lambda&gt;(parameters):
    return expression
</pre></div>
</div>
<p>Voir la section <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Définition de fonctions</span></a> pour la syntaxe des listes de paramètres. Notez que les fonctions créées par des expressions lambda ne peuvent pas contenir d'instructions ou d'annotations.</p>
</section>
<section id="expression-lists">
<span id="exprlists"></span><h2><span class="section-number">6.15. </span>Listes d'expressions<a class="headerlink" href="#expression-lists" title="Lien permanent vers ce titre">¶</a></h2>
<pre id="index-91">
<strong id="grammar-token-python-grammar-expression_list"><span id="grammar-token-expression-list"></span>expression_list   </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-starred_list"><span id="grammar-token-starred-list"></span>starred_list      </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-starred_expression"><span id="grammar-token-starred-expression"></span>starred_expression</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | (<a class="reference internal" href="#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a> &quot;,&quot;)* [<a class="reference internal" href="#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a>]
<strong id="grammar-token-python-grammar-starred_item"><span id="grammar-token-starred-item"></span>starred_item      </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
</pre>
<p id="index-92">Sauf lorsqu'elle fait partie d'un agencement de liste ou d'ensemble, une liste d'expressions qui contient au moins une virgule produit un <em>n</em>-uplet. La longueur du <em>n</em>-uplet est le nombre d'expressions dans la liste. Les expressions sont évaluées de la gauche vers la droite.</p>
<p id="index-93">Un astérisque <code class="docutils literal notranslate"><span class="pre">*</span></code> indique <em class="dfn">dépaquetage d'itérable</em> (<em>iterable unpacking</em> en anglais). Son opérande doit être un <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>. L'itérable est développé en une séquence d'éléments qui sont inclus dans un nouvel objet <em>n</em>-uplet, liste ou ensemble à l'emplacement du dépaquetage.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.5: </span>dépaquetage d'itérables dans les listes d'expressions, proposé à l'origine par la <span class="target" id="index-123"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a>.</p>
</div>
<p id="index-95">La virgule finale est nécessaire pour créer un singleton (c'est-à-dire un n-uplet composé d'un seul élément) : elle est optionnelle dans tous les autres cas. Une expression seule sans virgule finale ne crée pas un <em>n</em>-uplet mais produit la valeur de cette expression (pour créer un <em>n</em>-uplet vide, utilisez une paire de parenthèses vide : <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</section>
<section id="evaluation-order">
<span id="evalorder"></span><h2><span class="section-number">6.16. </span>Ordre d'évaluation<a class="headerlink" href="#evaluation-order" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-96">Python évalue les expressions de la gauche vers la droite. Remarquez que lors de l'évaluation d'une affectation, la partie droite de l'affectation est évaluée avant la partie gauche.</p>
<p>Dans les lignes qui suivent, les expressions sont évaluées suivant l'ordre arithmétique de leurs suffixes :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span>
<span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span><span class="p">)</span>
<span class="p">{</span><span class="n">expr1</span><span class="p">:</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">:</span> <span class="n">expr4</span><span class="p">}</span>
<span class="n">expr1</span> <span class="o">+</span> <span class="n">expr2</span> <span class="o">*</span> <span class="p">(</span><span class="n">expr3</span> <span class="o">-</span> <span class="n">expr4</span><span class="p">)</span>
<span class="n">expr1</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="o">*</span><span class="n">expr4</span><span class="p">,</span> <span class="o">**</span><span class="n">expr5</span><span class="p">)</span>
<span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span> <span class="o">=</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span>
</pre></div>
</div>
</section>
<section id="operator-precedence">
<span id="operator-summary"></span><h2><span class="section-number">6.17. </span>Priorités des opérateurs<a class="headerlink" href="#operator-precedence" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-97">The following table summarizes the operator precedence in Python, from highest
precedence (most binding) to lowest precedence (least binding).  Operators in
the same box have the same precedence.  Unless the syntax is explicitly given,
operators are binary.  Operators in the same box group left to right (except for
exponentiation and conditional expressions, which group from right to left).</p>
<p>Notez que les comparaisons, les tests d'appartenance et les tests d'identifiants possèdent tous la même priorité et s'enchaînent de la gauche vers la droite comme décrit dans la section <a class="reference internal" href="#comparisons"><span class="std std-ref">Comparaisons</span></a>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 56%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Opérateur</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">(expressions…)</span></code>,</p>
<p><code class="docutils literal notranslate"><span class="pre">[expressions…]</span></code>, <code class="docutils literal notranslate"><span class="pre">{key:</span> <span class="pre">value…}</span></code>, <code class="docutils literal notranslate"><span class="pre">{expressions…}</span></code></p>
</td>
<td><p>Expression de liaison ou parenthèse, affichage de liste, affichage de dictionnaire, affichage de <em>set</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x[indice]</span></code>, <code class="docutils literal notranslate"><span class="pre">x[indice:indice]</span></code>, <code class="docutils literal notranslate"><span class="pre">x(arguments…)</span></code>, <code class="docutils literal notranslate"><span class="pre">x.attribut</span></code></p></td>
<td><p>indiçage, tranches, appel, référence à un attribut</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span> <span class="pre">x</span></code></a></p></td>
<td><p>Expression <code class="docutils literal notranslate"><span class="pre">await</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">**</span></code></p></td>
<td><p>Puissance <a class="footnote-reference brackets" href="#id21" id="id15">5</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">+x</span></code>, <code class="docutils literal notranslate"><span class="pre">-x</span></code>, <code class="docutils literal notranslate"><span class="pre">~x</span></code></p></td>
<td><p>NOT (positif, négatif, bit à bit)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code></p></td>
<td><p>Multiplication, multiplication de matrices, division, division entière, reste <a class="footnote-reference brackets" href="#id22" id="id16">6</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>Addition et soustraction</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code></p></td>
<td><p>décalages</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
<td><p>AND (bit à bit)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
<td><p>XOR (bit à bit)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">|</span></code></p></td>
<td><p>OR (bit à bit)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>, <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>,
<a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>, <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
<td><p>Comparaisons, y compris les tests d'appartenance et les tests d'identifiants</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span></code></a></p></td>
<td><p>NOT (booléen)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a></p></td>
<td><p>AND (booléen)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a></p></td>
<td><p>OR (booléen)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#if-expr"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> -- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></p></td>
<td><p>Expressions conditionnelles</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a></p></td>
<td><p>Expression lambda</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">:=</span></code></p></td>
<td><p>Expression d'affectation</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="footnote brackets">
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id9">1</a></span></dt>
<dd><p>Bien que <code class="docutils literal notranslate"><span class="pre">abs(x%y)</span> <span class="pre">&lt;</span> <span class="pre">abs(y)</span></code> soit vrai mathématiquement, ce n'est pas toujours vrai pour les nombres à virgule flottante en raison des arrondis. Par exemple, en supposant que Python tourne sur une plateforme où les <em>float</em> sont des nombres à double précision IEEE 754, afin que <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">%</span> <span class="pre">1e100</span></code> soit du même signe que <code class="docutils literal notranslate"><span class="pre">1e100</span></code>, le résultat calculé est <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">+</span> <span class="pre">1e100</span></code>, qui vaut exactement <code class="docutils literal notranslate"><span class="pre">1e100</span></code> dans ce standard. Or, la fonction <a class="reference internal" href="../library/math.html#math.fmod" title="math.fmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.fmod()</span></code></a> renvoie un résultat dont le signe est le signe du premier argument, c'est-à-dire <code class="docutils literal notranslate"><span class="pre">-1e-100</span></code> dans ce cas. La meilleure approche dépend de l'application.</p>
</dd>
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id10">2</a></span></dt>
<dd><p>Si x est très proche d'un multiple entier de y, il est possible que <code class="docutils literal notranslate"><span class="pre">x/y</span></code> soit supérieur de un par rapport à <code class="docutils literal notranslate"><span class="pre">(x-x%y)//y</span></code> en raison des arrondis. Dans de tels cas, Python renvoie le second résultat afin d'avoir <code class="docutils literal notranslate"><span class="pre">divmod(x,y)[0]</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> le plus proche de <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id12">3</a></span></dt>
<dd><p>Le standard Unicode distingue les <em class="dfn">points codes</em> (<em>code points</em> en anglais, par exemple <em>U+0041</em>) et les <em class="dfn">caractères abstraits</em> (<em>abstract characters</em> en anglais, par exemple « LATIN CAPITAL LETTER A »). Bien que la plupart des caractères abstraits de l'Unicode ne sont représentés que par un seul point code, il y a un certain nombre de caractères abstraits qui peuvent être représentés par une séquence de plus qu'un point code. Par exemple, le caractère abstrait « LATIN CAPITAL LETTER C WITH CEDILLA » peut être représenté comme un unique <em class="dfn">caractère précomposé</em> au point code <em>U+00C7</em>, ou en tant que séquence d'un <em class="dfn">caractère de base</em> à la position <em>U+0043</em> (LATIN CAPITAL LETTER C) du code, suivi par un <em class="dfn">caractère combiné</em> à la position <em>U+0327</em> (<em>COMBINING CEDILLA</em>) du code.</p>
<p>Les opérateurs de comparaison des chaînes opèrent au niveau des points codes Unicode. Cela peut être déroutant pour des humains. Par exemple, <code class="docutils literal notranslate"><span class="pre">&quot;\u00C7&quot;</span> <span class="pre">==</span> <span class="pre">&quot;\u0043\u0327&quot;</span></code> renvoie <code class="docutils literal notranslate"><span class="pre">False</span></code>, bien que les deux chaînes représentent le même caractère abstrait &quot;LATIN CAPITAL LETTER C WITH CEDILLA&quot;.</p>
<p>Pour comparer des chaînes au niveau des caractères abstraits (afin d'avoir quelque chose d'intuitif pour les humains), utilisez <a class="reference internal" href="../library/unicodedata.html#unicodedata.normalize" title="unicodedata.normalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">unicodedata.normalize()</span></code></a>.</p>
</dd>
<dt class="label" id="id20"><span class="brackets"><a class="fn-backref" href="#id13">4</a></span></dt>
<dd><p>En raison du ramasse-miettes automatique et de la nature dynamique des descripteurs, vous pouvez être confronté à un comportement semblant bizarre lors de certaines utilisations de l'opérateur <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>, par exemple si cela implique des comparaisons entre des méthodes d'instances ou des constantes. Allez vérifier dans la documentation pour plus d'informations.</p>
</dd>
<dt class="label" id="id21"><span class="brackets"><a class="fn-backref" href="#id15">5</a></span></dt>
<dd><p>L'opérateur puissance <code class="docutils literal notranslate"><span class="pre">**</span></code> est moins prioritaire qu'un opérateur unaire arithmétique ou bit à bit sur sa droite. Ainsi, <code class="docutils literal notranslate"><span class="pre">2**-1</span></code> vaut <code class="docutils literal notranslate"><span class="pre">0.5</span></code>.</p>
</dd>
<dt class="label" id="id22"><span class="brackets"><a class="fn-backref" href="#id16">6</a></span></dt>
<dd><p>L'opérateur <code class="docutils literal notranslate"><span class="pre">%</span></code> est aussi utilisé pour formater les chaînes de caractères ; il y possède la même priorité.</p>
</dd>
</dl>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#">6. Expressions</a><ul>
<li><a class="reference internal" href="#arithmetic-conversions">6.1. Conversions arithmétiques</a></li>
<li><a class="reference internal" href="#atoms">6.2. Atomes</a><ul>
<li><a class="reference internal" href="#atom-identifiers">6.2.1. Identifiants (noms)</a></li>
<li><a class="reference internal" href="#literals">6.2.2. Littéraux</a></li>
<li><a class="reference internal" href="#parenthesized-forms">6.2.3. Formes parenthésées</a></li>
<li><a class="reference internal" href="#displays-for-lists-sets-and-dictionaries">6.2.4. Agencements des listes, ensembles et dictionnaires</a></li>
<li><a class="reference internal" href="#list-displays">6.2.5. Agencements de listes</a></li>
<li><a class="reference internal" href="#set-displays">6.2.6. Agencements d'ensembles</a></li>
<li><a class="reference internal" href="#dictionary-displays">6.2.7. Agencements de dictionnaires</a></li>
<li><a class="reference internal" href="#generator-expressions">6.2.8. Expressions génératrices</a></li>
<li><a class="reference internal" href="#yield-expressions">6.2.9. Expressions <code class="docutils literal notranslate"><span class="pre">yield</span></code></a><ul>
<li><a class="reference internal" href="#generator-iterator-methods">6.2.9.1. Méthodes des générateurs-itérateurs</a></li>
<li><a class="reference internal" href="#examples">6.2.9.2. Exemples</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">6.2.9.3. Fonctions génératrices asynchrones</a></li>
<li><a class="reference internal" href="#asynchronous-generator-iterator-methods">6.2.9.4. Méthodes des générateurs-itérateurs asynchrones</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#primaries">6.3. Primaires</a><ul>
<li><a class="reference internal" href="#attribute-references">6.3.1. Références à des attributs</a></li>
<li><a class="reference internal" href="#subscriptions">6.3.2. Indiçage (ou sélections)</a></li>
<li><a class="reference internal" href="#slicings">6.3.3. Tranches</a></li>
<li><a class="reference internal" href="#calls">6.3.4. Appels</a></li>
</ul>
</li>
<li><a class="reference internal" href="#await-expression">6.4. Expression <code class="docutils literal notranslate"><span class="pre">await</span></code></a></li>
<li><a class="reference internal" href="#the-power-operator">6.5. L'opérateur puissance</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operations">6.6. Arithmétique unaire et opérations sur les bits</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operations">6.7. Opérations arithmétiques binaires</a></li>
<li><a class="reference internal" href="#shifting-operations">6.8. Opérations de décalage</a></li>
<li><a class="reference internal" href="#binary-bitwise-operations">6.9. Opérations binaires bit à bit</a></li>
<li><a class="reference internal" href="#comparisons">6.10. Comparaisons</a><ul>
<li><a class="reference internal" href="#value-comparisons">6.10.1. Comparaisons de valeurs</a></li>
<li><a class="reference internal" href="#membership-test-operations">6.10.2. Opérations de tests d’appartenance à un ensemble</a></li>
<li><a class="reference internal" href="#is-not">6.10.3. Comparaisons d'identifiants</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-operations">6.11. Opérations booléennes</a></li>
<li><a class="reference internal" href="#assignment-expressions">6.12. Expressions d'affectation</a></li>
<li><a class="reference internal" href="#conditional-expressions">6.13. Expressions conditionnelles</a></li>
<li><a class="reference internal" href="#lambda">6.14. Expressions lambda</a></li>
<li><a class="reference internal" href="#expression-lists">6.15. Listes d'expressions</a></li>
<li><a class="reference internal" href="#evaluation-order">6.16. Ordre d'évaluation</a></li>
<li><a class="reference internal" href="#operator-precedence">6.17. Priorités des opérateurs</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="import.html"
                          title="Chapitre précédent"><span class="section-number">5. </span>Le système d'importation</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="simple_stmts.html"
                          title="Chapitre suivant"><span class="section-number">7. </span>Les instructions simples</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/expressions.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. Les instructions simples"
             >suivant</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. Le système d&#39;importation"
             >précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La référence du langage Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">6. </span>Expressions</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Mis à jour le oct. 26, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Créé en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>