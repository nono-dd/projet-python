
<!DOCTYPE html>

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="3. Modèle de données" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/reference/datamodel.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Objets, valeurs et types: En Python, les données sont représentées sous forme d'objets. Toutes les données d'un programme Python sont représentées par des objets ou par des relations entre les obje..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Objets, valeurs et types: En Python, les données sont représentées sous forme d'objets. Toutes les données d'un programme Python sont représentées par des objets ou par des relations entre les obje..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>3. Modèle de données &#8212; Documentation Python 3.12.0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=b37c26da2f7529d09fe70b41c4b2133fe4931a90" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Recherchez dans Documentation Python 3.12.0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="À propos de ces documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="4. Modèle d&#39;exécution" href="executionmodel.html" />
    <link rel="prev" title="2. Analyse lexicale" href="lexical_analysis.html" />
    <link rel="canonical" href="https://docs.python.org/3/reference/datamodel.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" />
                <input type="submit" value="Go"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#">3. Modèle de données</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. Objets, valeurs et types</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. Hiérarchie des types standards</a><ul>
<li><a class="reference internal" href="#none">3.2.1. <code class="docutils literal notranslate"><span class="pre">None</span></code></a></li>
<li><a class="reference internal" href="#notimplemented">3.2.2. NotImplemented</a></li>
<li><a class="reference internal" href="#ellipsis">3.2.3. Ellipse</a></li>
<li><a class="reference internal" href="#numbers-number">3.2.4. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a><ul>
<li><a class="reference internal" href="#numbers-integral">3.2.4.1. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a></li>
<li><a class="reference internal" href="#numbers-real-float">3.2.4.2. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>)</a></li>
<li><a class="reference internal" href="#numbers-complex-complex">3.2.4.3. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequences">3.2.5. Séquences</a><ul>
<li><a class="reference internal" href="#immutable-sequences">3.2.5.1. Séquences immuables</a></li>
<li><a class="reference internal" href="#mutable-sequences">3.2.5.2. Séquences muables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-types">3.2.6. Ensembles</a></li>
<li><a class="reference internal" href="#mappings">3.2.7. Tableaux de correspondances</a><ul>
<li><a class="reference internal" href="#dictionaries">3.2.7.1. Dictionnaires</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callable-types">3.2.8. Types appelables</a><ul>
<li><a class="reference internal" href="#user-defined-functions">3.2.8.1. Fonctions définies par l'utilisateur</a></li>
<li><a class="reference internal" href="#instance-methods">3.2.8.2. Méthodes d'instances</a></li>
<li><a class="reference internal" href="#generator-functions">3.2.8.3. Fonctions génératrices (ou générateurs)</a></li>
<li><a class="reference internal" href="#coroutine-functions">3.2.8.4. Fonctions coroutines</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">3.2.8.5. Fonctions génératrices (ou générateurs) asynchrones</a></li>
<li><a class="reference internal" href="#built-in-functions">3.2.8.6. Fonctions natives</a></li>
<li><a class="reference internal" href="#built-in-methods">3.2.8.7. Méthodes natives</a></li>
<li><a class="reference internal" href="#classes">3.2.8.8. Classes</a></li>
<li><a class="reference internal" href="#class-instances">3.2.8.9. Instances de classe</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modules">3.2.9. Modules</a></li>
<li><a class="reference internal" href="#custom-classes">3.2.10. Classes déclarées par le développeur</a></li>
<li><a class="reference internal" href="#id2">3.2.11. Instances de classe</a></li>
<li><a class="reference internal" href="#i-o-objects-also-known-as-file-objects">3.2.12. Objets entrées-sorties (ou objets fichiers)</a></li>
<li><a class="reference internal" href="#internal-types">3.2.13. Types internes</a><ul>
<li><a class="reference internal" href="#code-objects">3.2.13.1. Objets Code</a></li>
<li><a class="reference internal" href="#frame-objects">3.2.13.2. Objets cadres</a></li>
<li><a class="reference internal" href="#traceback-objects">3.2.13.3. Objets traces d'appels</a></li>
<li><a class="reference internal" href="#slice-objects">3.2.13.4. Objets tranches</a></li>
<li><a class="reference internal" href="#static-method-objects">3.2.13.5. Objets méthodes statiques</a></li>
<li><a class="reference internal" href="#class-method-objects">3.2.13.6. Objets méthodes de classes</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#special-method-names">3.3. Méthodes spéciales</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. Personnalisation de base</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. Personnalisation de l'accès aux attributs</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. Personnalisation de l'accès aux attributs d'un module</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. Implémentation de descripteurs</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. Invocation des descripteurs</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. créneaux prédéfinis (<code class="docutils literal notranslate"><span class="pre">__slots__</span></code>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. Personnalisation de la création de classes</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. Métaclasses</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. Résolution des entrées MRO</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. Détermination de la métaclasse appropriée</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. Préparation de l'espace de nommage de la classe</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. Exécution du corps de la classe</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. Création de l'objet classe</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. Cas d'utilisations des métaclasses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. Personnalisation des instances et vérification des sous-classes</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. Émulation de types génériques</a><ul>
<li><a class="reference internal" href="#the-purpose-of-class-getitem">3.3.5.1. Intention de <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> contre <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. Émulation d'objets appelables</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. Émulation de types conteneurs</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. Émulation de types numériques</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. Gestionnaire de contexte With</a></li>
<li><a class="reference internal" href="#customizing-positional-arguments-in-class-pattern-matching">3.3.10. Arguments positionnels dans le filtrage par motif sur les classes</a></li>
<li><a class="reference internal" href="#emulating-buffer-types">3.3.11. Emulating buffer types</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.12. Recherche des méthodes spéciales</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. Coroutines</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. Objets <em>attendables</em> (<em>awaitable</em>)</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. Objets coroutines</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. Itérateurs asynchrones</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. Gestionnaires de contexte asynchrones</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="lexical_analysis.html"
                          title="Chapitre précédent"><span class="section-number">2. </span>Analyse lexicale</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="Chapitre suivant"><span class="section-number">4. </span>Modèle d'exécution</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/datamodel.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modèle d&#39;exécution"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. Analyse lexicale"
             accesskey="P">précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">La référence du langage Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Modèle de données</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="data-model">
<span id="datamodel"></span><h1><span class="section-number">3. </span>Modèle de données<a class="headerlink" href="#data-model" title="Lien permanent vers ce titre">¶</a></h1>
<section id="objects-values-and-types">
<span id="objects"></span><h2><span class="section-number">3.1. </span>Objets, valeurs et types<a class="headerlink" href="#objects-values-and-types" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-0">En Python, les données sont représentées sous forme <em class="dfn">d'objets</em>. Toutes les données d'un programme Python sont représentées par des objets ou par des relations entre les objets (dans un certain sens, et en conformité avec le modèle de Von Neumann d'« ordinateur à programme enregistré », le code est aussi représenté par des objets).</p>
<span class="target" id="index-1"></span><p>Chaque objet possède un identifiant, un type et une valeur. <em>L'identifiant</em> d'un objet ne change jamais après sa création ; vous pouvez vous le représenter comme l'adresse de l'objet en mémoire. L'opérateur <a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> compare les identifiants de deux objets ; la fonction <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> renvoie un entier représentant cet identifiant.</p>
<div class="impl-detail compound">
<p><strong>Particularité de l'implémentation CPython :</strong> en CPython, <code class="docutils literal notranslate"><span class="pre">id(x)</span></code> est l'adresse mémoire où est stocké <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</div>
<p>Le type de l'objet détermine les opérations que l'on peut appliquer à l'objet (par exemple, « a-t-il une longueur ? ») et définit aussi les valeurs possibles pour les objets de ce type. La fonction <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> renvoie le type de l'objet (qui est lui-même un objet). Comme l'identifiant, le <em class="dfn">type</em> d'un objet ne peut pas être modifié <a class="footnote-reference brackets" href="#id13" id="id1">1</a>.</p>
<p>La <em>valeur</em> de certains objets peut changer. Les objets dont la valeur peut changer sont dits <em>muables</em> (<em>mutable</em> en anglais) ; les objets dont la valeur est définitivement fixée à leur création sont dits <em>immuables</em> (<em>immutable</em> en anglais). La valeur d'un objet conteneur immuable qui contient une référence vers un objet muable peut varier lorsque la valeur de l'objet muable change ; cependant, le conteneur est quand même considéré comme immuable parce que l'ensemble des objets qu'il contient ne peut pas être modifié. Ainsi, l'immuabilité n'est pas strictement équivalente au fait d'avoir une valeur non modifiable, c'est plus subtil. La muabilité d'un objet est définie par son type ; par exemple, les nombres, les chaînes de caractères et les <em>n</em>-uplets sont immuables alors que les dictionnaires et les listes sont muables.</p>
<p id="index-2">Un objet n'est jamais explicitement détruit ; cependant, lorsqu'il ne peut plus être atteint, il a vocation à être supprimé par le ramasse-miettes (<em>garbage-collector</em> en anglais). L'implémentation peut retarder cette opération ou même ne pas la faire du tout — la façon dont fonctionne le ramasse-miette est particulière à chaque implémentation, l'important étant qu'il ne supprime pas d'objet qui peut encore être atteint.</p>
<div class="impl-detail compound">
<p><strong>Particularité de l'implémentation CPython :</strong> CPython utilise aujourd'hui un mécanisme de compteur de références avec une détection, en temps différé et optionnelle, des cycles d'objets. Ce mécanisme supprime la plupart des objets dès qu'ils ne sont plus accessibles mais il ne garantit pas la suppression des objets où il existe des références circulaires. Consultez la documentation du module <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> pour tout ce qui concerne la suppression des cycles. D'autres implémentations agissent différemment et CPython pourrait évoluer. Ne vous reposez pas sur la finalisation immédiate des objets devenus inaccessibles (ainsi, vous devez toujours fermer les fichiers explicitement).</p>
</div>
<p>Notez que si vous utilisez les fonctionnalités de débogage ou de trace de l'implémentation, il est possible que des références qui seraient normalement supprimées soient toujours présentes. Notez aussi que capturer une exception avec l'instruction <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> peut conserver des objets en vie.</p>
<p>Certains objets font référence à des ressources « externes » telles que des fichiers ouverts ou des fenêtres. Ces objets libèrent ces ressources au moment où ils sont supprimés, mais comme le ramasse-miettes ne garantit pas qu'il supprime tous les objets, ces objets fournissent également un moyen explicite de libérer la ressource externe, généralement sous la forme d'une méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code>. Nous incitons fortement les programmeurs à fermer explicitement de tels objets. Les instructions <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> et <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> sont très pratiques pour cela.</p>
<p id="index-3">Certains objets contiennent des références à d'autres objets ; on les appelle <em>conteneurs</em>. Comme exemples de conteneurs, nous pouvons citer les <em>n</em>-uplets, les listes et les dictionnaires. Les références sont parties intégrantes de la valeur d'un conteneur. Dans la plupart des cas, lorsque nous parlons de la valeur d'un conteneur, nous parlons des valeurs, pas des identifiants des objets contenus ; cependant, lorsque nous parlons de la muabilité d'un conteneur, seuls les identifiants des objets immédiatement contenus sont concernés. Ainsi, si un conteneur immuable (comme un <em>n</em>-uplet) contient une référence à un objet muable, sa valeur change si cet objet muable est modifié.</p>
<p>Presque tous les comportements d'un objet dépendent du type de l'objet. Même son identifiant est concerné dans un certain sens : pour les types immuables, les opérations qui calculent de nouvelles valeurs peuvent en fait renvoyer une référence à n'importe quel objet existant avec le même type et la même valeur, alors que pour les objets muables cela n'est pas autorisé. Par exemple, après <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span></code> et <code class="docutils literal notranslate"><span class="pre">b</span></code> peuvent ou non se référer au même objet avec la valeur un, en fonction de l'implémentation. Mais après <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">[]</span> <span class="pre">;</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code>, il est garanti que <code class="docutils literal notranslate"><span class="pre">c</span></code> et <code class="docutils literal notranslate"><span class="pre">d</span></code> font référence à deux listes vides distinctes nouvellement créées. Notez que <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> attribue le même objet à <code class="docutils literal notranslate"><span class="pre">c</span></code> et <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p>
</section>
<section id="the-standard-type-hierarchy">
<span id="types"></span><h2><span class="section-number">3.2. </span>Hiérarchie des types standards<a class="headerlink" href="#the-standard-type-hierarchy" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-4">Vous trouvez ci-dessous une liste des types natifs de Python. Des modules d'extension (écrits en C, Java ou d'autres langages) peuvent définir des types supplémentaires. Les futures versions de Python pourront ajouter des types à cette hiérarchie (par exemple les nombres rationnels, des tableaux d'entiers stockés efficacement, etc.), bien que de tels ajouts se trouvent souvent plutôt dans la bibliothèque standard.</p>
<p id="index-5">Quelques descriptions des types ci-dessous contiennent un paragraphe listant des « attributs spéciaux ». Ces attributs donnent accès à l'implémentation et n'ont, en général, pas vocation à être utilisés. Leur définition peut changer dans le futur.</p>
<section id="none">
<h3><span class="section-number">3.2.1. </span><code class="docutils literal notranslate"><span class="pre">None</span></code><a class="headerlink" href="#none" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-6">Ce type ne possède qu'une seule valeur. Il n'existe qu'un seul objet avec cette valeur. Vous accédez à cet objet avec le nom natif <code class="docutils literal notranslate"><span class="pre">None</span></code>. Il est utilisé pour signifier l'absence de valeur dans de nombreux cas, par exemple pour des fonctions qui ne renvoient rien explicitement. Sa valeur booléenne est fausse.</p>
</section>
<section id="notimplemented">
<h3><span class="section-number">3.2.2. </span>NotImplemented<a class="headerlink" href="#notimplemented" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-7">Ce type ne possède qu'une seule valeur. Il n'existe qu'un seul objet avec cette valeur. Vous accédez à cet objet avec le nom natif <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>. Les méthodes numériques et les comparaisons riches doivent renvoyer cette valeur si elles n'implémentent pas l'opération pour les opérandes fournis (l'interpréteur essaie alors l'opération en permutant les opérandes ou tout autre stratégie de contournement, en fonction de l'opérateur). Il ne doit pas être évalué dans un contexte booléen.</p>
<p>Consultez <a class="reference internal" href="../library/numbers.html#implementing-the-arithmetic-operations"><span class="std std-ref">Implémentation des opérations arithmétiques</span></a> pour davantage de détails.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.9: </span>évaluer <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> dans un contexte booléen est obsolète. Python l'évalue aujourd'hui à <code class="docutils literal notranslate"><span class="pre">True</span></code> mais émet un <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>. Il lèvera une <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> dans une version ultérieure de Python.</p>
</div>
</section>
<section id="ellipsis">
<h3><span class="section-number">3.2.3. </span>Ellipse<a class="headerlink" href="#ellipsis" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-8">Ce type ne possède qu'une seule valeur. Il n'existe qu'un seul objet avec cette valeur. Vous accédez à cet objet avec le littéral <code class="docutils literal notranslate"><span class="pre">...</span></code> ou le nom natif <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code>. Sa valeur booléenne est vraie.</p>
</section>
<section id="numbers-number">
<h3><span class="section-number">3.2.4. </span><a class="reference internal" href="../library/numbers.html#numbers.Number" title="numbers.Number"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a><a class="headerlink" href="#numbers-number" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-9">Ces objets sont créés par les littéraux numériques et renvoyés en tant que résultats par les opérateurs et les fonctions arithmétiques natives. Les objets numériques sont immuables ; une fois créés, leur valeur ne change pas. Les nombres Python sont bien sûr très fortement corrélés aux nombres mathématiques mais ils sont soumis aux limitations des représentations numériques par les ordinateurs.</p>
<p>Les représentations sous forme de chaînes de caractères des objets numériques, produites par <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> et <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, ont les propriétés suivantes :</p>
<ul class="simple">
<li><p>Ce sont des littéraux numériques valides qui, s'ils sont passés au constructeur de leur classe, produisent un objet qui a la valeur numérique de l'objet d'origine.</p></li>
<li><p>La représentation est en base 10, si possible.</p></li>
<li><p>Les zéros en tête, sauf en ce qui concerne un zéro seul avant la virgule (représentée par un point en Python conformément à la convention anglo-saxonne), ne sont pas affichés.</p></li>
<li><p>Les zéros en fin, sauf en ce qui concerne un zéro seul après la virgule, ne sont pas affichés.</p></li>
<li><p>Le signe n'est affiché que lorsque le nombre est négatif.</p></li>
</ul>
<p>Python distingue les entiers, les nombres à virgule flottante et les nombres complexes :</p>
<section id="numbers-integral">
<h4><span class="section-number">3.2.4.1. </span><a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a><a class="headerlink" href="#numbers-integral" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-10">Ils représentent des éléments de l'ensemble mathématique des entiers (positifs ou négatifs).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p id="index-11">Les règles pour la représentation des entiers ont pour objet de donner l'interprétation la plus naturelle pour les opérations de décalage et masquage qui impliquent des entiers négatifs.</p>
</div>
<p>Il existe deux types d'entiers :</p>
<dl>
<dt>Entiers (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>)</dt><dd><p>Ils représentent les nombres, sans limite de taille, sous réserve de pouvoir être stockés en mémoire (virtuelle). Afin de pouvoir effectuer des décalages et appliquer des masques, on considère qu'ils ont une représentation binaire. Les nombres négatifs sont représentés comme une variante du complément à 2, qui donne l'illusion d'une chaîne infinie de bits de signe s'étendant vers la gauche.</p>
</dd>
<dt>Booléens (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>)</dt><dd><p id="index-12">Ils représentent les valeurs <em>faux</em> et <em>vrai</em>. Deux objets, <code class="docutils literal notranslate"><span class="pre">False</span></code> et <code class="docutils literal notranslate"><span class="pre">True</span></code>, sont les seuls objets booléens. Le type booléen est un sous-type du type entier et les valeurs booléennes se comportent comme les valeurs 0 (pour <code class="docutils literal notranslate"><span class="pre">False</span></code>) et 1 (pour <code class="docutils literal notranslate"><span class="pre">True</span></code>) dans presque tous les contextes. L'exception concerne la conversion en chaîne de caractères où <code class="docutils literal notranslate"><span class="pre">&quot;False&quot;</span></code> et <code class="docutils literal notranslate"><span class="pre">&quot;True&quot;</span></code> sont renvoyées.</p>
</dd>
</dl>
</section>
<section id="numbers-real-float">
<h4><span class="section-number">3.2.4.2. </span><a class="reference internal" href="../library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>)<a class="headerlink" href="#numbers-real-float" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-13">Ils représentent les nombres à virgule flottante en double précision, tels que manipulés directement par la machine. Vous dépendez donc de l'architecture machine sous-jacente (et de l'implémentation C ou Java) pour les intervalles gérés et le traitement des débordements. Python ne gère pas les nombres à virgule flottante en précision simple ; les gains en puissance de calcul et mémoire, qui sont généralement la raison de l'utilisation des nombres en simple précision, sont annihilés par le fait que Python encapsule de toute façon ces nombres dans des objets. Il n'y a donc aucune raison de compliquer le langage avec deux types de nombres à virgule flottante.</p>
</section>
<section id="numbers-complex-complex">
<h4><span class="section-number">3.2.4.3. </span><a class="reference internal" href="../library/numbers.html#numbers.Complex" title="numbers.Complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code></a> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>)<a class="headerlink" href="#numbers-complex-complex" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-14">Ils représentent les nombres complexes, sous la forme d'un couple de nombres à virgule flottante en double précision, tels que manipulés directement par la machine. Les mêmes restrictions s'appliquent que pour les nombres à virgule flottante. La partie réelle et la partie imaginaire d'un nombre complexe <code class="docutils literal notranslate"><span class="pre">z</span></code> peuvent être demandées par les attributs en lecture seule <code class="docutils literal notranslate"><span class="pre">z.real</span></code> et <code class="docutils literal notranslate"><span class="pre">z.imag</span></code>.</p>
</section>
</section>
<section id="sequences">
<h3><span class="section-number">3.2.5. </span>Séquences<a class="headerlink" href="#sequences" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-15">Ils représentent des ensembles de taille finie indicés par des entiers positifs ou nuls. La fonction native <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> renvoie le nombre d'éléments de la séquence. Quand la longueur d'une séquence est <em>n</em>, l'ensemble des indices contient les entiers 0, 1, …, <em>n-1</em>. On accède à l'élément d'indice <em>i</em> de la séquence <em>a</em> par <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>.</p>
<p id="index-16">Les séquences peuvent aussi être découpées en tranches (<em>slicing</em> en anglais) : <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> sélectionne tous les éléments d'indice <em>k</em> tel que <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>k</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em>. Quand on l'utilise dans une expression, la tranche est du même type que la séquence. Ceci veut dire que l'ensemble des indices de la tranche est renuméroté de manière à partir de 0.</p>
<p>Quelques séquences gèrent le « découpage étendu » (<em>extended slicing</em> en anglais) avec un troisième paramètre : <code class="docutils literal notranslate"><span class="pre">a[i:j:k]</span></code> sélectionne tous les éléments de <em>a</em> d'indice <em>x</em> où <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code>, avec <em>n</em> <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">0</span></code> et <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>x</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em>.</p>
<p>Les séquences se différencient en fonction de leur muabilité :</p>
<section id="immutable-sequences">
<h4><span class="section-number">3.2.5.1. </span>Séquences immuables<a class="headerlink" href="#immutable-sequences" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-17">Un objet de type de séquence immuable ne peut pas être modifié une fois qu'il a été créé. Si l'objet contient des références à d'autres objets, ces autres objets peuvent être muables et peuvent être modifiés ; cependant, les objets directement référencés par un objet immuable ne peuvent pas être modifiés.</p>
<p>Les types suivants sont des séquences immuables :</p>
<dl id="index-18">
<dt>Chaînes de caractères</dt><dd><p id="index-19">A string is a sequence of values that represent Unicode code points.
All the code points in the range <code class="docutils literal notranslate"><span class="pre">U+0000</span> <span class="pre">-</span> <span class="pre">U+10FFFF</span></code> can be
represented in a string.  Python doesn't have a <span class="c-expr sig sig-inline c"><span class="kt">char</span></span> type;
instead, every code point in the string is represented as a string
object with length <code class="docutils literal notranslate"><span class="pre">1</span></code>.  The built-in function <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a>
converts a code point from its string form to an integer in the
range <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code>; <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> converts an integer in the range
<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> to the corresponding length <code class="docutils literal notranslate"><span class="pre">1</span></code> string object.
<a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> can be used to convert a <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> to
<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> using the given text encoding, and
<a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> can be used to achieve the opposite.</p>
</dd>
<dt><em>n</em>-uplets (<em>tuples</em> en anglais)</dt><dd><p id="index-20">Les éléments d'un <em>n</em>-uplet peuvent être n'importe quel objet Python. Les <em>n</em>-uplets de deux éléments ou plus sont formés par une liste d'expressions dont les éléments sont séparés par des virgules. Un <em>n</em>-uplet composé d'un seul élément (un « singleton ») est formé en suffixant une expression avec une virgule (une expression en tant que telle ne crée pas un <em>n</em>-uplet car les parenthèses doivent rester disponibles pour grouper les expressions). Un <em>n</em>-uplet vide est formé à l'aide d'une paire de parenthèses vide.</p>
</dd>
<dt>Chaînes d'octets (ou <em>bytes</em>)</dt><dd><p id="index-21">Les objets <em>bytes</em> sont des tableaux immuables. Les éléments sont des octets (donc composés de 8 bits), représentés par des entiers dans l'intervalle 0 à 255 inclus. Les littéraux <em>bytes</em> (tels que <code class="docutils literal notranslate"><span class="pre">b'abc'</span></code>) et la fonction native constructeur <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes()</span></code></a> peuvent être utilisés pour créer des objets <em>bytes</em>. Aussi, un objet <em>bytes</em> peut être décodé vers une chaîne <em>via</em> la méthode <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a>.</p>
</dd>
</dl>
</section>
<section id="mutable-sequences">
<h4><span class="section-number">3.2.5.2. </span>Séquences muables<a class="headerlink" href="#mutable-sequences" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-22">Les séquences muables peuvent être modifiées après leur création. Les notations de tranches et de sous-ensembles peuvent être utilisées en tant que cibles d'une affectation ou de l'instruction <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> (suppression).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<span class="target" id="index-23"></span><p id="index-24">The <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> and <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> module provide
additional examples of mutable sequence types.</p>
</div>
<p>Il existe aujourd'hui deux types intrinsèques de séquences muables :</p>
<dl>
<dt>Listes</dt><dd><p id="index-25">N'importe quel objet Python peut être élément d'une liste. Les listes sont créées en plaçant entre crochets une liste d'expressions dont les éléments sont séparés par des virgules (notez que les listes de longueur 0 ou 1 ne sont pas des cas particuliers).</p>
</dd>
<dt>Tableaux d'octets</dt><dd><p id="index-26">Un objet <em>bytearray</em> est un tableau muable. Il est créé par la fonction native constructeur <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a>. À part la propriété d'être muable (et donc de ne pas pouvoir calculer son empreinte par hachage), un tableau d'octets possède la même interface et les mêmes fonctionnalités qu'un objet immuable <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
</dl>
</section>
</section>
<section id="set-types">
<h3><span class="section-number">3.2.6. </span>Ensembles<a class="headerlink" href="#set-types" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-27">Ils représentent les ensembles d'objets, non ordonnés, finis et dont les éléments sont uniques. Tels quels, ils ne peuvent pas être indicés. Cependant, il est possible d'itérer dessus et la fonction native <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> renvoie le nombre d'éléments de l'ensemble. Les utilisations classiques des ensembles sont les tests d'appartenance rapides, la suppression de doublons dans une séquence et le calcul d'opérations mathématiques telles que l'intersection, l'union, la différence et le complémentaire.</p>
<p>Pour les éléments des ensembles, les mêmes règles concernant l'immuabilité s'appliquent que pour les clés de dictionnaires. Notez que les types numériques obéissent aux règles normales pour les comparaisons numériques : si deux nombres sont égaux (pour l'opération de comparaison, par exemple <code class="docutils literal notranslate"><span class="pre">1</span></code> et <code class="docutils literal notranslate"><span class="pre">1.0</span></code>), un seul élément est conservé dans l'ensemble.</p>
<p>Actuellement, il existe deux types d'ensembles natifs :</p>
<dl>
<dt>Ensembles</dt><dd><p id="index-28">Ils représentent les ensembles muables. Un ensemble est créé par la fonction native constructeur <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a> et peut être modifié par la suite à l'aide de différentes méthodes, par exemple <code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code>.</p>
</dd>
<dt>Ensembles figés</dt><dd><p id="index-29">Ils représentent les ensembles immuables. Ils sont créés par la fonction native constructeur <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal notranslate"><span class="pre">frozenset()</span></code></a>. Comme un ensemble figé est immuable et <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hachable</span></a>, il peut être utilisé comme élément d'un autre ensemble ou comme clé de dictionnaire.</p>
</dd>
</dl>
</section>
<section id="mappings">
<h3><span class="section-number">3.2.7. </span>Tableaux de correspondances<a class="headerlink" href="#mappings" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-30">Ils représentent les ensembles finis d'objets indicés par des ensembles index arbitraires. La notation <code class="docutils literal notranslate"><span class="pre">a[k]</span></code> sélectionne l'élément indicé par <code class="docutils literal notranslate"><span class="pre">k</span></code> dans le tableau de correspondances <code class="docutils literal notranslate"><span class="pre">a</span></code> ; elle peut être utilisée dans des expressions, comme cible d'une affectation ou avec l'instruction <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a>. La fonction native <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> renvoie le nombre d'éléments du tableau de correspondances.</p>
<p>Il n'existe actuellement qu'un seul type natif pour les tableaux de correspondances :</p>
<section id="dictionaries">
<h4><span class="section-number">3.2.7.1. </span>Dictionnaires<a class="headerlink" href="#dictionaries" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-31">Ils représentent les ensembles finis d'objets indicés par des valeurs presque arbitraires. Les seuls types de valeurs non reconnus comme clés sont les valeurs contenant des listes, des dictionnaires ou les autres types muables qui sont comparés par valeur plutôt que par l'identifiant de l'objet. La raison de cette limitation est qu'une implémentation efficace de dictionnaire requiert que l'empreinte par hachage des clés reste constante dans le temps. Les types numériques obéissent aux règles normales pour les comparaisons numériques : si deux nombres sont égaux pour l'opération de comparaison, par exemple <code class="docutils literal notranslate"><span class="pre">1</span></code> et <code class="docutils literal notranslate"><span class="pre">1.0</span></code>, alors ces deux nombres peuvent être utilisés indifféremment pour désigner la même entrée du dictionnaire.</p>
<p>Les dictionnaires préservent l’ordre d’insertion, ce qui signifie que les clés sont renvoyées séquentiellement dans le même ordre que celui de l’insertion. Remplacer une clé existante ne change pas l’ordre. Par contre, la retirer puis la réinsérer la met à la fin et non à sa précédente position.</p>
<p>Les dictionnaires sont muables : ils peuvent être créés par la notation <code class="docutils literal notranslate"><span class="pre">{…}</span></code> (reportez-vous à la section <a class="reference internal" href="expressions.html#dict"><span class="std std-ref">Agencements de dictionnaires</span></a>).</p>
<p id="index-32">Les modules d'extensions <a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The standard &quot;database&quot; interface, based on ndbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.ndbm</span></code></a> et <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU's reinterpretation of dbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.gnu</span></code></a> apportent d'autres exemples de types tableaux de correspondances, de même que le module <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>les dictionnaires ne conservaient pas l’ordre d’insertion dans les versions antérieures à Python 3.6. Dans CPython 3.6, l’ordre d’insertion était déjà conservé, mais considéré comme un détail d’implémentation et non comme une garantie du langage.</p>
</div>
</section>
</section>
<section id="callable-types">
<h3><span class="section-number">3.2.8. </span>Types appelables<a class="headerlink" href="#callable-types" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-33">Ce sont les types sur lesquels on peut faire un appel de fonction (lisez la section <a class="reference internal" href="expressions.html#calls"><span class="std std-ref">Appels</span></a>) :</p>
<section id="user-defined-functions">
<h4><span class="section-number">3.2.8.1. </span>Fonctions définies par l'utilisateur<a class="headerlink" href="#user-defined-functions" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-34">Un objet fonction définie par l'utilisateur (mais ce n'est pas forcément l'utilisateur courant qui a défini cette fonction) est créé par la définition d'une fonction (voir la section <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Définition de fonctions</span></a>). Il doit être appelé avec une liste d'arguments contenant le même nombre d'éléments que la liste des paramètres formels de la fonction.</p>
<p>Attributs spéciaux :</p>
<table class="docutils align-default" id="index-35">
<colgroup>
<col style="width: 37%" />
<col style="width: 46%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribut</p></th>
<th class="head"><p>Signification</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></p></td>
<td><p>Texte de documentation de la fonction ou <code class="docutils literal notranslate"><span class="pre">None</span></code> s'il n'en existe pas ; n'est pas héritée par les sous-classes.</p></td>
<td><p>Accessible en écriture</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></p></td>
<td><p>Nom de la fonction.</p></td>
<td><p>Accessible en écriture</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__qualname__</span></code></a></p></td>
<td><p><a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">Nom qualifié</span></a> de la fonction.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.3.</span></p>
</div>
</td>
<td><p>Accessible en écriture</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></p></td>
<td><p>Nom du module où la fonction est définie ou <code class="docutils literal notranslate"><span class="pre">None</span></code> si ce nom n'est pas disponible.</p></td>
<td><p>Accessible en écriture</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults__</span></code></p></td>
<td><p><em>N</em>-uplet contenant les valeurs des arguments par défaut pour ceux qui en sont dotés ou <code class="docutils literal notranslate"><span class="pre">None</span></code> si aucun argument n'a de valeur par défaut.</p></td>
<td><p>Accessible en écriture</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code></p></td>
<td><p>Objet code représentant le corps de la fonction compilée.</p></td>
<td><p>Accessible en écriture</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__globals__</span></code></p></td>
<td><p>Référence pointant vers le dictionnaire contenant les variables globales de la fonction — l'espace de noms global du module dans lequel la fonction est définie.</p></td>
<td><p>Accessible en lecture seule</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a></p></td>
<td><p>Espace de nommage accueillant les attributs de la fonction.</p></td>
<td><p>Accessible en écriture</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__closure__</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">None</span></code> ou <em>n</em>-uplet de cellules qui contient un lien pour chaque variable libre de la fonction. Voir ci-dessous pour les informations relatives à l'attribut <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code>.</p></td>
<td><p>Accessible en lecture seule</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></p></td>
<td><p>Dictionnaire contenant les annotations des paramètres. Les clés du dictionnaire sont les noms des paramètres et la clé <code class="docutils literal notranslate"><span class="pre">&quot;return&quot;</span></code> est utilisée pour les annotations de la valeur renvoyée. Pour plus d'informations sur la manière de traiter cet attribut, voir <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Bonnes pratiques concernant les annotations</span></a>.</p></td>
<td><p>Accessible en écriture</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__kwdefaults__</span></code></p></td>
<td><p>Dictionnaire contenant les valeurs par défaut pour les paramètres passés par mot-clé.</p></td>
<td><p>Accessible en écriture</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__type_params__</span></code></p></td>
<td><p>A tuple containing the
<a class="reference internal" href="compound_stmts.html#type-params"><span class="std std-ref">type parameters</span></a> of a
<a class="reference internal" href="compound_stmts.html#generic-functions"><span class="std std-ref">generic function</span></a>.</p></td>
<td><p>Accessible en écriture</p></td>
</tr>
</tbody>
</table>
<p>La plupart des attributs étiquetés « Accessible en écriture » vérifient le type de la valeur qu'on leur affecte.</p>
<p>Les objets fonctions acceptent également l'affectation et la lecture d'attributs arbitraires. Vous pouvez utiliser cette fonctionnalité pour, par exemple, associer des métadonnées aux fonctions. La notation classique par point est utilisée pour définir et lire de tels attributs. <em>Notez que l'implémentation actuelle accepte seulement les attributs de fonction sur les fonctions définies par l'utilisateur. Les attributs de fonction pour les fonctions natives seront peut-être acceptés dans le futur.</em></p>
<p>Un objet cellule possède un attribut <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code>. Il peut être utilisé pour obtenir la valeur de la cellule et pour en définir la valeur.</p>
<p>Vous trouvez davantage d'informations sur la définition de fonctions dans le code de cet objet ; la description des types internes est donnée plus bas. Le type <a class="reference internal" href="../library/types.html#types.CellType" title="types.CellType"><code class="xref py py-data docutils literal notranslate"><span class="pre">cell</span></code></a> est accessible dans le module <a class="reference internal" href="../library/types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">types</span></code></a>.</p>
</section>
<section id="instance-methods">
<h4><span class="section-number">3.2.8.2. </span>Méthodes d'instances<a class="headerlink" href="#instance-methods" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-36">Un objet méthode d'instance combine une classe, une instance de classe et tout objet appelable (normalement une fonction définie par l'utilisateur).</p>
<p id="index-37">Attributs spéciaux en lecture seule : <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> est l'objet instance de classe, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> est l'objet fonction ; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> est la documentation de la méthode (comme <code class="docutils literal notranslate"><span class="pre">__func__.__doc__</span></code>) ; <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> est le nom de la méthode (comme <code class="docutils literal notranslate"><span class="pre">__func__.__name__</span></code>) ; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> est le nom du module où la méthode est définie ou <code class="docutils literal notranslate"><span class="pre">None</span></code> s'il n'est pas disponible.</p>
<p>Les méthodes savent aussi accéder (mais pas modifier) les attributs de la fonction de l'objet fonction sous-jacent.</p>
<p>Les objets méthodes définies par l'utilisateur peuvent être créés quand vous récupérez un attribut de classe (par exemple <em>via</em> une instance de cette classe) si cet attribut est un objet fonction définie par l'utilisateur ou un objet méthode de classe.</p>
<p>Quand un objet méthode d'instance est créé à partir d'un objet fonction définie par l'utilisateur <em>via</em> une des instances, son attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> est l'instance et l'objet méthode est réputé lié. Le nouvel attribut de la méthode <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> est l'objet fonction original.</p>
<p>Quand un objet méthode d'instance est créé à partir d'un autre objet méthode de la classe ou de l'instance, son attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> est la classe elle-même et son attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> est l'objet fonction sous-jacent la méthode de classe.</p>
<p>Quand un objet méthode d'instance est appelé, la fonction sous-jacente (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code>) est appelée et l'objet instance de la classe (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code>) est inséré en tête de liste des arguments. Par exemple, si <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> est une classe qui contient la définition d'une fonction <code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code> et que <code class="docutils literal notranslate"><span class="pre">x</span></code> est une instance de <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, alors appeler <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> est équivalent à appeler <code class="docutils literal notranslate"><span class="pre">C.f(x,</span> <span class="pre">1)</span></code>.</p>
<p>Quand un objet méthode d'instance est dérivé à partir d'un objet méthode de classe, l'instance de classe stockée dans <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> est en fait la classe elle-même. Ainsi, appeler <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> ou <code class="docutils literal notranslate"><span class="pre">C.f(1)</span></code> est équivalent à appeler <code class="docutils literal notranslate"><span class="pre">f(C,</span> <span class="pre">1)</span></code> où <code class="docutils literal notranslate"><span class="pre">f</span></code> est la fonction sous-jacente.</p>
<p>Notez que la transformation d'objet fonction en objet méthode d'instance se produit à chaque fois que l'attribut est récupéré à partir de l'instance. Dans certains cas, affecter l'attribut à une variable locale et appeler cette variable locale constitue une bonne optimisation. Notez aussi que cette transformation n'a lieu que pour les fonctions définies par l'utilisateur : les autres objets appelables (et les objets non appelables) sont récupérés sans transformation. Il est aussi important de noter que les fonctions définies par l'utilisateur qui sont attributs d'une instance de classe ne sont pas converties en méthodes liées ; ceci n'a lieu que pour les fonctions qui sont attributs de la classe.</p>
</section>
<section id="generator-functions">
<h4><span class="section-number">3.2.8.3. </span>Fonctions génératrices (ou générateurs)<a class="headerlink" href="#generator-functions" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-38">Une fonction ou une méthode qui utilise l'instruction <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> (voir la section <a class="reference internal" href="simple_stmts.html#yield"><span class="std std-ref">L'instruction yield</span></a>) est appelée <em class="dfn">fonction génératrice</em>. Une telle fonction, lorsqu'elle est appelée, renvoie toujours un objet <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">itérateur</span></a> qui peut être utilisé pour exécuter le corps de la fonction : appeler la méthode <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterator.__next__()</span></code></a> de l'itérateur exécute la fonction jusqu'à ce qu'elle renvoie une valeur à l'aide de l'instruction <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code>. Quand la fonction exécute l'instruction <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> ou se termine, une exception <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> est levée et l'itérateur a atteint la fin de l'ensemble de valeurs qu'il peut renvoyer.</p>
</section>
<section id="coroutine-functions">
<h4><span class="section-number">3.2.8.4. </span>Fonctions coroutines<a class="headerlink" href="#coroutine-functions" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-39">Une fonction ou méthode définie en utilisant <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> est appelée <em class="dfn">fonction coroutine</em>. Une telle fonction, quand elle est appelée, renvoie un objet <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a>. Elle peut contenir des expressions <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> ou <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> ou des instructions <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>. Voir également la section <a class="reference internal" href="#coroutine-objects"><span class="std std-ref">Objets coroutines</span></a>.</p>
</section>
<section id="asynchronous-generator-functions">
<h4><span class="section-number">3.2.8.5. </span>Fonctions génératrices (ou générateurs) asynchrones<a class="headerlink" href="#asynchronous-generator-functions" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-40">Une fonction ou une méthode définie avec <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> et qui utilise l'instruction <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> est appelée <em class="dfn">fonction génératrice asynchrone</em>. Une telle fonction, quand elle est appelée, renvoie un objet <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">itérateur asynchrone</span></a> qui peut être utilisé dans des instructions <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> pour exécuter le corps de la fonction.</p>
<p>Appeler la méthode <a class="reference internal" href="#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aiterator.__anext__</span></code></a> de l'itérateur asynchrone renvoie un <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> qui, lorsqu'on l'attend, s'exécute jusqu'à ce qu'il fournisse une valeur à l'aide de l'expression <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>. Quand la fonction exécute une instruction <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> (sans valeur) ou arrive à la fin, une exception <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> est levée et l'itérateur asynchrone a atteint la fin de l'ensemble des valeurs qu'il peut produire.</p>
</section>
<section id="built-in-functions">
<h4><span class="section-number">3.2.8.6. </span>Fonctions natives<a class="headerlink" href="#built-in-functions" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-41">Un objet fonction native est une enveloppe autour d'une fonction C. Nous pouvons citer <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> et <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> (<a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> est un module standard natif) comme fonctions natives. Le nombre et le type des arguments sont déterminés par la fonction C. Des attributs spéciaux en lecture seule existent : <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> contient le texte de documentation de la fonction (ou <code class="docutils literal notranslate"><span class="pre">None</span></code> s'il n'y en a pas) ; <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> est le nom de la fonction ; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> est défini à <code class="docutils literal notranslate"><span class="pre">None</span></code> ; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> est le nom du module où la fonction est définie ou <code class="docutils literal notranslate"><span class="pre">None</span></code> s'il n'est pas disponible.</p>
</section>
<section id="built-in-methods">
<h4><span class="section-number">3.2.8.7. </span>Méthodes natives<a class="headerlink" href="#built-in-methods" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-42">Ce sont des fonctions natives déguisées, contenant un objet passé à une fonction C en tant qu'argument supplémentaire implicite. Un exemple de méthode native est <code class="docutils literal notranslate"><span class="pre">une_liste.append()</span></code> (<code class="docutils literal notranslate"><span class="pre">une_liste</span></code> étant un objet liste). Dans ce cas, l'attribut spécial en lecture seule <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> est défini à l'objet <em>une_liste</em>.</p>
</section>
<section id="classes">
<h4><span class="section-number">3.2.8.8. </span>Classes<a class="headerlink" href="#classes" title="Lien permanent vers ce titre">¶</a></h4>
<p>Les classes sont des appelables. Ces objets sont normalement utilisés pour créer des instances d'elles-mêmes mais des variations sont possibles pour les types de classes qui surchargent <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a>. Les arguments de l'appel sont passés à <code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code> et, dans le cas classique, <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> initialise une nouvelle instance.</p>
</section>
<section id="class-instances">
<h4><span class="section-number">3.2.8.9. </span>Instances de classe<a class="headerlink" href="#class-instances" title="Lien permanent vers ce titre">¶</a></h4>
<p>Les instances d'une classe peuvent devenir des appelables si vous définissez la méthode <a class="reference internal" href="#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> de leur classe.</p>
</section>
</section>
<section id="modules">
<h3><span class="section-number">3.2.9. </span>Modules<a class="headerlink" href="#modules" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-43">Les modules constituent l'organisation de base du code Python et sont créés par le <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">mécanisme d'import</span></a> soit avec l'instruction <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>, soit en appelant des fonctions telles que <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> ou la fonction native <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>. Un objet module possède un espace de nommage implémenté par un objet dictionnaire (c'est le dictionnaire référencé par l'attribut <code class="docutils literal notranslate"><span class="pre">__globals__</span></code> des fonctions définies dans le module). Les références à un attribut sont traduites en recherches dans ce dictionnaire, par exemple <code class="docutils literal notranslate"><span class="pre">m.x</span></code> est équivalent à <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span></code>. Un objet module ne contient pas l'objet code utilisé pour initialiser le module (puisque celui-ci n'est plus nécessaire une fois l'initialisation terminée).</p>
<p>L'affectation d'un attribut met à jour le dictionnaire d'espace de nommage du module, par exemple <code class="docutils literal notranslate"><span class="pre">m.x</span> <span class="pre">=</span> <span class="pre">1</span></code> est équivalent à <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<p id="index-44">Attributs prédéfinis (accessibles en écriture) :</p>
<blockquote>
<div><dl class="simple">
<dt><a class="reference internal" href="import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>Nom du module.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></dt><dd><p>Chaîne de documentation du module (<em>docstring</em> en anglais), ou <code class="docutils literal notranslate"><span class="pre">None</span></code> si le module n'en a pas.</p>
</dd>
<dt><a class="reference internal" href="import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a></dt><dd><p>Chemin vers le fichier à partir duquel le module a été chargé, s'il a été chargé depuis un fichier. L'attribut <a class="reference internal" href="import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> peut être manquant pour certains types de modules, tels que les modules C qui sont statiquement liés à l'interpréteur. Pour les modules d'extension chargés dynamiquement à partir d'une bibliothèque partagée, c'est le chemin vers le fichier de la bibliothèque partagée.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></dt><dd><p>Dictionnaire des <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">annotations de variable</span></a> trouvées lors de l'exécution du code du module. Pour plus de détails sur l'attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code>, voir <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Bonnes pratiques concernant les annotations</span></a>.</p>
</dd>
</dl>
</div></blockquote>
<p id="index-45">Attribut spécial en lecture seule : <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> est l'objet dictionnaire répertoriant l'espace de nommage du module.</p>
<div class="impl-detail compound">
<p><strong>Particularité de l'implémentation CPython :</strong> en raison de la manière dont CPython nettoie les dictionnaires de modules, le dictionnaire du module est effacé quand le module n'est plus visible, même si le dictionnaire possède encore des références actives. Pour éviter ceci, copiez le dictionnaire ou gardez le module dans votre champ de visibilité tant que vous souhaitez utiliser le dictionnaire directement.</p>
</div>
</section>
<section id="custom-classes">
<h3><span class="section-number">3.2.10. </span>Classes déclarées par le développeur<a class="headerlink" href="#custom-classes" title="Lien permanent vers ce titre">¶</a></h3>
<p>Le type d'une classe déclarée par le développeur est créé au moment de la définition de la classe (voir la section <a class="reference internal" href="compound_stmts.html#class"><span class="std std-ref">Définition de classes</span></a>). Une classe possède un espace de nommage implémenté sous la forme d'un objet dictionnaire. Les références vers les attributs de la classe sont traduits en recherches dans ce dictionnaire, par exemple <code class="docutils literal notranslate"><span class="pre">C.x</span></code> est traduit en <code class="docutils literal notranslate"><span class="pre">C.__dict__[&quot;x&quot;]</span></code> (bien qu'il existe un certain nombre de fonctions automatiques qui permettent de trouver des attributs par d'autres moyens). Si le nom d'attribut n'est pas trouvé dans ce dictionnaire, la recherche continue dans les classes de base. Les classes de base sont trouvées en utilisant l'ordre de résolution des méthodes (<em>method resolution order</em> en anglais, ou MRO) <em>C3</em> qui a un comportement cohérent même en présence d'héritages en &quot;diamant&quot;, où différentes branches d'héritages conduisent vers un ancêtre commun. Vous trouverez plus de détails sur l'ordre de résolution des méthodes MRO <em>C3</em> utilisé par Python dans la documentation de la version 2.3 disponible sur <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a>.</p>
<p id="index-46">Quand une référence à un attribut de classe (disons la classe <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>) pointe vers un objet méthode de classe, elle est transformée en objet méthode d'instance dont l'attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> est <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>. Quand elle pointe vers un objet méthode statique, elle est transformée en objet encapsulé par l'objet méthode statique. Reportez-vous à la section <a class="reference internal" href="#descriptors"><span class="std std-ref">Implémentation de descripteurs</span></a> pour une autre manière dont les attributs d'une classe diffèrent de ceux réellement contenus dans son <code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code>.</p>
<p id="index-47">Les affectations d'un attribut de classe mettent à jour le dictionnaire de la classe, jamais le dictionnaire d'une classe de base.</p>
<p id="index-48">Un objet classe peut être appelé (voir ci-dessus) pour produire une instance de classe (voir ci-dessous).</p>
<p id="index-49">Attributs spéciaux :</p>
<blockquote>
<div><dl class="simple">
<dt><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>Nom de la classe.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></dt><dd><p>Nom du module où la classe a été définie.</p>
</dd>
<dt><a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a></dt><dd><p>Dictionnaire qui forme l'espace de nommage de la classe.</p>
</dd>
<dt><a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a></dt><dd><p><em>N</em>-uplet des classes mères, dans le même ordre que dans la définition de la classe.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></dt><dd><p>Chaîne de documentation de la classe (<em>docstring</em> en anglais), ou bien <code class="docutils literal notranslate"><span class="pre">None</span></code> si la classe n'en a pas.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></dt><dd><p>Dictionnaire des <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">annotations de variable</span></a> trouvées lors de l'exécution du code de la classe. Pour plus de détails sur l'attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code>, voir <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Bonnes pratiques concernant les annotations</span></a>.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__type_params__</span></code></dt><dd><p>A tuple containing the <a class="reference internal" href="compound_stmts.html#type-params"><span class="std std-ref">type parameters</span></a> of
a <a class="reference internal" href="compound_stmts.html#generic-classes"><span class="std std-ref">generic class</span></a>.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id2">
<h3><span class="section-number">3.2.11. </span>Instances de classe<a class="headerlink" href="#id2" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-50">Une instance de classe est créée en appelant un objet classe (voir ci-dessus). Une instance de classe possède un espace de nommage implémenté sous la forme d'un dictionnaire qui est le premier endroit où sont recherchées les références aux attributs. Quand un attribut n'est pas trouvé dans ce dictionnaire et que la classe de l'instance contient un attribut avec ce nom, la recherche continue avec les attributs de la classe. Si un attribut de classe est trouvé et que c'est un objet fonction définie par l'utilisateur, il est transformé en objet méthode d'instance dont l'attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> est l'instance. Les objets méthodes statiques et méthodes de classe sont aussi transformés ; reportez-vous ci-dessous à « Classes ». Lisez la section <a class="reference internal" href="#descriptors"><span class="std std-ref">Implémentation de descripteurs</span></a> pour une autre façon de récupérer les attributs d'une classe, où la récupération <em>via</em> ses instances peut différer des objets réellement stockés dans le <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> de la classe. Si aucun attribut de classe n'est trouvé et que la classe de l'objet possède une méthode <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>, cette méthode est appelée pour rechercher une correspondance.</p>
<p id="index-51">Les affectations et suppressions d'attributs mettent à jour le dictionnaire de l'instance, jamais le dictionnaire de la classe. Si la classe possède une méthode <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> ou <a class="reference internal" href="#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a>, elle est appelée au lieu de mettre à jour le dictionnaire de l'instance directement.</p>
<p id="index-52">Les instances de classes peuvent prétendre être des nombres, des séquences ou des tableaux de correspondances si elles ont des méthodes avec des noms spéciaux. Voir la section <a class="reference internal" href="#specialnames"><span class="std std-ref">Méthodes spéciales</span></a>.</p>
<p id="index-53">Attributs spéciaux : <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> est le dictionnaire des attributs ; <a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> est la classe de l'instance.</p>
</section>
<section id="i-o-objects-also-known-as-file-objects">
<h3><span class="section-number">3.2.12. </span>Objets entrées-sorties (ou objets fichiers)<a class="headerlink" href="#i-o-objects-also-known-as-file-objects" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-54">Un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">objet fichier</span></a> représente un fichier ouvert. Différents raccourcis existent pour créer des objets fichiers : la fonction native <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> et aussi <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a>, <a class="reference internal" href="../library/os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fdopen()</span></code></a> ou la méthode <a class="reference internal" href="../library/socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a> des objets connecteurs (et sûrement d'autres fonctions ou méthodes fournies par les modules d'extensions).</p>
<p>Les objets <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> et <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> sont initialisés à des objets fichiers correspondant à l'entrée standard, la sortie standard et le flux d'erreurs de l'interpréteur ; ils sont tous ouverts en mode texte et se conforment donc à l'interface définie par la classe abstraite <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a>.</p>
</section>
<section id="internal-types">
<h3><span class="section-number">3.2.13. </span>Types internes<a class="headerlink" href="#internal-types" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-55">Quelques types utilisés en interne par l'interpréteur sont accessibles à l'utilisateur. Leur définition peut changer dans les futures versions de l'interpréteur mais ils sont donnés ci-dessous à fin d'exhaustivité.</p>
<section id="code-objects">
<span id="id3"></span><h4><span class="section-number">3.2.13.1. </span>Objets Code<a class="headerlink" href="#code-objects" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-56">Un objet code représente le code Python sous sa forme compilée en <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">code intermédiaire</span></a>. La différence entre un objet code et un objet fonction est que l'objet fonction contient une référence explicite vers les globales de la fonction (le module dans lequel elle est définie) alors qu'un objet code ne contient aucun contexte ; par ailleurs, les valeurs par défaut des arguments sont stockées dans l'objet fonction, pas dans l'objet code (parce que ce sont des valeurs calculées au moment de l'exécution). Contrairement aux objets fonctions, les objets codes sont immuables et ne contiennent aucune référence (directe ou indirecte) à des objets muables.</p>
<p id="index-57">Special read-only attributes: <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_name</span></code> gives the function name;
<code class="xref py py-attr docutils literal notranslate"><span class="pre">co_qualname</span></code> gives the fully qualified function name;
<code class="xref py py-attr docutils literal notranslate"><span class="pre">co_argcount</span></code> is the total number of positional arguments
(including positional-only arguments and arguments with default values);
<code class="xref py py-attr docutils literal notranslate"><span class="pre">co_posonlyargcount</span></code> is the number of positional-only arguments
(including arguments with default values); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_kwonlyargcount</span></code> is
the number of keyword-only arguments (including arguments with default
values); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_nlocals</span></code> is the number of local variables used by the
function (including arguments); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_varnames</span></code> is a tuple containing
the names of the local variables (starting with the argument names);
<code class="xref py py-attr docutils literal notranslate"><span class="pre">co_cellvars</span></code> is a tuple containing the names of local variables
that are referenced by nested functions; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_freevars</span></code> is a tuple
containing the names of free variables; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_code</span></code> is a string
representing the sequence of bytecode instructions; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> is
a tuple containing the literals used by the bytecode; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code> is
a tuple containing the names used by the bytecode; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_filename</span></code> is
the filename from which the code was compiled; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_firstlineno</span></code> is
the first line number of the function; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_lnotab</span></code> is a string
encoding the mapping from bytecode offsets to line numbers (for details
see the source code of the interpreter, is deprecated since 3.12
and may be removed in 3.14); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_stacksize</span></code> is the
required stack size; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> is an integer encoding a number
of flags for the interpreter.</p>
<p id="index-58">Les drapeaux suivants sont codés par des bits dans <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> : le bit <code class="docutils literal notranslate"><span class="pre">0x04</span></code> est positionné à 1 si la fonction utilise la syntaxe <code class="docutils literal notranslate"><span class="pre">*arguments</span></code> pour accepter un nombre arbitraire d'arguments positionnels ; le bit <code class="docutils literal notranslate"><span class="pre">0x08</span></code> est positionné à 1 si la fonction utilise la syntaxe <code class="docutils literal notranslate"><span class="pre">**keywords</span></code> pour accepter un nombre arbitraire d'arguments nommés ; le bit <code class="docutils literal notranslate"><span class="pre">0x20</span></code> est positionné à 1 si la fonction est un générateur.</p>
<p>Les déclarations de fonctionnalité future <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code> utilisent aussi des bits dans <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> pour indiquer si l'objet code a été compilé avec une fonctionnalité future : le bit <code class="docutils literal notranslate"><span class="pre">0x2000</span></code> est positionné à 1 si la fonction a été compilée avec la division future activée ; les bits <code class="docutils literal notranslate"><span class="pre">0x10</span></code> et <code class="docutils literal notranslate"><span class="pre">0x1000</span></code> étaient utilisés dans les versions antérieures de Python.</p>
<p>Les autres bits de <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> sont réservés à un usage interne.</p>
<p id="index-59">Si l'objet code représente une fonction, le premier élément dans <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> est le texte de documentation de la fonction (ou <code class="docutils literal notranslate"><span class="pre">None</span></code> s'il n'y en a pas).</p>
<dl class="py method">
<dt class="sig sig-object py" id="codeobject.co_positions">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_positions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codeobject.co_positions" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un itérable qui parcourt les positions du code source pour chaque instruction de code intermédiaire dans l'objet <em>codeobject</em>.</p>
<p>L'itérateur renvoie un <em>n</em>-uplet contenant <code class="docutils literal notranslate"><span class="pre">(ligne_début,</span> <span class="pre">ligne_fin,</span> <span class="pre">colonne_début,</span> <span class="pre">colonne_fin)</span></code>. Le i<sup>ème</sup> <em>n</em>-uplet correspond à la position dans le code source qui compile la i<sup>ème</sup> instruction. L'information de colonne est l'indice (en partant de zéro) de l'octet utf-8 dans la ligne source donnée.</p>
<p>L'information sur la position peut être manquante. Ce peut être le cas si (liste non exhaustive) :</p>
<ul class="simple">
<li><p>l'interpréteur est lancé avec l'option  <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> <code class="docutils literal notranslate"><span class="pre">no_debug_ranges</span></code> ;</p></li>
<li><p>le fichier <em>.pyc</em> est le produit d'une compilation avec l'option  <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> <code class="docutils literal notranslate"><span class="pre">no_debug_ranges</span></code> ;</p></li>
<li><p>le <em>n</em>-uplet de position correspond à des instructions artificielles ;</p></li>
<li><p>les lignes et colonnes ne peuvent pas être représentées en tant que nombre, en raison de limitations dues à l'implémentation ;</p></li>
</ul>
<p>Dans ce cas, certains ou tous les éléments du <em>n</em>-uplet peuvent valoir <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.11.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>cette fonctionnalité nécessite de stocker les positions de colonne dans les objets code, ce qui peut conduire à une légère augmentation de l'utilisation du disque par les fichiers Python compilés ou de l'utilisation de la mémoire. Pour éviter de stocker cette information supplémentaire ou pour désactiver l'affichage supplémentaire dans la pile d'appels, vous pouvez activer l'option de ligne de commande <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> <code class="docutils literal notranslate"><span class="pre">no_debug_ranges</span></code> ou la variable d'environnement <span class="target" id="index-122"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONNODEBUGRANGES"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONNODEBUGRANGES</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="frame-objects">
<span id="id4"></span><h4><span class="section-number">3.2.13.2. </span>Objets cadres<a class="headerlink" href="#frame-objects" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-61">Un objet cadre représente le cadre d'exécution. Il apparait dans des objets traces (voir plus loin) et est passé comme argument aux fonctions de traçage actives.</p>
<p id="index-62">Attributs spéciaux en lecture seule : <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_back</span></code> pointe vers le cadre précédent (l'appelant) ou <code class="docutils literal notranslate"><span class="pre">None</span></code> si c'est le pied de la pile d'appel ; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_code</span></code> est l'objet code en cours d'exécution dans ce cadre ; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_locals</span></code> est le dictionnaire dans lequel sont cherchées les variables locales ; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_globals</span></code> est utilisé pour les variables globales ; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_builtins</span></code> est utilisé pour les noms natifs ; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lasti</span></code> donne l'instruction précise (c'est un indice dans la chaîne de code intermédiaire de l'objet code).</p>
<p>La lecture de <code class="docutils literal notranslate"><span class="pre">f_code</span></code> lève un <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">événement d'audit</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> avec les arguments <code class="docutils literal notranslate"><span class="pre">obj</span></code> et <code class="docutils literal notranslate"><span class="pre">&quot;f_code&quot;</span></code>.</p>
<p id="index-63">Attributs spéciaux en lecture-écriture : <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace</span></code>, s'il n'est pas <code class="docutils literal notranslate"><span class="pre">None</span></code>, est une fonction appelée à différentes occasions durant l'exécution du code (elle est utilisée par le débogueur). Normalement, un événement est déclenché pour chaque ligne de code source — ce comportement peut être désactivé en définissant <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_lines</span></code> à <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>.</p>
<p>Une implémentation <em>peut</em> autoriser le déclenchement des événements <em>opcode</em> par <em>opcode</em> en définissant <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_opcodes</span></code> à <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>. Notez que cela peut conduire à un comportement erratique de l'interpréteur si des exceptions levées par la fonction de traçage sont interceptées par la fonction en train d'être tracée.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lineno</span></code> est le numéro de la ligne courante du cadre — écrire dedans depuis une fonction trace fait sauter à la ligne demandée (seulement pour le cadre le plus bas). Un débogueur peut implémenter une commande « sauter vers » (aussi appelée « Définir la prochaine instruction » ou <em>Set Next Statement</em> en anglais) en écrivant dans <code class="docutils literal notranslate"><span class="pre">f_lineno</span></code>.</p>
<p>Les objets cadres comprennent une méthode :</p>
<dl class="py method">
<dt class="sig sig-object py" id="frame.clear">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frame.clear" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette méthode efface toutes les références aux variables locales conservées dans le cadre. Par ailleurs, si le cadre est celui d'un générateur, le générateur se termine. Ceci permet de casser des références cycliques qui incluent des objets cadres (par exemple, lors de la capture d'une exception et du stockage de la pile d'appels pour une utilisation future).</p>
<p><a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> est levée si le cadre est en cours d'exécution.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.4.</span></p>
</div>
</dd></dl>

</section>
<section id="traceback-objects">
<span id="id5"></span><h4><span class="section-number">3.2.13.3. </span>Objets traces d'appels<a class="headerlink" href="#traceback-objects" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-64">Les objets <em>traces d'appels</em> représentent le contenu de la pile des appels au moment de l'exception. Un objet <em>trace d'appels</em> est implicitement créé quand une exception apparaît et peut être explicitement créé en appelant <a class="reference internal" href="../library/types.html#types.TracebackType" title="types.TracebackType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.TracebackType</span></code></a>.</p>
<p>Pour les traces créées implicitement, quand l'interpréteur recherche un gestionnaire d'exception en remontant la pile d'exécution, un objet trace est inséré devant l'objet trace courant à chaque nouveau niveau. Quand il entre dans le gestionnaire d'exception, la pile d'appels est rendue accessible au programme (voir la section <a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">L'instruction try</span></a>). Elle est accessible par le troisième élément du triplet renvoyé par <code class="docutils literal notranslate"><span class="pre">sys.exc_info()</span></code> et comme attribut <code class="docutils literal notranslate"><span class="pre">__traceback__</span></code> de l'exception qui est traitée.</p>
<p>Quand le programme ne contient aucun gestionnaire adéquat, la pile de traces est écrite (joliment formatée) sur la sortie d'erreur standard ; si l'interpréteur est interactif, elle est rendue disponible pour l'utilisateur en tant que <code class="docutils literal notranslate"><span class="pre">sys.last_traceback</span></code>.</p>
<p>Pour les traces créées explicitement, il revient au créateur de la trace de déterminer comment les attributs <code class="docutils literal notranslate"><span class="pre">tb_next</span></code> doivent être liés pour former la pile complète des traces.</p>
<p id="index-65">Attributs spéciaux en lecture seule : <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_frame</span></code> pointe vers le cadre d'exécution du niveau courant ; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lineno</span></code> donne le numéro de ligne où l'exception a été levée ; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lasti</span></code> indique l'instruction précise. Le numéro de ligne et la dernière instruction dans la trace peuvent différer du numéro de ligne de l'objet cadre si l'exception a eu lieu dans une instruction <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> sans qu'il n'y ait de clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code> adéquate ou sans clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code>.</p>
<p>La lecture de <code class="docutils literal notranslate"><span class="pre">tb_frame</span></code> lève un <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">événement d'audit</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> avec les arguments <code class="docutils literal notranslate"><span class="pre">obj</span></code> et <code class="docutils literal notranslate"><span class="pre">&quot;tb_frame&quot;</span></code>.</p>
<p id="index-66">Attributs spéciaux en lecture-écriture : <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_next</span></code> est le niveau suivant dans la pile d'exécution (en direction du cadre où l'exception a eu lieu) ou <code class="docutils literal notranslate"><span class="pre">None</span></code> s'il n'y a pas de niveau suivant.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>les objets de traces d'appels peuvent maintenant être explicitement instanciés depuis le code Python et l'attribut <code class="docutils literal notranslate"><span class="pre">tb_next</span></code> des instances existantes peut être mis à jour.</p>
</div>
</section>
<section id="slice-objects">
<h4><span class="section-number">3.2.13.4. </span>Objets tranches<a class="headerlink" href="#slice-objects" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-67">Un objet tranche est utilisé pour représenter des découpes des méthodes <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>. Ils sont aussi créés par la fonction native <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a>.</p>
<p id="index-68">Attributs spéciaux en lecture seule : <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code> est la borne inférieure ; <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> est la borne supérieure ; <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> est la valeur du pas ; chaque attribut vaut <code class="docutils literal notranslate"><span class="pre">None</span></code> s'il est omis. Ces attributs peuvent être de n'importe quel type.</p>
<p>Les objets tranches comprennent une méthode :</p>
<dl class="py method">
<dt class="sig sig-object py" id="slice.indices">
<span class="sig-prename descclassname"><span class="pre">slice.</span></span><span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slice.indices" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette méthode prend un argument entier <em>length</em> et calcule les informations de la tranche que l'objet <em>slice</em> décrit s'il est appliqué à une séquence de <em>length</em> éléments. Elle renvoie un triplet d'entiers ; respectivement, ce sont les indices de <em>début</em> et <em>fin</em> ainsi que le <em>pas</em> de découpe. Les indices manquants ou en dehors sont gérés de manière cohérente avec les tranches normales.</p>
</dd></dl>

</section>
<section id="static-method-objects">
<h4><span class="section-number">3.2.13.5. </span>Objets méthodes statiques<a class="headerlink" href="#static-method-objects" title="Lien permanent vers ce titre">¶</a></h4>
<p>Les objets méthodes statiques permettent la transformation des objets fonctions en objets méthodes décrits au-dessus. Un objet méthode statique encapsule tout autre objet, souvent un objet méthode définie par l'utilisateur. Quand un objet méthode statique est récupéré depuis une classe ou une instance de classe, l'objet réellement renvoyé est un objet encapsulé, qui n'a pas vocation à être transformé encore une fois. Les objets méthodes statiques sont aussi appelables. Les objets méthodes statiques sont créés par le constructeur natif <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>.</p>
</section>
<section id="class-method-objects">
<h4><span class="section-number">3.2.13.6. </span>Objets méthodes de classes<a class="headerlink" href="#class-method-objects" title="Lien permanent vers ce titre">¶</a></h4>
<p>Un objet méthode de classe, comme un objet méthode statique, encapsule un autre objet afin de modifier la façon dont cet objet est récupéré depuis les classes et instances de classes. Le comportement des objets méthodes de classes dans le cas d'une telle récupération est décrit plus haut, dans « méthodes définies par l'utilisateur ». Les objets méthodes de classes sont créés par le constructeur natif <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>.</p>
</section>
</section>
</section>
<section id="special-method-names">
<span id="specialnames"></span><h2><span class="section-number">3.3. </span>Méthodes spéciales<a class="headerlink" href="#special-method-names" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-69">Une classe peut implémenter certaines opérations que l'on invoque par une syntaxe spéciale (telles que les opérations arithmétiques ou la découpe en tranches) en définissant des méthodes aux noms particuliers. C'est l'approche utilisée par Python pour la <em class="dfn">surcharge d'opérateur</em>, permettant à une classe de définir son propre comportement vis-à-vis des opérateurs du langage. Par exemple, si une classe définit une méthode <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> et que <code class="docutils literal notranslate"><span class="pre">x</span></code> est une instance de cette classe, alors <code class="docutils literal notranslate"><span class="pre">x[i]</span></code> est globalement équivalent à <code class="docutils literal notranslate"><span class="pre">type(x).__getitem__(x,</span> <span class="pre">i)</span></code>. Sauf lorsque c'est mentionné, toute tentative d'appliquer une opération alors que la méthode appropriée n'est pas définie lève une exception (typiquement <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> ou <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>).</p>
<p>Définir une méthode spéciale à <code class="docutils literal notranslate"><span class="pre">None</span></code> indique que l'opération correspondante n'est pas disponible. Par exemple, si une classe assigne <code class="docutils literal notranslate"><span class="pre">None</span></code> à <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, vous ne pouvez pas itérer sur la classe et appeler <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> sur une instance lève <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> (sans se replier sur <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>) <a class="footnote-reference brackets" href="#id14" id="id6">2</a>.</p>
<p>Lorsque vous implémentez une classe qui émule un type natif, il est important que cette émulation n'implémente que ce qui fait sens pour l'objet qui est modélisé. Par exemple, la recherche d'éléments individuels d'une séquence peut faire sens, mais pas l'extraction d'une tranche (un exemple est l'interface de <code class="xref py py-class docutils literal notranslate"><span class="pre">NodeList</span></code> dans le modèle objet des documents W3C).</p>
<section id="basic-customization">
<span id="customization"></span><h3><span class="section-number">3.3.1. </span>Personnalisation de base<a class="headerlink" href="#basic-customization" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="object.__new__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__new__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__new__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-70">Appelée pour créer une nouvelle instance de la classe <em>cls</em>. La méthode <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> est statique (c'est un cas particulier, vous n'avez pas besoin de la déclarer comme telle) qui prend comme premier argument la classe pour laquelle on veut créer une instance. Les autres arguments sont ceux passés à l'expression de l'objet constructeur (l'appel à la classe). La valeur de retour de <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> doit être l'instance du nouvel objet (classiquement une instance de <em>cls</em>).</p>
<p>Typical implementations create a new instance of the class by invoking the
superclass's <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> method using <code class="docutils literal notranslate"><span class="pre">super().__new__(cls[,</span> <span class="pre">...])</span></code>
with appropriate arguments and then modifying the newly created instance
as necessary before returning it.</p>
<p>Si <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> est appelée pendant la construction de l'objet et renvoie une instance de <em>cls</em>, alors la méthode <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> de la nouvelle instance est invoquée avec <code class="docutils literal notranslate"><span class="pre">__init__(self[,</span> <span class="pre">…])</span></code> où <em>self</em> est la nouvelle instance et les autres arguments sont les mêmes que ceux passés au constructeur de l'objet.</p>
<p>Si <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> ne renvoie pas une instance de <em>cls</em>, alors la méthode <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> de la nouvelle instance n'est pas invoquée.</p>
<p>L'objectif de <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> est principalement, pour les sous-classes de types immuables (comme <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">str</span></code> ou <code class="docutils literal notranslate"><span class="pre">tuple</span></code>), d'autoriser la création sur mesure des instances. Elle est aussi souvent surchargée dans les métaclasses pour particulariser la création des classes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__init__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__init__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-71">Appelée après la création de l'instance (par <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a>), mais avant le retour vers l'appelant. Les arguments sont ceux passés à l'expression du constructeur de classe. Si une classe de base possède une méthode <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>, la méthode <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> de la classe dérivée, si elle existe, doit explicitement appeler cette méthode pour assurer une initialisation correcte de la partie classe de base de l'instance ; par exemple : <code class="docutils literal notranslate"><span class="pre">super().__init__([args…])</span></code>.</p>
<p>Comme <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> et <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> travaillent ensemble pour créer des objets (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> pour le créer, <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> pour le particulariser), <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> ne doit pas renvoyer de valeur <code class="docutils literal notranslate"><span class="pre">None</span></code> ; sinon une exception <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> est levée à l'exécution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__del__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__del__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__del__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-72">Appelée au moment où une instance est sur le point d'être détruite. On l'appelle aussi finaliseur ou (improprement) destructeur. Si une classe de base possède une méthode <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>, la méthode <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> de la classe dérivée, si elle existe, doit explicitement l'appeler pour s'assurer de l'effacement correct de la partie classe de base de l'instance.</p>
<p>Il est possible (mais pas recommandé) que la méthode <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> retarde la destruction de l'instance en créant une nouvelle référence vers cet objet. Python appelle ceci la <em>résurrection</em> d'objet. En fonction de l'implémentation, <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> peut être appelée une deuxième fois au moment où l'objet ressuscité va être détruit ; l'implémentation actuelle de <a class="reference internal" href="../glossary.html#term-CPython"><span class="xref std std-term">CPython</span></a> ne l'appelle qu'une fois.</p>
<p>Il n'est pas garanti que soient appelées les méthodes <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> des objets qui existent toujours quand l'interpréteur termine.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> n'appelle pas directement <code class="docutils literal notranslate"><span class="pre">x.__del__()</span></code> — la première décrémente le compteur de références de <code class="docutils literal notranslate"><span class="pre">x</span></code>. La seconde n'est appelée que quand le compteur de références de <code class="docutils literal notranslate"><span class="pre">x</span></code> atteint zéro.</p>
</div>
<div class="impl-detail compound">
<p class="compound-first"><strong>Particularité de l'implémentation CPython :</strong> It is possible for a reference cycle to prevent the reference count
of an object from going to zero.  In this case, the cycle will be
later detected and deleted by the <a class="reference internal" href="../glossary.html#term-garbage-collection"><span class="xref std std-term">cyclic garbage collector</span></a>.  A common cause of reference cycles is when
an exception has been caught in a local variable.  The frame's
locals then reference the exception, which references its own
traceback, which references the locals of all frames caught in the
traceback.</p>
<div class="compound-last admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p>Documentation du module <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a>.</p>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Avertissement</p>
<p>en raison des conditions particulières qui règnent quand <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> est appelée, les exceptions levées pendant son exécution sont ignorées et, à la place, un avertissement est affiché sur <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>. En particulier :</p>
<ul class="simple">
<li><p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> peut être invoquée quand du code arbitraire est en cours d'exécution, et ce dans n'importe quel fil d'exécution. Si <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> a besoin de poser un verrou ou d'accéder à tout autre ressource bloquante, elle peut provoquer un blocage mutuel (<em>deadlock</em> en anglais) car la ressource peut être déjà utilisée par le code qui est interrompu pour exécuter la méthode <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> peut être exécutée pendant que l'interpréteur se ferme. En conséquence, les variables globales auxquelles elle souhaite accéder (y compris les autres modules) peuvent déjà être détruites ou assignées à <code class="docutils literal notranslate"><span class="pre">None</span></code>. Python garantit que les variables globales dont le nom commence par un tiret bas sont supprimées de leur module avant que les autres variables globales ne le soient ; si aucune autre référence vers ces variables globales n'existe, cela peut aider à s'assurer que les modules importés soient toujours accessibles au moment où la méthode <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> est appelée.</p></li>
</ul>
</div>
<span class="target" id="index-73"></span></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__repr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__repr__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée par la fonction native <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> pour calculer la représentation « officielle » en chaîne de caractères d'un objet. Tout est fait pour que celle-ci ressemble à une expression Python valide pouvant être utilisée pour recréer un objet avec la même valeur (dans un environnement donné). Si ce n'est pas possible, une chaîne de la forme <code class="docutils literal notranslate"><span class="pre">&lt;…une</span> <span class="pre">description</span> <span class="pre">utile…&gt;</span></code> est renvoyée. La valeur renvoyée doit être un objet chaîne de caractères. Si une classe définit <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> mais pas <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, alors <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> est aussi utilisée quand une représentation « informelle » en chaîne de caractères est demandée pour une instance de cette classe.</p>
<p>Cette fonction est principalement utilisée à fins de débogage, il est donc important que la représentation donne beaucoup d'informations et ne soit pas ambigüe.</p>
<span class="target" id="index-74"></span></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__str__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__str__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée par <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(objet)</span></code></a> ainsi que les fonctions natives <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> et <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> pour calculer une chaîne de caractères « informelle » ou joliment mise en forme de représentation de l'objet. La valeur renvoyée doit être un objet <a class="reference internal" href="../library/stdtypes.html#textseq"><span class="std std-ref">string</span></a>.</p>
<p>Cette méthode diffère de <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> car il n'est pas attendu que <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> renvoie une expression Python valide : une représentation plus agréable à lire ou plus concise peut être utilisée.</p>
<p>L'implémentation par défaut du type natif <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> appelle <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> .</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__bytes__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__bytes__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bytes__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-75">Appelée par <a class="reference internal" href="../library/functions.html#func-bytes"><span class="std std-ref">bytes</span></a> pour calculer une représentation en chaîne <em>bytes</em> d'un objet. Elle doit renvoyer un objet <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<span class="target" id="index-76"></span></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__format__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__format__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__format__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée par la fonction native <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> et, par extension, lors de l'évaluation de <a class="reference internal" href="lexical_analysis.html#f-strings"><span class="std std-ref">chaînes de caractères littérales formatées</span></a> et la méthode <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a>. Elle produit une chaîne de caractères « formatée » représentant un objet. L'argument <code class="docutils literal notranslate"><span class="pre">format_spec</span></code> est une chaîne de caractères contenant la description des options de formatage voulues. L'interprétation de l'argument <code class="docutils literal notranslate"><span class="pre">format_spec</span></code> est laissée au type implémentant <a class="reference internal" href="#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a>. Cependant, la plupart des classes délèguent le formatage aux types natifs ou utilisent une syntaxe similaire pour les options de formatage.</p>
<p>Lisez <a class="reference internal" href="../library/string.html#formatspec"><span class="std std-ref">Mini-langage de spécification de format</span></a> pour une description de la syntaxe standard du formatage.</p>
<p>La valeur renvoyée doit être un objet chaîne de caractères.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.4: </span>la méthode <code class="docutils literal notranslate"><span class="pre">__format__</span></code> de <code class="docutils literal notranslate"><span class="pre">object</span></code> lui-même lève une <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> si vous lui passez une chaîne non vide.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span><code class="docutils literal notranslate"><span class="pre">object.__format__(x,</span> <span class="pre">'')</span></code> est maintenant équivalent à <code class="docutils literal notranslate"><span class="pre">str(x)</span></code> plutôt qu'à <code class="docutils literal notranslate"><span class="pre">format(str(x),</span> <span class="pre">'')</span></code>.</p>
</div>
</dd></dl>

<span class="target" id="richcmpfuncs"></span><dl class="py method">
<dt class="sig sig-object py" id="object.__lt__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__lt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lt__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__le__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__le__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__le__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__eq__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__eq__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ne__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ne__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ne__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__gt__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__gt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__gt__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ge__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ge__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ge__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-77">Ce sont les méthodes dites de « comparaisons riches ». La correspondance entre les symboles opérateurs et les noms de méthodes est la suivante : <code class="docutils literal notranslate"><span class="pre">x&lt;y</span></code> appelle <code class="docutils literal notranslate"><span class="pre">x.__lt__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> appelle <code class="docutils literal notranslate"><span class="pre">x.__le__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x==y</span></code> appelle <code class="docutils literal notranslate"><span class="pre">x.__eq__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x!=y</span></code> appelle <code class="docutils literal notranslate"><span class="pre">x.__ne__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x&gt;y</span></code> appelle <code class="docutils literal notranslate"><span class="pre">x.__gt__(y)</span></code> et <code class="docutils literal notranslate"><span class="pre">x&gt;=y</span></code> appelle <code class="docutils literal notranslate"><span class="pre">x.__ge__(y)</span></code>.</p>
<p>Une méthode de comparaison riche peut renvoyer le singleton <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> si elle n'implémente pas l'opération pour une paire donnée d'arguments. Par convention, <code class="docutils literal notranslate"><span class="pre">False</span></code> et <code class="docutils literal notranslate"><span class="pre">True</span></code> sont renvoyées pour une comparaison qui a réussi. Cependant, ces méthodes peuvent renvoyer n'importe quelle valeur donc, si l'opérateur de comparaison est utilisé dans un contexte booléen (par exemple dans une condition d'une instruction <code class="docutils literal notranslate"><span class="pre">if</span></code>), Python appelle <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> sur la valeur pour déterminer si le résultat est faux ou vrai.</p>
<p>Par défaut, <code class="docutils literal notranslate"><span class="pre">object</span></code> implémente <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> en utilisant <code class="docutils literal notranslate"><span class="pre">is</span></code> et renvoie <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> si la comparaison renvoie <code class="docutils literal notranslate"><span class="pre">False</span></code> : <code class="docutils literal notranslate"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span> <span class="pre">else</span> <span class="pre">NotImplemented</span></code>. Pour <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a>, il délègue à <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> et renvoie le résultat inverse, sauf si c'est <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>. Il n'y a pas d'autres relations implicites pour les opérateurs de comparaison ou d'implémentations par défaut ; par exemple, <code class="docutils literal notranslate"><span class="pre">(x&lt;y</span> <span class="pre">or</span> <span class="pre">x==y)</span></code> n'implique pas <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code>. Pour obtenir une relation d'ordre total automatique à partir d'une seule opération, reportez-vous à <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.total_ordering()</span></code></a>.</p>
<p>Lisez le paragraphe <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> pour connaître certaines notions importantes relatives à la création d'objets <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hachables</span></a> qui acceptent les opérations de comparaison personnalisées et qui sont utilisables en tant que clés de dictionnaires.</p>
<p>Il n'y a pas de versions avec les arguments interchangés de ces méthodes (qui seraient utilisées quand l'argument de gauche ne connaît pas l'opération alors que l'argument de droite la connaît) ; en lieu et place, <a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> et <a class="reference internal" href="#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> sont la réflexion l'une de l'autre, <a class="reference internal" href="#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a> et <a class="reference internal" href="#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> sont la réflexion l'une de l'autre et <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> ainsi que <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> sont réflexives. Si les opérandes sont de types différents et que l'opérande de droite est d'un type qui une sous-classe directe ou indirecte du type de l'opérande de gauche, alors la méthode symétrique de l'opérande de droite est prioritaire, sinon c'est la méthode de l'opérande de gauche qui est prioritaire. Les sous-classes virtuelles ne sont pas prises en compte.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__hash__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__hash__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-78">Appelée par la fonction native <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> et par les opérations sur les membres de collections hachées (ce qui comprend <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> et <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>). La méthode <code class="docutils literal notranslate"><span class="pre">__hash__()</span></code> doit renvoyer un entier. La seule propriété requise est que les objets qui sont égaux pour la comparaison doivent avoir la même valeur de hachage ; il est conseillé de mélanger les valeurs de hachage des composants d'un objet qui jouent un rôle dans la comparaison des objets, en les emballant dans un <em>n</em>-uplet dont on calcule l'empreinte. Par exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nick</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> limite la valeur renvoyée d'un objet ayant une méthode <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> personnalisée à la taille d'un <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>. C'est classiquement 8 octets pour une implémentation 64 bits et 4 octets sur une implémentation 32 bits. Si la méthode <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> d'un objet doit être interopérable sur des plateformes ayant des implémentations différentes, assurez-vous de vérifier la taille du hachage sur toutes les plateformes. Une manière facile de le faire est la suivante : <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-c</span> <span class="pre">&quot;import</span> <span class="pre">sys;</span> <span class="pre">print(sys.hash_info.width)&quot;</span></code>.</p>
</div>
<p>If a class does not define an <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> method it should not define a
<a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> operation either; if it defines <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> but not
<a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, its instances will not be usable as items in hashable
collections.  If a class defines mutable objects and implements an
<a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> method, it should not implement <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, since the
implementation of <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> collections requires that a key's hash value is
immutable (if the object's hash value changes, it will be in the wrong hash
bucket).</p>
<p>Les classes définies par l'utilisateur possèdent des méthodes <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> et <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> par défaut ; ces méthodes répondent que tous les objets sont différents (sauf avec eux-mêmes) et <code class="docutils literal notranslate"><span class="pre">x.__hash__()</span></code> renvoie une valeur telle que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> implique à la fois <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> et <code class="docutils literal notranslate"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code>.</p>
<p>Une classe qui surcharge <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> et qui ne définit pas <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> a sa méthode <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> implicitement assignée à <code class="docutils literal notranslate"><span class="pre">None</span></code>. Quand la méthode <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> d'une classe est <code class="docutils literal notranslate"><span class="pre">None</span></code>, une instance de cette classe lève <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> quand un programme essaie de demander son empreinte et elle est correctement identifiée comme <em>non hachable</em> quand on vérifie <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code>.</p>
<p>Si une classe qui surcharge <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> a besoin de conserver l'implémentation de <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> de la classe parente, vous devez l'indiquer explicitement à l'interpréteur en définissant <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">&lt;ClasseParente&gt;.__hash__</span></code>.</p>
<p>Si une classe ne surcharge pas <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> et veut supprimer le calcul des empreintes, elle doit inclure <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> dans la définition de la classe. Une classe qui définit sa propre méthode <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> qui lève explicitement <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> serait incorrectement identifiée comme hachable par un appel à <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>par défaut, les valeurs renvoyées par <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> pour les chaînes et les <em>bytes</em> sont « salées » avec une valeur aléatoire non prévisible. Bien qu'une empreinte reste constante tout au long d'un processus Python, sa valeur n'est pas prévisible entre deux invocations de Python.</p>
<p>This is intended to provide protection against a denial-of-service caused
by carefully chosen inputs that exploit the worst case performance of a
dict insertion, O(n<sup>2</sup>) complexity.  See
<a class="reference external" href="http://ocert.org/advisories/ocert-2011-003.html">http://ocert.org/advisories/ocert-2011-003.html</a> for details.</p>
<p>Modifier les empreintes obtenues par hachage modifie l'ordre d'itération sur les <em>sets</em>. Python n'a jamais donné de garantie sur cet ordre (d'ailleurs, l'ordre n'est pas le même entre les implémentations 32 et 64 bits).</p>
<p>Voir aussi <span class="target" id="index-123"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.3: </span>la randomisation des empreintes est activée par défaut.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__bool__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__bool__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bool__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-80">Called to implement truth value testing and the built-in operation
<code class="docutils literal notranslate"><span class="pre">bool()</span></code>; should return <code class="docutils literal notranslate"><span class="pre">False</span></code> or <code class="docutils literal notranslate"><span class="pre">True</span></code>.  When this method is not
defined, <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> is called, if it is defined, and the object is
considered true if its result is nonzero.  If a class defines neither
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> nor <code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code>, all its instances are considered
true.</p>
</dd></dl>

</section>
<section id="customizing-attribute-access">
<span id="attribute-access"></span><h3><span class="section-number">3.3.2. </span>Personnalisation de l'accès aux attributs<a class="headerlink" href="#customizing-attribute-access" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les méthodes suivantes peuvent être définies pour personnaliser l'accès aux attributs (utilisation, assignation, suppression de <code class="docutils literal notranslate"><span class="pre">x.name</span></code>) pour les instances de classes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__getattr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattr__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée lorsque l'accès par défaut à l'attribut échoue en levant <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> (soit <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> lève <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> car <em>name</em> n'est pas un attribut de l'instance ou un attribut dans l'arborescence de la classe de <code class="docutils literal notranslate"><span class="pre">self</span></code> ; ou <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> de la propriété <em>name</em> lève <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>). Cette méthode doit renvoyer soit la valeur (calculée) de l'attribut, soit lever une exception <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>.</p>
<p>Notez que si l'attribut est trouvé par le mécanisme normal, <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> n'est pas appelée (c'est une asymétrie voulue entre <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> et <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a>). Ce comportement est adopté à la fois pour des raisons de performance et parce que, sinon, <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> n'aurait aucun moyen d'accéder aux autres attributs de l'instance. Notez que, au moins pour ce qui concerne les variables d'instance, vous pouvez simuler un contrôle total en n'insérant aucune valeur dans le dictionnaire des attributs de l'instance (mais en les insérant dans un autre objet à la place). Lisez la partie relative à la méthode <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> ci-dessous pour obtenir un contrôle total effectif sur l'accès aux attributs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__getattribute__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getattribute__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattribute__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée de manière inconditionnelle pour implémenter l'accès aux attributs des instances de la classe. Si la classe définit également <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>, cette dernière n'est pas appelée à moins que <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> ne l'appelle explicitement ou ne lève une exception <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Cette méthode doit renvoyer la valeur (calculée) de l'attribut ou lever une exception <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Afin d'éviter une récursion infinie sur cette méthode, son implémentation doit toujours appeler la méthode de la classe de base avec le même paramètre <em>name</em> pour accéder à n'importe quel attribut dont elle a besoin. Par exemple, <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(self,</span> <span class="pre">name)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>cette méthode peut être shuntée lorsque la recherche porte sur les méthodes spéciales en tant que résultat d'une invocation implicite <em>via</em> la syntaxe du langage ou les fonctions natives. Lisez <a class="reference internal" href="#special-lookup"><span class="std std-ref">Recherche des méthodes spéciales</span></a>.</p>
</div>
<p class="audit-hook">Lève un <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">événement d'audit</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> avec les arguments <code class="docutils literal notranslate"><span class="pre">obj</span></code> et <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__setattr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setattr__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée lors d'une assignation d'attribut. Elle est appelée à la place du mécanisme normal (c'est-à-dire stocker la valeur dans le dictionnaire de l'instance). <em>name</em> est le nom de l'attribut, <em>value</em> est la valeur à assigner à cet attribut.</p>
<p>Si <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> veut assigner un attribut d'instance, elle doit appeler la méthode de la classe de base avec le même nom, par exemple <code class="docutils literal notranslate"><span class="pre">object.__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></code>.</p>
<p class="audit-hook">Lève un <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">événement d'audit</span></a> <code class="docutils literal notranslate"><span class="pre">object.__setattr__</span></code> avec les arguments <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code> et <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__delattr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delattr__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Comme <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> mais pour supprimer un attribut au lieu de l'assigner. Elle ne doit être implémentée que si <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">obj.name</span></code> a du sens pour cet objet.</p>
<p class="audit-hook">Lève un <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">événement d'audit</span></a> <code class="docutils literal notranslate"><span class="pre">object.__deltattr__</span></code> avec les arguments <code class="docutils literal notranslate"><span class="pre">obj</span></code> et <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__dir__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__dir__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__dir__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée quand <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> est appelée sur l'objet. Elle doit renvoyer une séquence. <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> convertit la séquence renvoyée en liste et effectue le classement.</p>
</dd></dl>

<section id="customizing-module-attribute-access">
<h4><span class="section-number">3.3.2.1. </span>Personnalisation de l'accès aux attributs d'un module<a class="headerlink" href="#customizing-module-attribute-access" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-81">Les noms spéciaux <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> et <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> peuvent aussi être personnalisés pour accéder aux attributs du module. La fonction <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> au niveau du module doit accepter un argument qui est un nom d'attribut et doit renvoyer la valeur calculée ou lever une <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Si un attribut n'est pas trouvé dans l'objet module en utilisant la recherche normale, c'est-à-dire <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getattribute__()</span></code></a>, alors Python recherche <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> dans le <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> du module avant de lever une <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. S'il la trouve, il l'appelle avec le nom de l'attribut et renvoie le résultat.</p>
<p>La fonction <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> ne prend aucun argument et renvoie une séquence de chaînes qui représente les noms accessibles du module. Si elle existe, cette fonction surcharge la fonction de recherche standard <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> du module.</p>
<p>Pour une personnalisation plus fine du comportement d'un module (assignation des attributs, propriétés, etc.), vous pouvez assigner l'attribut <code class="docutils literal notranslate"><span class="pre">__class__</span></code> d'un objet module à une sous-classe de <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a>. Par exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">ModuleType</span>

<span class="k">class</span> <span class="nc">VerboseModule</span><span class="p">(</span><span class="n">ModuleType</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Verbose </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">VerboseModule</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>définir <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> du module et <code class="docutils literal notranslate"><span class="pre">__class__</span></code> pour le module impacte uniquement les recherches qui utilisent la syntaxe d'accès aux attributs — accéder directement aux globales d'un module (soit par le code dans le module, soit <em>via</em> une référence au dictionnaire des variables globales du module) fonctionne toujours de la même façon.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>l'attribut <code class="docutils literal notranslate"><span class="pre">__class__</span></code> du module est maintenant en lecture-écriture.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7: </span>attributs <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> et <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> du module.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<dl class="simple">
<dt><span class="target" id="index-124"></span><a class="pep reference external" href="https://peps.python.org/pep-0562/"><strong>PEP 562</strong></a> — <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> et <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> pour un module</dt><dd><p>Décrit les fonctions <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> et <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> des modules.</p>
</dd>
</dl>
</div>
</section>
<section id="implementing-descriptors">
<span id="descriptors"></span><h4><span class="section-number">3.3.2.2. </span>Implémentation de descripteurs<a class="headerlink" href="#implementing-descriptors" title="Lien permanent vers ce titre">¶</a></h4>
<p>Les méthodes qui suivent s'appliquent seulement quand une instance de la classe (dite classe <em>descripteur</em>) contenant la méthode apparaît dans une classe <em>propriétaire</em> (<em>owner</em> en anglais) ; la classe descripteur doit figurer dans le dictionnaire de la classe propriétaire ou dans le dictionnaire de la classe d'un des parents. Dans les exemples ci-dessous, « l'attribut » fait référence à l'attribut dont le nom est une clé du <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> de la classe propriétaire.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__get__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__get__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__get__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée pour obtenir l'attribut de la classe propriétaire (accès à un attribut de classe) ou d'une instance de cette classe (accès à un attribut d'instance). L'argument optionnel <em>owner</em> est la classe propriétaire alors que <em>instance</em> est l'instance par laquelle on accède à l'attribut ou <code class="docutils literal notranslate"><span class="pre">None</span></code> lorsque l'on accède par la classe <em>owner</em>.</p>
<p>Il convient que cette méthode renvoie la valeur calculée de l'attribut ou lève une exception <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>.</p>
<p>La <span class="target" id="index-125"></span><a class="pep reference external" href="https://peps.python.org/pep-0252/"><strong>PEP 252</strong></a> spécifie que <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> soit un appelable avec un ou deux arguments. Les descripteurs natifs de Python suivent cette spécification ; cependant, il est probable que des outils tiers aient des descripteurs qui requièrent les deux arguments. L'implémentation de <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> de Python passe toujours les deux arguments, qu'ils soient requis ou non.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__set__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__set__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée pour définir l'attribut d'une instance <em>instance</em> de la classe propriétaire à la nouvelle valeur <em>value</em>.</p>
<p>Notez que ajouter <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> ou <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> modifie la nature du descripteur vers un « descripteur de donnée ». Reportez-vous à <a class="reference internal" href="#descriptor-invocation"><span class="std std-ref">Invocation des descripteurs</span></a> pour plus de détails.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__delete__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__delete__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delete__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée pour supprimer l'attribut de l'instance <em>instance</em> de la classe propriétaire.</p>
</dd></dl>

<p>L'attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> est interprété par le module <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> comme spécifiant la classe où cet objet a été défini (le définir correctement peut vous aider dans l'introspection des classes dynamiques à l'exécution). Pour les appelables, cela peut indiquer qu'une instance d'un certain type (ou d'une certaine sous-classe) est attendue ou requise comme premier argument positionnel (par exemple, CPython définit cet attribut pour les méthodes non liées qui sont implémentées en C).</p>
</section>
<section id="invoking-descriptors">
<span id="descriptor-invocation"></span><h4><span class="section-number">3.3.2.3. </span>Invocation des descripteurs<a class="headerlink" href="#invoking-descriptors" title="Lien permanent vers ce titre">¶</a></h4>
<p>En général, un descripteur est un attribut d'objet dont le comportement est « lié » (<em>binding dehavior</em> en anglais), c'est-à-dire que les accès aux attributs ont été surchargés par des méthodes conformes au protocole des descripteurs : <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> et <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>. Si l'une de ces méthodes est définie pour un objet, il est réputé être un descripteur.</p>
<p>Le comportement par défaut pour la gestion d'un attribut est de définir, obtenir et supprimer cet attribut du dictionnaire de l'objet. Par exemple, pour <code class="docutils literal notranslate"><span class="pre">a.x</span></code> Python commence d'abord par rechercher <code class="docutils literal notranslate"><span class="pre">a.__dict__['x']</span></code>, puis <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x']</span></code> ; ensuite Python continue en remontant les classes de base de <code class="docutils literal notranslate"><span class="pre">type(a)</span></code>, en excluant les métaclasses.</p>
<p>Cependant, si la valeur cherchée est un objet qui définit une des méthodes de descripteur, alors Python modifie son comportement et invoque la méthode du descripteur à la place. Le moment où cela intervient dans la recherche citée ci-dessus dépend de l'endroit où a été définie la méthode de descripteur et comment elle a été appelée.</p>
<p>Le point de départ pour une invocation de descripteur est la liaison <code class="docutils literal notranslate"><span class="pre">a.x</span></code>. La façon dont les arguments sont assemblés dépend de <code class="docutils literal notranslate"><span class="pre">a</span></code> :</p>
<dl class="simple">
<dt>Appel direct</dt><dd><p>Le plus simple et le plus rare des appels est quand l'utilisateur code directement l'appel à la méthode du descripteur : <code class="docutils literal notranslate"><span class="pre">x.__get__(a)</span></code>.</p>
</dd>
<dt>Liaison avec une instance</dt><dd><p>Si elle est liée à un objet instance, <code class="docutils literal notranslate"><span class="pre">a.x</span></code> est transformé en l'appel suivant : <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x'].__get__(a,</span> <span class="pre">type(a))</span></code>.</p>
</dd>
<dt>Liaison avec une classe</dt><dd><p>Si elle est liée à une classe, <code class="docutils literal notranslate"><span class="pre">A.x</span></code> est transformé en l'appel suivant : <code class="docutils literal notranslate"><span class="pre">A.__dict__['x'].__get__(None,</span> <span class="pre">A)</span></code>.</p>
</dd>
<dt>Liaison super</dt><dd><p>Une recherche avec un point telle que <code class="docutils literal notranslate"><span class="pre">super(A,</span> <span class="pre">a).x</span></code> cherche <code class="docutils literal notranslate"><span class="pre">a.__class__.__mro__</span></code> pour une classe de base <code class="docutils literal notranslate"><span class="pre">B</span></code> qui suit (dans l'ordre MRO) <code class="docutils literal notranslate"><span class="pre">A</span></code>, puis renvoie <code class="docutils literal notranslate"><span class="pre">B.__dict__['x'].__get__(a,</span> <span class="pre">A)</span></code>.  Si ce n'est pas un descripteur, <code class="docutils literal notranslate"><span class="pre">x</span></code> est renvoyé inchangé.</p>
</dd>
</dl>
<p>Pour des liaisons avec des instances, la priorité à l'invocation du descripteur dépend des méthodes que le descripteur a définies. Un descripteur peut définir n'importe quelle combinaison de <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> et <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>. S'il ne définit pas <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code>, alors accéder à l'attribut renvoie l'objet descripteur lui-même sauf s'il existe une valeur dans le dictionnaire de l'objet instance. Si le descripteur définit <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> ou <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>, c'est un descripteur de données ; s'il ne définit aucune méthode, c'est un descripteur hors-données. Normalement, les descripteurs de données définissent à la fois <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> et <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code>, alors que les descripteurs hors-données définissent seulement la méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code>. Les descripteurs de données qui définissent <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> et <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> (ou <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>) sont toujours prioritaires face à une redéfinition du dictionnaire de l'instance. En revanche, les descripteurs hors-données peuvent être shuntés par les instances.</p>
<p>Les méthodes Python (y compris celles décorées par <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code></a> et <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a>) sont implémentées comme des descripteurs hors-données. De la même manière, les instances peuvent redéfinir et surcharger les méthodes. Ceci permet à chaque instance d'avoir un comportement qui diffère des autres instances de la même classe.</p>
<p>La fonction <a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> est implémentée en tant que descripteur de données. Ainsi, les instances ne peuvent pas surcharger le comportement d'une propriété.</p>
</section>
<section id="slots">
<span id="id7"></span><h4><span class="section-number">3.3.2.4. </span>créneaux prédéfinis (<code class="docutils literal notranslate"><span class="pre">__slots__</span></code>)<a class="headerlink" href="#slots" title="Lien permanent vers ce titre">¶</a></h4>
<p>Les créneaux prédéfinis (<code class="docutils literal notranslate"><span class="pre">__slots__</span></code>) vous permettent de déclarer des membres d'une donnée (comme une propriété) et d'interdire la création de <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> ou de <em>__weakref__</em> (à moins qu'ils ne soient explicitement déclarés dans le <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> ou présent dans le parent).</p>
<p>L'espace gagné par rapport à l'utilisation d'un <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> peut être significatif. La recherche d'attribut peut aussi s'avérer beaucoup plus rapide.</p>
<dl class="py data">
<dt class="sig sig-object py" id="object.__slots__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__slots__</span></span><a class="headerlink" href="#object.__slots__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette variable de classe peut être assignée avec une chaîne, un itérable ou une séquence de chaînes avec les noms de variables utilisés par les instances. <em>__slots__</em> réserve de la place pour ces variables déclarées et interdit la création automatique de <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> et <em>__weakref__</em> pour chaque instance.</p>
</dd></dl>

<p id="datamodel-note-slots">Notes on using <em>__slots__</em>:</p>
<ul class="simple">
<li><p>Lorsque vous héritez d'une classe sans <em>__slots__</em>, les attributs <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> et <em>__weakref__</em> des instances sont toujours accessibles.</p></li>
<li><p>Sans variable <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>, les instances ne peuvent pas assigner de nouvelles variables (non listées dans la définition de <em>__slots__</em>). Les tentatives d'assignation sur un nom de variable non listé lève <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Si l'assignation dynamique de nouvelles variables est nécessaire, ajoutez <code class="docutils literal notranslate"><span class="pre">'__dict__'</span></code> à la séquence de chaînes dans la déclaration <em>__slots__</em>.</p></li>
<li><p>Sans variable <em>__weakref__</em> pour chaque instance, les classes qui définissent <em>__slots__</em> ne gèrent pas les <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">références</span> <span class="pre">faibles</span></code></a> vers leurs instances. Si vous avez besoin de gérer des références faibles, ajoutez <code class="docutils literal notranslate"><span class="pre">'__weakref__'</span></code> à la séquence de chaînes dans la déclaration de <em>__slots__</em>.</p></li>
<li><p>Les <em>__slots__</em> sont implémentés au niveau de la classe en créant des <a class="reference internal" href="#descriptors"><span class="std std-ref">descripteurs</span></a> pour chaque nom de variable. Ainsi, les attributs de classe ne peuvent pas être utilisés pour des valeurs par défaut aux variables d'instances définies par <em>__slots__</em> ; sinon, l'attribut de classe surchargerait l'assignation par descripteur.</p></li>
<li><p>L'action de la déclaration du <em>__slots__</em> ne se limite pas à la classe où il est défini. Les <em>__slots__</em> déclarés par les parents sont disponibles dans les classes enfants. Cependant, les sous-classes enfants ont un <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> et un <em>__weakref__</em> à moins qu'elles ne définissent aussi un <em>__slots__</em> (qui ne doit contenir alors que les noms <em>supplémentaires</em> aux créneaux déjà prédéfinis).</p></li>
<li><p>Si une classe définit un <em>slot</em> déjà défini dans une classe de base, la variable d'instance définie par la classe de base est inaccessible (sauf à utiliser le descripteur de la classe de base directement). Cela rend la signification du programme indéfinie. Dans le futur, une vérification sera ajoutée pour empêcher cela.</p></li>
<li><p><a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> will be raised if nonempty <em>__slots__</em> are defined for a
class derived from a
<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">&quot;variable-length&quot;</span> <span class="pre">built-in</span> <span class="pre">type</span></code></a> such as
<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, and <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>.</p></li>
<li><p>Tout <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">itérable</span></a>, sauf les chaînes de caractères, peuvent être affectés à <em>__slots__</em>.</p></li>
<li><p>Si vous affectez <em>__slots__</em> à un <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionnaire</span></code></a>, les clés du dictionnaires seront les noms du <em>slot</em>. Les valeurs du dictionnaire peuvent être utilisées en tant que chaines de description (<em>docstrings</em>) et sont reconnues par <a class="reference internal" href="../library/inspect.html#inspect.getdoc" title="inspect.getdoc"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getdoc()</span></code></a> qui les affiche dans la sortie de <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a>.</p></li>
<li><p>Les assignations de <a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> ne fonctionnent que si les deux classes ont le même <em>__slots__</em>.</p></li>
<li><p>L'<a class="reference internal" href="../tutorial/classes.html#tut-multiple"><span class="std std-ref">héritage multiple</span></a> avec plusieurs classes parentes qui ont des <em>__slots__</em> est possible, mais seul un parent peut avoir des attributs créés par <em>__slots__</em> (les autres classes parentes doivent avoir des <em>__slots__</em> vides). La violation de cette règle lève <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p></li>
<li><p>Si un <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">itérateur</span></a> est utilisé pour <em>__slots__</em>, alors un <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descripteur</span></a> est créé pour chacune des valeurs de l'itérateur. Cependant, l'attribut <em>__slots__</em> est un itérateur vide.</p></li>
</ul>
</section>
</section>
<section id="customizing-class-creation">
<span id="class-customization"></span><h3><span class="section-number">3.3.3. </span>Personnalisation de la création de classes<a class="headerlink" href="#customizing-class-creation" title="Lien permanent vers ce titre">¶</a></h3>
<p>Quand une classe hérite d'une classe parente, la méthode <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> de la classe parente est appelée. Ainsi, il est possible d'écrire des classes qui modifient le comportement des sous-classes. Ce comportement est corrélé aux décorateurs de classes mais, alors que les décorateurs de classes agissent seulement sur la classe qu'ils décorent, <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> agit uniquement sur les futures sous-classes de la classe qui définit cette méthode.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__init_subclass__">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__init_subclass__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__init_subclass__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette méthode est appelée quand la classe est sous-classée. <em>cls</em> est alors la nouvelle sous-classe. Si elle est définie en tant que méthode d'instance normale, cette méthode est implicitement convertie en méthode de classe.</p>
<p>Les arguments nommés qui sont donnés à la nouvelle classe sont passés à <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> de la classe parente. Par souci de compatibilité avec les autres classes qui utilisent <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>, vous devez enlever les arguments nommés dont vous avez besoin et passer les autres à la classe de base, comme ci-dessous :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Philosopher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">default_name</span> <span class="o">=</span> <span class="n">default_name</span>

<span class="k">class</span> <span class="nc">AustralianPhilosopher</span><span class="p">(</span><span class="n">Philosopher</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="s2">&quot;Bruce&quot;</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>L'implémentation par défaut de <code class="docutils literal notranslate"><span class="pre">object.__init_subclass__</span></code> ne fait rien sans argument, mais lève une erreur si elle est appelée avec un argument ou plus.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>l'indication de métaclasse <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> est absorbée par le reste du mécanisme de types et n'est jamais passée à l'implémentation de <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>. La métaclasse réelle (plutôt que l'indication explicite) peut être récupérée par <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.6.</span></p>
</div>
</dd></dl>

<p>Lorsqu'une classe est créée, <code class="xref py py-meth docutils literal notranslate"><span class="pre">type.__new__()</span></code> exécute le point d'entrée <code class="xref py py-meth docutils literal notranslate"><span class="pre">___set_name__()</span></code> de toute variable de la classe qui en possède un.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__set_name__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__set_name__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set_name__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée automatiquement au moment où la classe propriétaire <em>owner</em> est créée. L'objet <em>self</em> a été assigné à <em>name</em> dans <em>owner</em> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>  <span class="c1"># Automatically calls: x.__set_name__(A, &#39;x&#39;)</span>
</pre></div>
</div>
<p>Si l'affectation se produit après la création de la classe, le point d'entrée <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> n'est pas appelé automatiquement. Mais il est autorisé d'appeler <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> manuellement :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
   <span class="k">pass</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">A</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">c</span>                  <span class="c1"># The hook is not called</span>
<span class="n">c</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>   <span class="c1"># Manually invoke the hook</span>
</pre></div>
</div>
<p>Consultez <a class="reference internal" href="#class-object-creation"><span class="std std-ref">Création de l'objet classe</span></a> pour davantage de détails.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.6.</span></p>
</div>
</dd></dl>

<section id="metaclasses">
<span id="id8"></span><h4><span class="section-number">3.3.3.1. </span>Métaclasses<a class="headerlink" href="#metaclasses" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-84">Par défaut, les classes sont construites en utilisant <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>. Le corps de la classe est exécuté dans un nouvel espace de nommage et le nom de la classe est lié localement au résultat de <code class="docutils literal notranslate"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">namespace)</span></code>.</p>
<p>Le déroulement de création de la classe peut être personnalisé en passant l'argument nommé <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> dans la ligne de définition de la classe ou en héritant d'une classe existante qui comporte déjà un tel argument. Dans l'exemple qui suit, <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> et <code class="docutils literal notranslate"><span class="pre">MySubclass</span></code> sont des instances de <code class="docutils literal notranslate"><span class="pre">Meta</span></code> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MySubclass</span><span class="p">(</span><span class="n">MyClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Tout autre argument nommé spécifié dans la définition de la classe est passé aux opérations de métaclasses décrites auparavant.</p>
<p>Quand la définition d'une classe est exécutée, les différentes étapes suivies sont :</p>
<ul class="simple">
<li><p>les entrées MRO sont résolues ;</p></li>
<li><p>la métaclasse appropriée est déterminée ;</p></li>
<li><p>l'espace de nommage de la classe est préparé ;</p></li>
<li><p>le corps de la classe est exécuté ;</p></li>
<li><p>l'objet classe est créé.</p></li>
</ul>
</section>
<section id="resolving-mro-entries">
<h4><span class="section-number">3.3.3.2. </span>Résolution des entrées MRO<a class="headerlink" href="#resolving-mro-entries" title="Lien permanent vers ce titre">¶</a></h4>
<dl class="py method">
<dt class="sig sig-object py" id="object.__mro_entries__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__mro_entries__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mro_entries__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>If a base that appears in a class definition is not an instance of
<a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>, then an <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code> method is searched on the base.
If an <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code> method is found, the base is substituted with the
result of a call to <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code> when creating the class.
The method is called with the original bases tuple
passed to the <em>bases</em> parameter, and must return a tuple
of classes that will be used instead of the base. The returned tuple may be
empty: in these cases, the original base is ignored.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<dl class="simple">
<dt><a class="reference internal" href="../library/types.html#types.resolve_bases" title="types.resolve_bases"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.resolve_bases()</span></code></a></dt><dd><p>Dynamically resolve bases that are not instances of <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
</dd>
<dt><a class="reference internal" href="../library/types.html#types.get_original_bases" title="types.get_original_bases"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.get_original_bases()</span></code></a></dt><dd><p>Retrieve a class's &quot;original bases&quot; prior to modifications by
<a class="reference internal" href="#object.__mro_entries__" title="object.__mro_entries__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code></a>.</p>
</dd>
<dt><span class="target" id="index-85"></span><a class="pep reference external" href="https://peps.python.org/pep-0560/"><strong>PEP 560</strong></a></dt><dd><p>Core support for typing module and generic types.</p>
</dd>
</dl>
</div>
</section>
<section id="determining-the-appropriate-metaclass">
<h4><span class="section-number">3.3.3.3. </span>Détermination de la métaclasse appropriée<a class="headerlink" href="#determining-the-appropriate-metaclass" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-86">La métaclasse appropriée pour une définition de classe est déterminée de la manière suivante :</p>
<ul class="simple">
<li><p>si aucune classe et aucune métaclasse n'est donnée, alors <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> est utilisée ;</p></li>
<li><p>si une métaclasse explicite est donnée et que <em>ce n'est pas</em> une instance de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>, alors elle est utilisée directement en tant que métaclasse ;</p></li>
<li><p>si une instance de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> est donnée comme métaclasse explicite ou si <em>bases</em> est définie, alors la métaclasse la plus dérivée est utilisée.</p></li>
</ul>
<p>La métaclasse la plus dérivée est choisie à partir des métaclasses explicitement spécifiées (s'il y en a) et les métaclasses (c'est-à-dire les <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>) de toutes les classes de base spécifiées. La métaclasse la plus dérivée est celle qui est un sous-type de <em>toutes</em> ces métaclasses candidates. Si aucune des métaclasses candidates ne remplit ce critère, alors la définition de la classe échoue en levant <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p>
</section>
<section id="preparing-the-class-namespace">
<span id="prepare"></span><h4><span class="section-number">3.3.3.4. </span>Préparation de l'espace de nommage de la classe<a class="headerlink" href="#preparing-the-class-namespace" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-87">Une fois que la métaclasse appropriée est identifiée, l'espace de nommage de la classe est préparé. Si la métaclasse possède un attribut <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code>, il est appelé avec <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">=</span> <span class="pre">metaclass.__prepare__(name,</span> <span class="pre">bases,</span> <span class="pre">**kwds)</span></code> (où les arguments nommés supplémentaires, s'il y en a, sont les arguments de la définition de la classe). La méthode <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> doit être implémentée comme une <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">méthode</span> <span class="pre">de</span> <span class="pre">classe</span></code></a>). L’espace de nommage renvoyé par <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> est passé à <code class="docutils literal notranslate"><span class="pre">__new__</span></code>, mais quand l’instance finale est créée, l’espace de nommage est copié vers un nouveau <code class="docutils literal notranslate"><span class="pre">dict</span></code>.</p>
<p>Si la métaclasse ne possède pas d'attribut <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code>, alors l'espace de nommage de la classe est initialisé en tant que tableau de correspondances ordonné.</p>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<dl class="simple">
<dt><span class="target" id="index-126"></span><a class="pep reference external" href="https://peps.python.org/pep-3115/"><strong>PEP 3115</strong></a> — Métaclasses dans Python 3000</dt><dd><p>introduction de la fonction automatique <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> de l'espace de nommage</p>
</dd>
</dl>
</div>
</section>
<section id="executing-the-class-body">
<h4><span class="section-number">3.3.3.5. </span>Exécution du corps de la classe<a class="headerlink" href="#executing-the-class-body" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-89">Le corps de la classe est exécuté (approximativement) avec <code class="docutils literal notranslate"><span class="pre">exec(body,</span> <span class="pre">globals(),</span> <span class="pre">namespace)</span></code>. La principale différence avec un appel normal à <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> est que la portée lexicale autorise le corps de la classe (y compris les méthodes) à faire référence aux noms de la portée courante et des portées externes lorsque la définition de classe a lieu dans une fonction.</p>
<p>Cependant, même quand une définition de classe intervient dans une fonction, les méthodes définies à l'intérieur de la classe ne peuvent pas voir les noms définis en dehors de la portée de la classe. On accède aux variables de la classe <em>via</em> le premier paramètre des méthodes d'instance ou de classe, ou <em>via</em> la référence implicite <code class="docutils literal notranslate"><span class="pre">__class__</span></code> incluse dans la portée lexicale et décrite dans la section suivante.</p>
</section>
<section id="creating-the-class-object">
<span id="class-object-creation"></span><h4><span class="section-number">3.3.3.6. </span>Création de l'objet classe<a class="headerlink" href="#creating-the-class-object" title="Lien permanent vers ce titre">¶</a></h4>
<p id="index-90">Quand l'espace de nommage a été rempli en exécutant le corps de la classe, l'objet classe est créé en appelant <code class="docutils literal notranslate"><span class="pre">metaclass(name,</span> <span class="pre">bases,</span> <span class="pre">namespace,</span> <span class="pre">**kwds)</span></code> (les arguments nommés supplémentaires passés ici sont les mêmes que ceux passés à <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code>).</p>
<p>Cet objet classe est celui qui est référencé par la forme sans argument de <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>. <code class="docutils literal notranslate"><span class="pre">__class__</span></code> est une référence implicite créée par le compilateur si une méthode du corps de la classe fait référence soit à <code class="docutils literal notranslate"><span class="pre">__class__</span></code>, soit à <code class="docutils literal notranslate"><span class="pre">super</span></code>. Ceci permet que la forme sans argument de <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> identifie la classe en cours de définition en fonction de la portée lexicale, tandis que la classe ou l'instance utilisée pour effectuer l'appel en cours est identifiée en fonction du premier argument transmis à la méthode.</p>
<div class="impl-detail compound">
<p><strong>Particularité de l'implémentation CPython :</strong> dans CPython 3.6 et suivants, la cellule <code class="docutils literal notranslate"><span class="pre">__class__</span></code> est passée à la métaclasse en tant qu'entrée <code class="docutils literal notranslate"><span class="pre">__classcell__</span></code> dans l'espace de nommage de la classe. Si elle est présente, elle doit être propagée à l'appel <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> pour que la classe soit correctement initialisée. Ne pas le faire se traduit par un <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> dans Python 3.8.</p>
</div>
<p>Quand vous utilisez la métaclasse par défaut <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> ou toute autre métaclasse qui finit par appeler <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>, les étapes de personnalisation supplémentaires suivantes sont suivies après la création de l'objet classe :</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> récupère, dans l'espace de nommage de la classe, tous les descripteurs qui définissent une méthode <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> ;</p></li>
<li><p>Toutes ces méthodes <code class="docutils literal notranslate"><span class="pre">__set_name__</span></code> sont appelées avec la classe en cours de définition et le nom assigné à chaque descripteur ;</p></li>
<li><p>La méthode automatique <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> est appelée sur le parent immédiat de la nouvelle classe en utilisant l'ordre de résolution des méthodes.</p></li>
</ol>
<p>Après la création de l'objet classe, il est passé aux décorateurs de la classe, y compris ceux inclus dans la définition de la classe (s'il y en a) et l'objet résultant est lié à l'espace de nommage local en tant que classe définie.</p>
<p>Quand une nouvelle classe est créée <em>via</em> <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>, l'objet fourni en tant que paramètre d'espace de nommage est copié vers un nouveau tableau de correspondances ordonné et l'objet original est laissé de côté. La nouvelle copie est encapsulée dans un mandataire en lecture seule qui devient l'attribut <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> de l'objet classe.</p>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<dl class="simple">
<dt><span class="target" id="index-127"></span><a class="pep reference external" href="https://peps.python.org/pep-3135/"><strong>PEP 3135</strong></a> — Nouvelle méthode super</dt><dd><p>Décrit la référence à la fermeture (<em>closure</em> en anglais) de la <code class="docutils literal notranslate"><span class="pre">__class__</span></code> implicite</p>
</dd>
</dl>
</div>
</section>
<section id="uses-for-metaclasses">
<h4><span class="section-number">3.3.3.7. </span>Cas d'utilisations des métaclasses<a class="headerlink" href="#uses-for-metaclasses" title="Lien permanent vers ce titre">¶</a></h4>
<p>Les utilisations possibles des métaclasses sont immenses. Quelques pistes ont déjà été explorées comme l'énumération, la gestion des traces, le contrôle des interfaces, la délégation automatique, la création automatique de propriétés, les mandataires, les <em>frameworks</em> ainsi que le verrouillage ou la synchronisation automatique de ressources.</p>
</section>
</section>
<section id="customizing-instance-and-subclass-checks">
<h3><span class="section-number">3.3.4. </span>Personnalisation des instances et vérification des sous-classes<a class="headerlink" href="#customizing-instance-and-subclass-checks" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les méthodes suivantes sont utilisées pour surcharger le comportement par défaut des fonctions natives <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> et <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>.</p>
<p>En particulier, la métaclasse <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code></a> implémente ces méthodes pour autoriser l'ajout de classes de base abstraites (ABC pour <em>Abstract Base Classes</em> en anglais) en tant que « classes de base virtuelles » pour toute classe ou type (y compris les types natifs).</p>
<dl class="py method">
<dt class="sig sig-object py" id="class.__instancecheck__">
<span class="sig-prename descclassname"><span class="pre">class.</span></span><span class="sig-name descname"><span class="pre">__instancecheck__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#class.__instancecheck__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>instance</em> doit être considérée comme une instance (directe ou indirecte) de <em>class</em>. Si elle est définie, elle est appelée pour implémenter <code class="docutils literal notranslate"><span class="pre">isinstance(instance,</span> <span class="pre">class)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="class.__subclasscheck__">
<span class="sig-prename descclassname"><span class="pre">class.</span></span><span class="sig-name descname"><span class="pre">__subclasscheck__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subclass</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasscheck__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>subclass</em> doit être considérée comme une sous-classe (directe ou indirecte) de <em>class</em>. Si elle est définie, appelée pour implémenter <code class="docutils literal notranslate"><span class="pre">issubclass(subclass,</span> <span class="pre">class)</span></code>.</p>
</dd></dl>

<p>Notez que ces méthodes sont recherchées dans le type (la métaclasse) d'une classe. Elles ne peuvent pas être définies en tant que méthodes de classe dans la classe réelle. C'est cohérent avec la recherche des méthodes spéciales qui sont appelées pour les instances, sauf qu'ici l'instance est elle-même une classe.</p>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<dl class="simple">
<dt><span class="target" id="index-128"></span><a class="pep reference external" href="https://peps.python.org/pep-3119/"><strong>PEP 3119</strong></a> — Introduction aux classes de bases abstraites</dt><dd><p>Inclut la spécification pour la personnalisation du comportement de <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> et <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> à travers <a class="reference internal" href="#class.__instancecheck__" title="class.__instancecheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__instancecheck__()</span></code></a> et <a class="reference internal" href="#class.__subclasscheck__" title="class.__subclasscheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__subclasscheck__()</span></code></a>, avec comme motivation pour cette fonctionnalité l'ajout des classes de base abstraites (voir le module <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>) au langage.</p>
</dd>
</dl>
</div>
</section>
<section id="emulating-generic-types">
<h3><span class="section-number">3.3.5. </span>Émulation de types génériques<a class="headerlink" href="#emulating-generic-types" title="Lien permanent vers ce titre">¶</a></h3>
<p>Lors de l'utilisation d'<a class="reference internal" href="../glossary.html#term-annotation"><span class="xref std std-term">annotations de types</span></a>, il est souvent utile de <em>paramètrer</em> un <a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">type générique</span></a> en se servant de la notation crochets de Python. Par exemple, l'annotation <code class="docutils literal notranslate"><span class="pre">list[int]</span></code> peut être utilisée pour signifier une <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">liste</span></code></a> dans laquelle tous les éléments sont de type <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">entiers</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<dl class="simple">
<dt><span class="target" id="index-129"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a> — Indications de types</dt><dd><p>Introduction à l'annotation de types en Python (document en anglais)</p>
</dd>
<dt><a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">Types alias génériques</span></a></dt><dd><p>Documentation pour les objets qui représentent des classes génériques paramétrées</p>
</dd>
<dt><a class="reference internal" href="../library/typing.html#generics"><span class="std std-ref">Génériques</span></a>, <a class="reference internal" href="../library/typing.html#user-defined-generics"><span class="std std-ref">Types génériques définis par l'utilisateur</span></a> et classe <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span> <span class="pre">(classe</span> <span class="pre">de</span> <span class="pre">base</span> <span class="pre">abstraite</span> <span class="pre">pour</span> <span class="pre">les</span> <span class="pre">types</span> <span class="pre">génériques)</span></code></a></dt><dd><p>Documentation sur la manière d'implémenter des classes génériques qui peuvent être paramétrées à l'exécution et comprises par les vérificateurs statiques de types.</p>
</dd>
</dl>
</div>
<p><em>Généralement</em>, une classe ne peut être paramétrée que si elle définit une méthode spéciale de classe <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__class_getitem__">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__class_getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__class_getitem__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un objet représentant la spécialisation d'une classe générique en fonction des arguments types trouvés dans <em>key</em>.</p>
<p>Lorsqu'elle est définie dans une classe, <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> est automatiquement une méthode de classe. Ainsi, il est superflu de la décorer avec <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a> lors de sa définition.</p>
</dd></dl>

<section id="the-purpose-of-class-getitem">
<h4><span class="section-number">3.3.5.1. </span>Intention de <em>__class_getitem__</em><a class="headerlink" href="#the-purpose-of-class-getitem" title="Lien permanent vers ce titre">¶</a></h4>
<p>Le but de <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> est de permettre la paramétrisation à l'exécution des classes génériques de la bibliothèque standard de façon à pouvoir appliquer plus facilement des <a class="reference internal" href="../glossary.html#term-type-hint"><span class="xref std std-term">annotations de type</span></a> à ces classes.</p>
<p>Pour implémenter des classes génériques particularisées pouvant être paramétrées à l'exécution, et comprises par les vérificateurs statiques de type, vous pouvez soit hériter d'une classe de la bibliothèque standard qui implémente déjà <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, ou hériter de <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a>, qui a sa propre implémentation de <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<p>Les implémentations particularisées de <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> sur des classes définies ailleurs que la bibliothèque standard peuvent ne pas être comprises par des vérificateurs de types tiers tels que <em>mypy</em>. L'utilisation de <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> pour tout autre objectif que l'annotation de type n'est pas conseillée.</p>
</section>
<section id="class-getitem-versus-getitem">
<span id="classgetitem-versus-getitem"></span><h4><span class="section-number">3.3.5.2. </span><em>__class_getitem__</em> contre <em>__getitem__</em><a class="headerlink" href="#class-getitem-versus-getitem" title="Lien permanent vers ce titre">¶</a></h4>
<p>D'habitude, l'<a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">indiçage</span></a> d'un objet en utilisant des crochets appelle la méthode <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> de l'instance, définie dans la classe de l'objet. Cependant, si l'objet dont on cherche un indice est lui-même une classe, la méthode de classe <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> peut être appelée à la place. <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> doit renvoyer un objet <a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias</span></a> si elle est correctement définie.</p>
<p>Lorsqu'on lui présente l'<a class="reference internal" href="../glossary.html#term-expression"><span class="xref std std-term">expression</span></a> <code class="docutils literal notranslate"><span class="pre">obj[x]</span></code>, l'interpréteur Python suit une sorte de processus suivant pour décider s'il faut appeler <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> ou <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">isclass</span>

<span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the result of the expression &#39;obj[x]&#39;&quot;&quot;&quot;</span>

    <span class="n">class_of_obj</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="c1"># If the class of obj defines __getitem__,</span>
    <span class="c1"># call class_of_obj.__getitem__(obj, x)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">class_of_obj</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">class_of_obj</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Else, if obj is a class and defines __class_getitem__,</span>
    <span class="c1"># call obj.__class_getitem__(x)</span>
    <span class="k">elif</span> <span class="n">isclass</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__class_getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">__class_getitem__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Else, raise an exception</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">class_of_obj</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object is not subscriptable&quot;</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>En Python, toutes les classes sont des instances d'autres classes. La classe d'une classe est appelée la <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">métaclasse</span></a> de la classe et la plupart des classes ont la classe <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> comme métaclasse. <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> ne définit pas <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, ce qui veut dire que des expressions telles que <code class="docutils literal notranslate"><span class="pre">list[int]</span></code>, <code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">float]</span></code> et <code class="docutils literal notranslate"><span class="pre">tuple[str,</span> <span class="pre">bytes]</span></code> aboutissent toutes à l'appel de <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># list has class &quot;type&quot; as its metaclass, like most classes:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="go">&lt;class &#39;type&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># &quot;list[int]&quot; calls &quot;list.__class_getitem__(int)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="go">list[int]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># list.__class_getitem__ returns a GenericAlias object:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="go">&lt;class &#39;types.GenericAlias&#39;&gt;</span>
</pre></div>
</div>
<p>Cependant, si une classe a une métaclasse particularisée qui définit <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, l'indiçage de la classe peut conduire à un comportement différent. Un exemple peut être trouvé dans le module <a class="reference internal" href="../library/enum.html#module-enum" title="enum: Implementation of an enumeration class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code></a> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Menu</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="gp">... </span><span class="w">    </span><span class="sd">&quot;&quot;&quot;A breakfast menu&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="n">SPAM</span> <span class="o">=</span> <span class="s1">&#39;spam&#39;</span>
<span class="gp">... </span>    <span class="n">BACON</span> <span class="o">=</span> <span class="s1">&#39;bacon&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Enum classes have a custom metaclass:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">)</span>
<span class="go">&lt;class &#39;enum.EnumMeta&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># EnumMeta defines __getitem__,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># so __class_getitem__ is not called,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and the result is not a GenericAlias object:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">]</span>
<span class="go">&lt;Menu.SPAM: &#39;spam&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">])</span>
<span class="go">&lt;enum &#39;Menu&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<dl class="simple">
<dt><span class="target" id="index-130"></span><a class="pep reference external" href="https://peps.python.org/pep-0560/"><strong>PEP 560</strong></a> — Gestion de base pour les types modules et les types génériques</dt><dd><p>Introduction de <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, et présentation des cas où un <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">indiçage</span></a> conduit à l'appel de <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> au lieu de <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a></p>
</dd>
</dl>
</div>
</section>
</section>
<section id="emulating-callable-objects">
<span id="id9"></span><h3><span class="section-number">3.3.6. </span>Émulation d'objets appelables<a class="headerlink" href="#emulating-callable-objects" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="object.__call__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">args...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__call__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-95">Appelée quand l'instance est « appelée » en tant que fonction ; si la méthode est définie, <code class="docutils literal notranslate"><span class="pre">x(arg1,</span> <span class="pre">arg2,</span> <span class="pre">…)</span></code> est un raccourci pour <code class="docutils literal notranslate"><span class="pre">type(x).__call__(x,</span> <span class="pre">arg1,</span> <span class="pre">…)</span></code>.</p>
</dd></dl>

</section>
<section id="emulating-container-types">
<span id="sequence-types"></span><h3><span class="section-number">3.3.7. </span>Émulation de types conteneurs<a class="headerlink" href="#emulating-container-types" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les fonctions suivantes peuvent être définies pour implémenter des objets conteneurs. Les conteneurs sont habituellement des <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">séquences</span></a> (telles que les <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">listes</span></code></a> ou les <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">n-uplets</span></code></a>) ou des <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">tableaux de correspondances</span></a> (comme les <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionnaires</span></code></a>), mais ils peuvent aussi représenter d'autres conteneurs. Le premier ensemble de méthodes est utilisé soit pour émuler une séquence, soit pour émuler un tableau de correspondances ; la différence est que, pour une séquence, les clés doivent être soit des entiers <em>k</em> tels que <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">N</span></code> où <em>N</em> est la longueur de la séquence, soit des objets <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">tranches</span></code></a> qui définissent un intervalle d'éléments. Il est aussi recommandé que les tableaux de correspondances fournissent les méthodes <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code> et <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> avec un comportement similaire aux objets <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionnaires</span></code></a> standards de Python. Le module <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> fournit une <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">classe de base abstraite</span></a> <a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a> pour aider à la création de ces méthodes à partir d'un ensemble de base composé de <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a> et <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>. Les séquences muables doivent fournir les méthodes <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code> et <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code>, comme les objets <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">listes</span></code></a> standards de Python. Enfin, les types séquences doivent implémenter l'addition (dans le sens de la concaténation) et la multiplication (dans le sens de la répétition) en définissant les méthodes <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a>, <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>, <a class="reference internal" href="#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a>, <a class="reference internal" href="#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code></a> et <a class="reference internal" href="#object.__imul__" title="object.__imul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__imul__()</span></code></a> décrites ci-dessous ; ils ne doivent pas définir d'autres opérateurs numériques. Il est recommandé que les tableaux de correspondances et les séquences implémentent la méthode <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> pour permettre l'utilisation efficace de l'opérateur <code class="docutils literal notranslate"><span class="pre">in</span></code> ; concernant les tableaux de correspondances, <code class="docutils literal notranslate"><span class="pre">in</span></code> doit rechercher dans les clés du tableau ; pour les séquences, il doit chercher dans les valeurs. Il est de plus recommandé que les tableaux de correspondances et les séquences implémentent la méthode <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> pour permettre une itération efficace dans le conteneur ; pour les tableaux de correspondances, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> doit itérer sur les clés de l'objet ; pour les séquences, elle doit itérer sur les valeurs.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__len__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__len__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-96">Called to implement the built-in function <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>.  Should return the length
of the object, an integer <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0.  Also, an object that doesn't define a
<a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> method and whose <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> method returns zero is
considered to be false in a Boolean context.</p>
<div class="impl-detail compound">
<p><strong>Particularité de l'implémentation CPython :</strong> In CPython, the length is required to be at most <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a>.
If the length is larger than <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code> some features (such as
<a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>) may raise <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>.  To prevent raising
<code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code> by truth value testing, an object must define a
<a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> method.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__length_hint__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__length_hint__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__length_hint__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée pour implémenter <a class="reference internal" href="../library/operator.html#operator.length_hint" title="operator.length_hint"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.length_hint()</span></code></a>. Elle doit renvoyer une longueur estimée de l'objet (qui peut être plus grande ou plus petite que la longueur réelle). La longueur doit être un entier <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0. La valeur de retour peut aussi être <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-const docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>, qui est traitée de la même façon que si la méthode <code class="docutils literal notranslate"><span class="pre">__length_hint__</span></code> n'existait pas. Cette méthode est utilisée uniquement pour optimiser les traitements et n'est jamais tenue de renvoyer un résultat exact.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.4.</span></p>
</div>
</dd></dl>

<div class="admonition note" id="index-97">
<p class="admonition-title">Note</p>
<p>le découpage est effectué uniquement à l'aide des trois méthodes suivantes. Un appel comme</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>est traduit en</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>et ainsi de suite. Les éléments manquants sont remplacés par <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="object.__getitem__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getitem__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée pour implémenter l'évaluation de <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. Pour les types <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">séquences</span></a>, les clés autorisées sont les entiers et les objets tranches (<em>slice</em>). Notez que l'interprétation spéciale des indices négatifs (si la classe souhaite émuler un type <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">séquence</span></a>) est du ressort de la méthode <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>. Si <em>key</em> n'est pas du bon type, une <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> peut être levée ; si la valeur est en dehors de l'ensemble des indices de la séquence (après interprétation éventuelle des valeurs négatives), une <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> doit être levée. Pour les <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">tableaux de correspondances</span></a>, si <em>key</em> n'existe pas dans le conteneur, une <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> doit être levée.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> s'attend à ce qu'une <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> soit levée en cas d'indice illégal afin de détecter correctement la fin de la séquence.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>quand on vous <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">spécifiez un indice</span></a> pour une <em>classe</em>, la méthode de classe spéciale <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> peut être appelée au lieu de <code class="docutils literal notranslate"><span class="pre">__getitem__()</span></code>. Reportez-vous à <a class="reference internal" href="#classgetitem-versus-getitem"><span class="std std-ref">__class_getitem__ contre __getitem__</span></a> pour plus de détails.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__setitem__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__setitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setitem__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée pour implémenter l'assignation à <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. La même note que pour <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> s'applique. Elle ne doit être implémentée que pour les tableaux de correspondances qui autorisent les modifications de valeurs des clés, ceux pour lesquels on peut ajouter de nouvelles clés ou, pour les séquences, celles dont les éléments peuvent être remplacés. Les mêmes exceptions que pour la méthode <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> doivent être levées en cas de mauvaises valeurs de clés.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__delitem__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__delitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delitem__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée pour implémenter la suppression de <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. La même note que pour <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> s'applique. Elle ne doit être implémentée que pour les tableaux de correspondances qui autorisent les suppressions de clés ou pour les séquences dont les éléments peuvent être supprimés de la séquence. Les mêmes exceptions que pour la méthode <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> doivent être levées en cas de mauvaises valeurs de clés.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__missing__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__missing__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__missing__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée par <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> pour implémenter <code class="docutils literal notranslate"><span class="pre">self[key]</span></code> dans les sous-classes de dictionnaires lorsque la clé n'est pas dans le dictionnaire.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__iter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iter__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette méthode est appelée quand un <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">itérateur</span></a> est requis pour un conteneur. Cette méthode doit renvoyer un nouvel objet itérateur qui peut itérer sur tous les objets du conteneur. Pour les tableaux de correspondances, elle doit itérer sur les clés du conteneur.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__reversed__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__reversed__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__reversed__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée (si elle existe) par la fonction native <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> pour implémenter l'itération en sens inverse. Elle doit renvoyer un nouvel objet itérateur qui itère sur tous les objets du conteneur en sens inverse.</p>
<p>Si la méthode <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> n'est pas fournie, la fonction native <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> se replie sur le protocole de séquence (<a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> et <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>). Les objets qui connaissent le protocole de séquence ne doivent fournir <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> que si l'implémentation qu'ils proposent est plus efficace que celle de <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a>.</p>
</dd></dl>

<p>Les opérateurs de tests d'appartenance (<a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> et <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>) sont normalement implémentés comme des itérations sur un conteneur. Cependant, les objets conteneurs peuvent fournir les méthodes spéciales suivantes avec une implémentation plus efficace, qui ne requièrent d'ailleurs pas que l'objet soit itérable.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__contains__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__contains__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__contains__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée pour implémenter les opérateurs de test d'appartenance. Elle doit renvoyer <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>item</em> est dans <em>self</em> et <code class="docutils literal notranslate"><span class="pre">False</span></code> sinon. Pour les tableaux de correspondances, seules les clés sont considérées (pas les valeurs des paires clés-valeurs).</p>
<p>Pour les objets qui ne définissent pas <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, les tests d'appartenance essaient d'abord d'itérer avec <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> puis avec le vieux protocole d'itération sur les séquences <em>via</em> <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, reportez-vous à <a class="reference internal" href="expressions.html#membership-test-details"><span class="std std-ref">cette section dans la référence du langage</span></a>.</p>
</dd></dl>

</section>
<section id="emulating-numeric-types">
<span id="numeric-types"></span><h3><span class="section-number">3.3.8. </span>Émulation de types numériques<a class="headerlink" href="#emulating-numeric-types" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les méthodes suivantes peuvent être définies pour émuler des objets numériques. Les méthodes correspondant à des opérations qui ne sont pas autorisées pour la catégorie de nombres considérée (par exemple, les opérations bit à bit pour les nombres qui ne sont pas entiers) doivent être laissées indéfinies.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__add__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__add__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__sub__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__sub__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__mul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mul__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__matmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__matmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__matmul__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__truediv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__truediv__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__floordiv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__floordiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floordiv__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__mod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__mod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mod__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__divmod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__divmod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__divmod__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__pow__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__pow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__pow__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__lshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__lshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lshift__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rshift__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__and__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__and__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__xor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__xor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__xor__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__or__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__or__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__or__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-98">Ces méthodes sont appelées pour implémenter les opérations arithmétiques binaires (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>). Par exemple, pour évaluer l'expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>, où <em>x</em> est une instance d'une classe qui possède une méthode <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">type(x).__add__(x,</span> <span class="pre">y)</span></code> est appelée. La méthode <a class="reference internal" href="#object.__divmod__" title="object.__divmod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__divmod__()</span></code></a> doit être l'équivalent d'appeler <a class="reference internal" href="#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> et <a class="reference internal" href="#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a> ; elle ne doit pas être reliée à <a class="reference internal" href="#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a>. Notez que <a class="reference internal" href="#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a> doit être définie de manière à accepter un troisième argument optionnel si la version ternaire de la fonction native <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> est autorisée.</p>
<p>Si l'une de ces méthodes n'autorise pas l'opération avec les arguments donnés, elle doit renvoyer <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__radd__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__radd__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rsub__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rsub__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmul__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rmatmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rmatmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmatmul__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rtruediv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rtruediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rtruediv__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rfloordiv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rfloordiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rfloordiv__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rmod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rmod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmod__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rdivmod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rdivmod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rdivmod__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rpow__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rpow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__rpow__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rlshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rlshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rlshift__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rrshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rrshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rrshift__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rand__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rand__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rxor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rxor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rxor__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ror__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ror__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ror__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-99">Ces méthodes sont appelées pour implémenter les opérations arithmétiques binaires (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>) avec des opérandes renversés (intervertis). Ces fonctions ne sont appelées que si l'opérande de gauche n'autorise pas l'opération correspondante <a class="footnote-reference brackets" href="#id15" id="id10">3</a> et si les opérandes sont de types différents <a class="footnote-reference brackets" href="#id16" id="id11">4</a>. Par exemple, pour évaluer l'expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code>, où <em>y</em> est une instance d'une classe qui possède une méthode <a class="reference internal" href="#object.__rsub__" title="object.__rsub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rsub__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">type(y).__rsub__(y,</span> <span class="pre">x)</span></code> est appelée si <code class="docutils literal notranslate"><span class="pre">type(x)__sub__(x,</span> <span class="pre">y)</span></code> renvoie <em>NotImplemented</em>.</p>
<p id="index-100">Notez que la fonction ternaire <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> n'essaie pas d'appeler <a class="reference internal" href="#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rpow__()</span></code></a> (les règles de coercition seraient trop compliquées).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>si le type de l'opérande de droite est une sous-classe du type de l'opérande de gauche et que cette sous-classe fournit une implémentation différente de la méthode symétrique pour l'opération, cette méthode est appelée avant la méthode originelle de l'opérande gauche. Ce comportement permet à des sous-classes de surcharger les opérations de leurs ancêtres.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__iadd__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__iadd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iadd__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__isub__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__isub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__isub__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__imul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__imul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imul__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__imatmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__imatmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imatmul__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__itruediv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__itruediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__itruediv__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ifloordiv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ifloordiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ifloordiv__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__imod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__imod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imod__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ipow__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ipow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__ipow__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ilshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ilshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ilshift__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__irshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__irshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__irshift__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__iand__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__iand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iand__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ixor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ixor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ixor__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ior__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ior__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ior__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ces méthodes sont appelées pour implémenter les affectations arithmétiques augmentées (<code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">//=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>). Ces méthodes doivent essayer d'effectuer l'opération « sur place » (c'est-à-dire de modifier <em>self</em>) et de renvoyer le résultat (qui peut être, mais pas nécessairement, <em>self</em>). Si une méthode spécifique n'est pas définie, l'assignation augmentée se replie vers la méthode normale correspondante. Par exemple, si <em>x</em> est une instance d'une classe qui possède une méthode <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></code> est équivalent à <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x.__iadd__(y)</span></code>. Sinon, <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> et <code class="docutils literal notranslate"><span class="pre">y.__radd__(x)</span></code> sont essayées, comme pour l'évaluation de <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>. Dans certaines situations, les assignations augmentées peuvent causer des erreurs inattendues (voir <a class="reference internal" href="../faq/programming.html#faq-augmented-assignment-tuple-error"><span class="std std-ref">Pourquoi a_tuple[i] += ['item'] lève-t-il une exception alors que l'addition fonctionne ?</span></a>), mais ce comportement est en fait partie intégrante du modèle de données.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__neg__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__neg__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__pos__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__pos__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__abs__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__abs__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__abs__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__invert__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__invert__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__invert__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-101">Appelées pour implémenter les opérations arithmétiques unaires (<code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> et <code class="docutils literal notranslate"><span class="pre">~</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__complex__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__complex__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__complex__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__int__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__int__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__int__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__float__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__float__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__float__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-102">Appelées pour implémenter les fonctions natives <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> et <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a>. Elles doivent renvoyer une valeur du type approprié.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__index__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__index__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__index__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelée pour implémenter <a class="reference internal" href="../library/operator.html#operator.index" title="operator.index"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.index()</span></code></a> et lorsque Python a besoin de convertir sans perte un objet numérique en objet entier (pour un découpage ou dans les fonctions natives <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a>, <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a> et <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a>). La présence de cette méthode indique que l'objet numérique est un type entier. Elle doit renvoyer un entier.</p>
<p>Si <a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a>, <a class="reference internal" href="#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> et <a class="reference internal" href="#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a> ne sont pas définies, alors les fonctions natives <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> et <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> redirigent par défaut vers <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__round__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__round__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">ndigits</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__round__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__trunc__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__trunc__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__trunc__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__floor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__floor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floor__" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ceil__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ceil__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ceil__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-103">Appelées pour implémenter la fonction native <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> et les fonctions du module <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> <a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code></a>, <a class="reference internal" href="../library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a> et <a class="reference internal" href="../library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a>. À moins que <em>ndigits</em> ne soit passé à <code class="xref py py-meth docutils literal notranslate"><span class="pre">__round__()</span></code>, toutes ces méthodes doivent renvoyer la valeur de l'objet tronquée pour donner un <a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> (typiquement un <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>).</p>
<p>La fonction native <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> se replie sur <a class="reference internal" href="#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a> dans le cas où ni <a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> ni <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> ne sont définies.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>la délégation de <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> vers <code class="xref py py-func docutils literal notranslate"><span class="pre">__trunc__()</span></code> est obsolète.</p>
</div>
</dd></dl>

</section>
<section id="with-statement-context-managers">
<span id="context-managers"></span><h3><span class="section-number">3.3.9. </span>Gestionnaire de contexte With<a class="headerlink" href="#with-statement-context-managers" title="Lien permanent vers ce titre">¶</a></h3>
<p>Un <em class="dfn">gestionnaire de contexte</em> est un objet qui met en place un contexte prédéfini au moment de l'exécution de l'instruction <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>. Le gestionnaire de contexte gère l'entrée et la sortie de ce contexte d'exécution pour tout un bloc de code. Les gestionnaires de contextes sont normalement invoqués en utilisant une instruction <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> (décrite dans la section <a class="reference internal" href="compound_stmts.html#with"><span class="std std-ref">L'instruction with</span></a>), mais ils peuvent aussi être directement invoqués par leurs méthodes.</p>
<p id="index-104">Les utilisations classiques des gestionnaires de contexte sont la sauvegarde et la restauration d'états divers, le verrouillage et le déverrouillage de ressources, la fermeture de fichiers ouverts, etc.</p>
<p>Pour plus d'informations sur les gestionnaires de contexte, lisez <a class="reference internal" href="../library/stdtypes.html#typecontextmanager"><span class="std std-ref">Le type gestionnaire de contexte</span></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__enter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__enter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__enter__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Entre dans le contexte d'exécution relatif à cet objet. L'instruction <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> lie la valeur de retour de cette méthode à une (ou plusieurs) cible spécifiée par la clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> de l'instruction, si elle est spécifiée.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__exit__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__exit__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__exit__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Sort du contexte d'exécution relatif à cet objet. Les paramètres décrivent l'exception qui a causé la sortie du contexte. Si l'on sort du contexte sans exception, les trois arguments sont à <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.</p>
<p>Si une exception est indiquée et que la méthode souhaite supprimer l'exception (c'est-à-dire qu'elle ne veut pas que l'exception soit propagée), elle doit renvoyer <code class="docutils literal notranslate"><span class="pre">True</span></code>. Sinon, l'exception est traitée normalement à la sortie de cette méthode.</p>
<p>Note that <a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> methods should not reraise the passed-in exception;
this is the caller's responsibility.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<dl class="simple">
<dt><span class="target" id="index-131"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a> — L'instruction <code class="docutils literal notranslate"><span class="pre">with</span></code></dt><dd><p>La spécification, les motivations et des exemples de l'instruction <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> en Python.</p>
</dd>
</dl>
</div>
</section>
<section id="customizing-positional-arguments-in-class-pattern-matching">
<span id="class-pattern-matching"></span><h3><span class="section-number">3.3.10. </span>Arguments positionnels dans le filtrage par motif sur les classes<a class="headerlink" href="#customizing-positional-arguments-in-class-pattern-matching" title="Lien permanent vers ce titre">¶</a></h3>
<p>When using a class name in a pattern, positional arguments in the pattern are not
allowed by default, i.e. <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(x,</span> <span class="pre">y)</span></code> is typically invalid without special
support in <code class="docutils literal notranslate"><span class="pre">MyClass</span></code>. To be able to use that kind of pattern, the class needs to
define a <em>__match_args__</em> attribute.</p>
<dl class="py data">
<dt class="sig sig-object py" id="object.__match_args__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__match_args__</span></span><a class="headerlink" href="#object.__match_args__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cet attribut de la classe est un <em>n</em>-uplet de chaînes. Lorsque la classe apparaît dans un filtre avec des arguments positionnels, ils sont convertis en arguments nommés avec les noms du <em>n</em>-uplet, dans l'ordre. Si l'attribut n'est pas défini, tout se passe comme si sa valeur était le <em>n</em>-uplet vide <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
</dd></dl>

<p>Ainsi, si <code class="docutils literal notranslate"><span class="pre">UneClasse.__match_args__</span></code> est mis à <code class="docutils literal notranslate"><span class="pre">(&quot;gauche&quot;,</span> <span class="pre">&quot;milieu&quot;,</span> <span class="pre">&quot;droite&quot;)</span></code>, le filtre <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">UneClasse(x,</span> <span class="pre">y)</span></code> est équivalent à <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">UneClasse(gauche=x,</span> <span class="pre">milieu=y)</span></code>. Le filtre doit comporter au maximum autant d'arguments positionnels que la longueur <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code>. Dans le cas contraire, le filtrage lève l'exception <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.10.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<dl class="simple">
<dt><span class="target" id="index-132"></span><a class="pep reference external" href="https://peps.python.org/pep-0634/"><strong>PEP 634</strong></a> — Filtrage par motif structurel</dt><dd><p>Spécification de l'instruction <code class="docutils literal notranslate"><span class="pre">match</span></code>.</p>
</dd>
</dl>
</div>
</section>
<section id="emulating-buffer-types">
<span id="python-buffer-protocol"></span><h3><span class="section-number">3.3.11. </span>Emulating buffer types<a class="headerlink" href="#emulating-buffer-types" title="Lien permanent vers ce titre">¶</a></h3>
<p>The <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">buffer protocol</span></a> provides a way for Python
objects to expose efficient access to a low-level memory array. This protocol
is implemented by builtin types such as <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> and <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>,
and third-party libraries may define additional buffer types.</p>
<p>While buffer types are usually implemented in C, it is also possible to
implement the protocol in Python.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__buffer__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__buffer__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__buffer__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Called when a buffer is requested from <em>self</em> (for example, by the
<a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> constructor). The <em>flags</em> argument is an integer
representing the kind of buffer requested, affecting for example whether
the returned buffer is read-only or writable. <a class="reference internal" href="../library/inspect.html#inspect.BufferFlags" title="inspect.BufferFlags"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.BufferFlags</span></code></a>
provides a convenient way to interpret the flags. The method must return
a <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__release_buffer__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__release_buffer__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__release_buffer__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Called when a buffer is no longer needed. The <em>buffer</em> argument is a
<a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> object that was previously returned by
<a class="reference internal" href="#object.__buffer__" title="object.__buffer__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__buffer__()</span></code></a>. The method must release any resources associated
with the buffer. This method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.
Buffer objects that do not need to perform any cleanup are not required
to implement this method.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.12.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<dl class="simple">
<dt><span class="target" id="index-107"></span><a class="pep reference external" href="https://peps.python.org/pep-0688/"><strong>PEP 688</strong></a> - Making the buffer protocol accessible in Python</dt><dd><p>Introduces the Python <code class="docutils literal notranslate"><span class="pre">__buffer__</span></code> and <code class="docutils literal notranslate"><span class="pre">__release_buffer__</span></code> methods.</p>
</dd>
<dt><a class="reference internal" href="../library/collections.abc.html#collections.abc.Buffer" title="collections.abc.Buffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Buffer</span></code></a></dt><dd><p>ABC for buffer types.</p>
</dd>
</dl>
</div>
</section>
<section id="special-method-lookup">
<span id="special-lookup"></span><h3><span class="section-number">3.3.12. </span>Recherche des méthodes spéciales<a class="headerlink" href="#special-method-lookup" title="Lien permanent vers ce titre">¶</a></h3>
<p>Pour les classes définies par le développeur, l'invocation implicite de méthodes spéciales n'est garantie que si ces méthodes sont définies par le type d'objet, pas dans le dictionnaire de l'objet instance. Ce comportement explique pourquoi le code suivant lève une exception :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object of type &#39;C&#39; has no len()</span>
</pre></div>
</div>
<p>La raison de ce comportement vient de certaines méthodes spéciales telles que <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> et <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> qui sont implémentées par tous les objets, y compris les objets types. Si la recherche effectuée par ces méthodes utilisait le processus normal de recherche, elles ne fonctionneraient pas si on les appelait sur l'objet type lui-même :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span>
</pre></div>
</div>
<p>Essayer d'invoquer une méthode non liée d'une classe de cette manière est parfois appelé « confusion de métaclasse » et se contourne en shuntant l'instance lors de la recherche des méthodes spéciales :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>En plus de shunter les attributs des instances pour fonctionner correctement, la recherche des méthodes spéciales implicites shunte aussi la méthode <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> même dans la métaclasse de l'objet :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metaclass getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Class getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>                 <span class="c1"># Explicit lookup via instance</span>
<span class="go">Class getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># Explicit lookup via type</span>
<span class="go">Metaclass getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                      <span class="c1"># Implicit lookup</span>
<span class="go">10</span>
</pre></div>
</div>
<p>En shuntant le mécanisme de <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> de cette façon, cela permet d'optimiser la vitesse de l'interpréteur moyennant une certaine manœuvre dans la gestion des méthodes spéciales (la méthode spéciale <em>doit</em> être définie sur l'objet classe lui-même afin d'être invoquée de manière cohérente par l'interpréteur).</p>
</section>
</section>
<section id="coroutines">
<span id="index-108"></span><h2><span class="section-number">3.4. </span>Coroutines<a class="headerlink" href="#coroutines" title="Lien permanent vers ce titre">¶</a></h2>
<section id="awaitable-objects">
<h3><span class="section-number">3.4.1. </span>Objets <em>attendables</em> (<em>awaitable</em>)<a class="headerlink" href="#awaitable-objects" title="Lien permanent vers ce titre">¶</a></h3>
<p>Un objet <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> implémente généralement une méthode <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>. Les objets <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> renvoyés par les fonctions <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> sont des <em>attendables</em> (<em>awaitable</em>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>les objets <a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">itérateur de générateur</span></a> renvoyés par les générateurs décorés par <a class="reference internal" href="../library/types.html#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.coroutine()</span></code></a> sont aussi des <em>attendables</em> (<em>awaitable</em>), mais ils n'implémentent pas <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="object.__await__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__await__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__await__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Doit renvoyer un <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">itérateur</span></a>. Doit être utilisé pour implémenter les objets <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a>. Par exemple, <a class="reference internal" href="../library/asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> implémente cette méthode pour être compatible avec les expressions <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The language doesn't place any restriction on the type or value of the
objects yielded by the iterator returned by <code class="docutils literal notranslate"><span class="pre">__await__</span></code>, as this is
specific to the implementation of the asynchronous execution framework
(e.g. <a class="reference internal" href="../library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>) that will be managing the <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> object.</p>
</div>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.5.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p><span class="target" id="index-133"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> pour les informations relatives aux objets <em>attendables</em> (<em>awaitable</em>).</p>
</div>
</section>
<section id="coroutine-objects">
<span id="id12"></span><h3><span class="section-number">3.4.2. </span>Objets coroutines<a class="headerlink" href="#coroutine-objects" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les objets <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> sont des objets <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a>. L'exécution d'une coroutine peut être contrôlée en appelant <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> et en itérant sur le résultat. Quand la coroutine a fini de s'exécuter et termine, l'itérateur lève <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> et l'attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> de l'exception contient la valeur de retour. Si la coroutine lève une exception, elle est propagée par l'itérateur. Les coroutines ne doivent pas lever directement des exceptions <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> non gérées.</p>
<p>Les coroutines disposent aussi des méthodes listées ci-dessous, analogues à celles des générateurs (voir <a class="reference internal" href="expressions.html#generator-methods"><span class="std std-ref">Méthodes des générateurs-itérateurs</span></a>). Cependant, au contraire des générateurs, vous ne pouvez pas itérer directement sur des coroutines.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5.2: </span>utiliser <em>await</em> plus d'une fois sur une coroutine lève une <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="coroutine.send">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.send" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Démarre ou reprend l'exécution d'une coroutine. Si <em>value</em> est <code class="docutils literal notranslate"><span class="pre">None</span></code>, c'est équivalent à avancer l'itérateur renvoyé par <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>. Si <em>value</em> ne vaut pas <code class="docutils literal notranslate"><span class="pre">None</span></code>, cette méthode appelle la méthode <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> de l'itérateur qui a causé la suspension de la coroutine. Le résultat (valeur de retour, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> ou une autre exception) est le même que lorsque vous itérez sur la valeur de retour de <code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code>, décrite ci-dessus.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coroutine.throw">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.throw" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Lève l'exception spécifiée dans la coroutine. Cette méthode délègue à la méthode <a class="reference internal" href="expressions.html#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> de l'itérateur qui a causé la suspension de la coroutine, s'il possède une telle méthode. Sinon, l'exception est levée au point de suspension. Le résultat (valeur de retour, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> ou une autre exception) est le même que lorsque vous itérez sur la valeur de retour de <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>, décrite ci-dessus. Si l'exception n'est pas gérée par la coroutine, elle est propagée à l'appelant.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.12: </span>The second signature (type[, value[, traceback]]) is deprecated and
may be removed in a future version of Python.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coroutine.close">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.close" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Demande à la coroutine de faire le ménage et de se terminer. Si la coroutine est suspendue, cette méthode délègue d'abord à la méthode <a class="reference internal" href="expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> de l'itérateur qui a causé la suspension de la coroutine, s'il possède une telle méthode. Ensuite, elle lève <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> au point de suspension, ce qui fait le ménage dans la coroutine immédiatement. Enfin, la coroutine est marquée comme ayant terminé son exécution, même si elle n'a jamais démarré.</p>
<p>Les objets coroutines sont automatiquement fermés en utilisant le processus décrit au-dessus au moment où ils sont détruits.</p>
</dd></dl>

</section>
<section id="asynchronous-iterators">
<span id="async-iterators"></span><h3><span class="section-number">3.4.3. </span>Itérateurs asynchrones<a class="headerlink" href="#asynchronous-iterators" title="Lien permanent vers ce titre">¶</a></h3>
<p>Un <em>itérateur asynchrone</em> peut appeler du code asynchrone dans sa méthode <code class="docutils literal notranslate"><span class="pre">__anext__</span></code>.</p>
<p>Les itérateurs asynchrones peuvent être utilisés dans des instructions <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__aiter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__aiter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aiter__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Doit renvoyer un objet <em>itérateur asynchrone</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__anext__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__anext__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__anext__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Doit renvoyer un <em>attendable</em> (<em>awaitable</em>) qui se traduit par la valeur suivante de l'itérateur. Doit lever une <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> quand l'itération est terminée.</p>
</dd></dl>

<p>Un exemple d'objet itérateur asynchrone :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reader</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopAsyncIteration</span>
        <span class="k">return</span> <span class="n">val</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>avant Python 3.7, <a class="reference internal" href="#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> pouvait renvoyer un <em>attendable</em> (<em>awaitable</em>) qui se résolvait potentiellement en un <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">itérateur asynchrone</span></a>.</p>
<p>À partir de Python 3.7, <a class="reference internal" href="#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> doit renvoyer un objet itérateur asynchrone. Renvoyer autre chose entraine une erreur <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
</div>
</section>
<section id="asynchronous-context-managers">
<span id="async-context-managers"></span><h3><span class="section-number">3.4.4. </span>Gestionnaires de contexte asynchrones<a class="headerlink" href="#asynchronous-context-managers" title="Lien permanent vers ce titre">¶</a></h3>
<p>Un <em>gestionnaire de contexte asynchrone</em> est un <em>gestionnaire de contexte</em> qui est capable de suspendre son exécution dans ses méthodes <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> et <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code>.</p>
<p>Les gestionnaires de contexte asynchrones peuvent être utilisés dans des instructions <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__aenter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__aenter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aenter__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Semantically similar to <a class="reference internal" href="#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a>, the only
difference being that it must return an <em>awaitable</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__aexit__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__aexit__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aexit__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Semantically similar to <a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a>, the only
difference being that it must return an <em>awaitable</em>.</p>
</dd></dl>

<p>Un exemple de classe de gestionnaire de contexte asynchrone :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;entering context&#39;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;exiting context&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.5.</span></p>
</div>
<p class="rubric">Notes de bas de page</p>
<dl class="footnote brackets">
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Il <em>est</em> possible, dans certains cas, de changer le type d'un objet, sous certaines conditions. Cependant, ce n'est généralement pas une bonne idée car cela peut conduire à un comportement très étrange si ce n'est pas géré correctement.</p>
</dd>
<dt class="label" id="id14"><span class="brackets"><a class="fn-backref" href="#id6">2</a></span></dt>
<dd><p>Les méthodes <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> et <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> ont une gestion particulière pour cela ; les autres lèvent toujours <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, mais le font en considérant que <code class="docutils literal notranslate"><span class="pre">None</span></code> n'est pas un appelable.</p>
</dd>
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id10">3</a></span></dt>
<dd><p><em>n'autorise pas</em> signifie ici que la classe ne possède pas de méthode adéquate ou que la méthode renvoie <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>. N'assignez pas <code class="docutils literal notranslate"><span class="pre">None</span></code> à la méthode si vous voulez un repli vers la méthode symétrique de l'opérande de droite — cela aurait pour effet de <em>bloquer</em> un tel repli.</p>
</dd>
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id11">4</a></span></dt>
<dd><p>Pour des opérandes de même type, on considère que si la méthode originelle (telle que <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>) échoue, alors l'opération en tant que telle n'est pas autorisée et donc la méthode symétrique n'est pas appelée.</p>
</dd>
</dl>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#">3. Modèle de données</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. Objets, valeurs et types</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. Hiérarchie des types standards</a><ul>
<li><a class="reference internal" href="#none">3.2.1. <code class="docutils literal notranslate"><span class="pre">None</span></code></a></li>
<li><a class="reference internal" href="#notimplemented">3.2.2. NotImplemented</a></li>
<li><a class="reference internal" href="#ellipsis">3.2.3. Ellipse</a></li>
<li><a class="reference internal" href="#numbers-number">3.2.4. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a><ul>
<li><a class="reference internal" href="#numbers-integral">3.2.4.1. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a></li>
<li><a class="reference internal" href="#numbers-real-float">3.2.4.2. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>)</a></li>
<li><a class="reference internal" href="#numbers-complex-complex">3.2.4.3. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequences">3.2.5. Séquences</a><ul>
<li><a class="reference internal" href="#immutable-sequences">3.2.5.1. Séquences immuables</a></li>
<li><a class="reference internal" href="#mutable-sequences">3.2.5.2. Séquences muables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-types">3.2.6. Ensembles</a></li>
<li><a class="reference internal" href="#mappings">3.2.7. Tableaux de correspondances</a><ul>
<li><a class="reference internal" href="#dictionaries">3.2.7.1. Dictionnaires</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callable-types">3.2.8. Types appelables</a><ul>
<li><a class="reference internal" href="#user-defined-functions">3.2.8.1. Fonctions définies par l'utilisateur</a></li>
<li><a class="reference internal" href="#instance-methods">3.2.8.2. Méthodes d'instances</a></li>
<li><a class="reference internal" href="#generator-functions">3.2.8.3. Fonctions génératrices (ou générateurs)</a></li>
<li><a class="reference internal" href="#coroutine-functions">3.2.8.4. Fonctions coroutines</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">3.2.8.5. Fonctions génératrices (ou générateurs) asynchrones</a></li>
<li><a class="reference internal" href="#built-in-functions">3.2.8.6. Fonctions natives</a></li>
<li><a class="reference internal" href="#built-in-methods">3.2.8.7. Méthodes natives</a></li>
<li><a class="reference internal" href="#classes">3.2.8.8. Classes</a></li>
<li><a class="reference internal" href="#class-instances">3.2.8.9. Instances de classe</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modules">3.2.9. Modules</a></li>
<li><a class="reference internal" href="#custom-classes">3.2.10. Classes déclarées par le développeur</a></li>
<li><a class="reference internal" href="#id2">3.2.11. Instances de classe</a></li>
<li><a class="reference internal" href="#i-o-objects-also-known-as-file-objects">3.2.12. Objets entrées-sorties (ou objets fichiers)</a></li>
<li><a class="reference internal" href="#internal-types">3.2.13. Types internes</a><ul>
<li><a class="reference internal" href="#code-objects">3.2.13.1. Objets Code</a></li>
<li><a class="reference internal" href="#frame-objects">3.2.13.2. Objets cadres</a></li>
<li><a class="reference internal" href="#traceback-objects">3.2.13.3. Objets traces d'appels</a></li>
<li><a class="reference internal" href="#slice-objects">3.2.13.4. Objets tranches</a></li>
<li><a class="reference internal" href="#static-method-objects">3.2.13.5. Objets méthodes statiques</a></li>
<li><a class="reference internal" href="#class-method-objects">3.2.13.6. Objets méthodes de classes</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#special-method-names">3.3. Méthodes spéciales</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. Personnalisation de base</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. Personnalisation de l'accès aux attributs</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. Personnalisation de l'accès aux attributs d'un module</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. Implémentation de descripteurs</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. Invocation des descripteurs</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. créneaux prédéfinis (<code class="docutils literal notranslate"><span class="pre">__slots__</span></code>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. Personnalisation de la création de classes</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. Métaclasses</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. Résolution des entrées MRO</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. Détermination de la métaclasse appropriée</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. Préparation de l'espace de nommage de la classe</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. Exécution du corps de la classe</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. Création de l'objet classe</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. Cas d'utilisations des métaclasses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. Personnalisation des instances et vérification des sous-classes</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. Émulation de types génériques</a><ul>
<li><a class="reference internal" href="#the-purpose-of-class-getitem">3.3.5.1. Intention de <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> contre <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. Émulation d'objets appelables</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. Émulation de types conteneurs</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. Émulation de types numériques</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. Gestionnaire de contexte With</a></li>
<li><a class="reference internal" href="#customizing-positional-arguments-in-class-pattern-matching">3.3.10. Arguments positionnels dans le filtrage par motif sur les classes</a></li>
<li><a class="reference internal" href="#emulating-buffer-types">3.3.11. Emulating buffer types</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.12. Recherche des méthodes spéciales</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. Coroutines</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. Objets <em>attendables</em> (<em>awaitable</em>)</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. Objets coroutines</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. Itérateurs asynchrones</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. Gestionnaires de contexte asynchrones</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="lexical_analysis.html"
                          title="Chapitre précédent"><span class="section-number">2. </span>Analyse lexicale</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="Chapitre suivant"><span class="section-number">4. </span>Modèle d'exécution</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/datamodel.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modèle d&#39;exécution"
             >suivant</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. Analyse lexicale"
             >précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La référence du langage Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Modèle de données</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Mis à jour le oct. 26, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Créé en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>