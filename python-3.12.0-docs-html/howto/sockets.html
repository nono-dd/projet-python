
<!DOCTYPE html>

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="Guide pratique : programmation avec les sockets" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/howto/sockets.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Auteur, Gordon McMillan,. Résumé: Les connecteurs ( sockets, en anglais) sont utilisés presque partout, mais ils sont l'une des technologies les plus méconnues. En voici un aperçu très général. Ce ..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Auteur, Gordon McMillan,. Résumé: Les connecteurs ( sockets, en anglais) sont utilisés presque partout, mais ils sont l'une des technologies les plus méconnues. En voici un aperçu très général. Ce ..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Guide pratique : programmation avec les sockets &#8212; Documentation Python 3.12.0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=b37c26da2f7529d09fe70b41c4b2133fe4931a90" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Recherchez dans Documentation Python 3.12.0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="À propos de ces documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Guide pour le tri" href="sorting.html" />
    <link rel="prev" title="Guide des expressions régulières" href="regex.html" />
    <link rel="canonical" href="https://docs.python.org/3/howto/sockets.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" />
                <input type="submit" value="Go"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#">Guide pratique : programmation avec les <em>sockets</em></a><ul>
<li><a class="reference internal" href="#sockets">Connecteurs (<em>sockets</em>)</a><ul>
<li><a class="reference internal" href="#history">Historique</a></li>
</ul>
</li>
<li><a class="reference internal" href="#creating-a-socket">Création d'un connecteur</a><ul>
<li><a class="reference internal" href="#ipc"><em>IPC</em> (Communication Entre Processus)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-a-socket">Utilisation d'un connecteur</a><ul>
<li><a class="reference internal" href="#binary-data">Données binaires</a></li>
</ul>
</li>
<li><a class="reference internal" href="#disconnecting">Déconnexion</a><ul>
<li><a class="reference internal" href="#when-sockets-die">Quand les connecteurs meurent</a></li>
</ul>
</li>
<li><a class="reference internal" href="#non-blocking-sockets">Connecteurs non bloquants</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="regex.html"
                          title="Chapitre précédent">Guide des expressions régulières</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="sorting.html"
                          title="Chapitre suivant">Guide pour le tri</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/howto/sockets.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="sorting.html" title="Guide pour le tri"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="regex.html" title="Guide des expressions régulières"
             accesskey="P">précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Les HOWTOs de Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Guide pratique : programmation avec les <em>sockets</em></a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="socket-programming-howto">
<span id="socket-howto"></span><h1>Guide pratique : programmation avec les <em>sockets</em><a class="headerlink" href="#socket-programming-howto" title="Lien permanent vers ce titre">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Auteur</dt>
<dd class="field-odd"><p>Gordon McMillan</p>
</dd>
</dl>
<div class="topic">
<p class="topic-title">Résumé</p>
<p>Les connecteurs (<em>sockets</em>, en anglais) sont utilisés presque partout, mais ils sont l'une des technologies les plus méconnues. En voici un aperçu très général. Ce n'est pas vraiment un tutoriel — vous aurez encore du travail à faire pour avoir un résultat opérationnel. Il ne couvre pas les détails (et il y en a beaucoup), mais j'espère qu'il vous donnera suffisamment d'informations pour commencer à les utiliser correctement.</p>
</div>
<section id="sockets">
<h2>Connecteurs (<em>sockets</em>)<a class="headerlink" href="#sockets" title="Lien permanent vers ce titre">¶</a></h2>
<p>Je ne parlerai que des connecteurs <em>INET</em> (c'est-à-dire IPv4), mais ils représentent au moins 99 % des connecteurs utilisés. Et je ne parlerai que des connecteurs <em>STREAM</em> (c.-à-d. <em>TCP</em>) — à moins que vous ne sachiez vraiment ce que vous faites (auquel cas ce guide n'est pas pour vous), vous obtiendrez un meilleur comportement et de meilleures performances avec un connecteur <em>STREAM</em> qu'avec n'importe quel autre. Je vais essayer d'éclaircir le mystère de ce qu'est un connecteur, ainsi que quelques conseils sur la façon de travailler avec des connecteurs bloquants et non bloquants. Mais je commencerai par parler des connecteurs bloquants. Vous devez savoir comment ils fonctionnent avant de vous intéresser aux connecteurs non bloquants.</p>
<p>Une partie de la difficulté à comprendre ces choses est que « connecteur » peut désigner plusieurs choses très légèrement différentes, selon le contexte. Faisons donc d'abord une distinction entre un connecteur « client » — point final d'une conversation — et un connecteur « serveur », qui ressemble davantage à un standardiste. L'application cliente (votre navigateur par exemple) utilise exclusivement des connecteurs « client » ; le serveur web avec lequel elle parle utilise à la fois des connecteurs « serveur » et des connecteurs « client ».</p>
<section id="history">
<h3>Historique<a class="headerlink" href="#history" title="Lien permanent vers ce titre">¶</a></h3>
<p>Parmi les différentes formes d’<abbr title="Inter Process Communication">IPC</abbr>, les connecteurs sont de loin les plus populaires. Sur une plate-forme donnée, il est probable que d'autres formes d'<em>IPC</em> soient plus rapides, mais pour la communication entre plates-formes, les connecteurs sont à peu près la seule solution valable.</p>
<p>Ils ont été inventés à Berkeley dans le cadre de la déclinaison <em>BSD</em> d'Unix. Ils se sont répandus comme une traînée de poudre avec Internet. Et pour cause : la combinaison des connecteurs avec <em>INET</em> rend le dialogue avec n’importe quelle machine dans le monde entier incroyablement facile (du moins par rapport à d'autres systèmes).</p>
</section>
</section>
<section id="creating-a-socket">
<h2>Création d'un connecteur<a class="headerlink" href="#creating-a-socket" title="Lien permanent vers ce titre">¶</a></h2>
<p>Grosso modo, lorsque vous avez cliqué sur le lien qui vous a amené à cette page, votre navigateur a fait quelque chose comme ceci :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># create an INET, STREAMing socket</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="c1"># now connect to the web server on port 80 - the normal http port</span>
<span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s2">&quot;www.python.org&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
</pre></div>
</div>
<p>Lorsque l’appel à <code class="docutils literal notranslate"><span class="pre">connect</span></code> est terminé, le connecteur <code class="docutils literal notranslate"><span class="pre">s</span></code> peut être utilisé pour envoyer une requête demandant le texte de la page. Le même connecteur lira la réponse, puis sera mis au rebut. C'est exact, mis au rebut. Les connecteurs clients ne sont normalement utilisés que pour un seul échange (ou un petit ensemble d'échanges séquentiels).</p>
<p>Ce qui se passe dans le serveur web est un peu plus complexe. Tout d'abord, le serveur web crée un « connecteur serveur » :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># create an INET, STREAMing socket</span>
<span class="n">serversocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="c1"># bind the socket to a public host, and a well-known port</span>
<span class="n">serversocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">(),</span> <span class="mi">80</span><span class="p">))</span>
<span class="c1"># become a server socket</span>
<span class="n">serversocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Quelques remarques : nous avons utilisé <code class="docutils literal notranslate"><span class="pre">socket.gethostname()</span></code> pour que le connecteur soit visible par le monde extérieur.  Si nous avions utilisé <code class="docutils literal notranslate"><span class="pre">s.bind(('localhost',</span> <span class="pre">80))</span></code> ou <code class="docutils literal notranslate"><span class="pre">s.bind(('127.0.0.1',</span> <span class="pre">80))</span></code>, nous aurions toujours un connecteur « serveur », mais qui ne serait visible qu'à l'intérieur de la même machine. <code class="docutils literal notranslate"><span class="pre">s.bind(('',</span> <span class="pre">80))</span></code> précise que le connecteur est accessible par n'importe quelle adresse que la machine possède.</p>
<p>Une deuxième chose à noter : les ports dont le numéro est petit sont généralement réservés aux services « bien connus » (HTTP, SNMP, etc.). Si vous expérimentez, utilisez un nombre suffisamment élevé (4 chiffres).</p>
<p>Enfin, l'argument passé à <code class="docutils literal notranslate"><span class="pre">listen</span></code> indique à la bibliothèque de connecteurs que nous voulons mettre en file d'attente jusqu'à 5 requêtes de connexion (le maximum normal) avant de refuser les connexions externes. Si le reste du code est écrit correctement, cela devrait suffire.</p>
<p>Maintenant que nous avons un connecteur « serveur », en écoute sur le port 80, nous pouvons entrer dans la boucle principale du serveur web :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="c1"># accept connections from outside</span>
    <span class="p">(</span><span class="n">clientsocket</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="o">=</span> <span class="n">serversocket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="c1"># now do something with the clientsocket</span>
    <span class="c1"># in this case, we&#39;ll pretend this is a threaded server</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">client_thread</span><span class="p">(</span><span class="n">clientsocket</span><span class="p">)</span>
    <span class="n">ct</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>Il y a en fait trois façons générales de faire fonctionner cette boucle : mobiliser un fil d'exécution pour gérer les <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code>s, créer un nouveau processus pour gérer les <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code>s, ou restructurer cette application pour utiliser des connecteurs non bloquants, et multiplexer entre notre connecteur « serveur » et n'importe quel <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code> actif en utilisant <code class="docutils literal notranslate"><span class="pre">select</span></code>. Plus d'informations à ce sujet plus tard. La chose importante à comprendre maintenant est la suivante : c'est <em>tout</em> ce que fait un connecteur « serveur ». Il n'envoie aucune donnée. Il ne reçoit aucune donnée. Il ne fait que produire des connecteurs « clients ». Chaque <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code> est créé en réponse à un <em>autre</em> connecteur « client » qui se connecte à l'hôte et au port auxquels nous sommes liés. Dès que nous avons créé ce <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code>, nous retournons à l'écoute pour d'autres connexions. Les deux « clients » sont libres de discuter — ils utilisent un port alloué dynamiquement qui sera recyclé à la fin de la conversation.</p>
<section id="ipc">
<h3><em>IPC</em> (Communication Entre Processus)<a class="headerlink" href="#ipc" title="Lien permanent vers ce titre">¶</a></h3>
<p>Si vous avez besoin d'une communication rapide entre deux processus sur une même machine, vous devriez regarder comment utiliser les tubes (<em>pipe</em>, en anglais) ou la mémoire partagée. Si vous décidez d'utiliser les connecteurs <em>AF_INET</em>, liez le connecteur « serveur » à <code class="docutils literal notranslate"><span class="pre">'localhost'</span></code>. Sur la plupart des plates-formes, cela contourne quelques couches réseau et est un peu plus rapide.</p>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p>Le <a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> intègre de l’IPC multiplateformes dans une API de plus haut niveau.</p>
</div>
</section>
</section>
<section id="using-a-socket">
<h2>Utilisation d'un connecteur<a class="headerlink" href="#using-a-socket" title="Lien permanent vers ce titre">¶</a></h2>
<p>La première chose à noter, c'est que la prise « client » du navigateur web et la prise « client » du serveur web sont des bêtes identiques. C'est-à-dire qu'il s'agit d'une conversation « pair à pair ». Ou pour le dire autrement, <em>en tant que concepteur, vous devrez décider quelles sont les règles d'étiquette pour une conversation</em>. Normalement, la connexion via <code class="docutils literal notranslate"><span class="pre">connect</span></code> lance la conversation en envoyant une demande, ou peut-être un signe. Mais c'est une décision de conception — ce n'est pas une règle des connecteurs.</p>
<p>Il y a maintenant deux ensembles de verbes à utiliser pour la communication. Vous pouvez utiliser <code class="docutils literal notranslate"><span class="pre">send</span></code> et <code class="docutils literal notranslate"><span class="pre">recv</span></code>, ou vous pouvez transformer votre connecteur client en une bête imitant un fichier et utiliser <code class="docutils literal notranslate"><span class="pre">read</span></code> et <code class="docutils literal notranslate"><span class="pre">write</span></code>. C'est la façon dont Java présente ses connecteurs. Je ne vais pas en parler ici, sauf pour vous avertir que vous devez utiliser <code class="docutils literal notranslate"><span class="pre">flush</span></code> sur les connecteurs. Ce sont des « fichiers », mis en mémoire tampon, et une erreur courante est d'« écrire » via <code class="docutils literal notranslate"><span class="pre">write</span></code> quelque chose, puis de « lire » via <code class="docutils literal notranslate"><span class="pre">read</span></code> pour obtenir une réponse. Sans un <code class="docutils literal notranslate"><span class="pre">flush</span></code>, vous pouvez attendre la réponse pour toujours, parce que la requête peut encore être dans votre mémoire tampon de sortie.</p>
<p>Nous arrivons maintenant au principal écueil des connecteurs — <code class="docutils literal notranslate"><span class="pre">send</span></code> et <code class="docutils literal notranslate"><span class="pre">recv</span></code> fonctionnent sur les mémoires tampons du réseau. Ils ne traitent pas nécessairement tous les octets que vous leur passez (ou que vous attendez d'eux), car leur principal objectif est de gérer les tampons réseau. En général, leur exécution se termine lorsque les tampons réseau associés ont été remplis (<code class="docutils literal notranslate"><span class="pre">send</span></code>) ou vidés (<code class="docutils literal notranslate"><span class="pre">recv</span></code>). Ils vous indiquent alors combien d'octets ils ont traité. Il est de <em>votre</em> responsabilité de les rappeler jusqu'à ce que votre message ait été complètement traité.</p>
<p>Lorsqu'un <code class="docutils literal notranslate"><span class="pre">recv</span></code> renvoie 0 octet, cela signifie que l'autre partie a fermé (ou est en train de fermer) la connexion. Vous ne recevrez plus de données sur cette connexion. Jamais. Vous pouvez peut-être envoyer des données avec succès. J’en parlerai plus tard.</p>
<p>Un protocole comme HTTP utilise un connecteur pour un seul transfert. Le client envoie une demande, puis lit une réponse. C'est tout. Le connecteur est mis au rebut. Cela signifie qu'un client peut détecter la fin de la réponse en recevant 0 octet.</p>
<p>Mais si vous prévoyez de réutiliser votre connecteur pour d'autres transferts, vous devez réaliser qu'<em>il n'y a pas</em> d'<abbr title="End of Transfer">EOT</abbr> <em>sur un connecteur</em>. Je répète : si un appel à <code class="docutils literal notranslate"><span class="pre">send</span></code> ou <code class="docutils literal notranslate"><span class="pre">recv</span></code> se termine après avoir traité 0 octet, la connexion a été interrompue. Si la connexion n'a <em>pas</em> été interrompue, vous pouvez attendre sur un <code class="docutils literal notranslate"><span class="pre">recv</span></code> pour toujours, car le connecteur ne vous dira pas qu'il n'y a plus rien à lire (pour le moment). Maintenant, si vous y réfléchissez un peu, vous allez vous rendre compte d'une vérité fondamentale sur les connecteurs : <em>les messages doivent être de longueur fixe</em> (beurk), <em>ou être délimités</em> (bof), <em>ou indiquer de quelle longueur ils sont</em> (beaucoup mieux), <em>ou terminer en coupant la connexion</em>. Le choix est entièrement de votre côté (mais certaines façons sont meilleurs que d'autres).</p>
<p>En supposant que vous ne vouliez pas terminer la connexion, la solution la plus simple est un message de longueur fixe :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MySocket</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;demonstration class only</span>
<span class="sd">      - coded for clarity, not efficiency</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span>
                            <span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">mysend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="n">totalsent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">totalsent</span> <span class="o">&lt;</span> <span class="n">MSGLEN</span><span class="p">:</span>
            <span class="n">sent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="n">totalsent</span><span class="p">:])</span>
            <span class="k">if</span> <span class="n">sent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;socket connection broken&quot;</span><span class="p">)</span>
            <span class="n">totalsent</span> <span class="o">=</span> <span class="n">totalsent</span> <span class="o">+</span> <span class="n">sent</span>

    <span class="k">def</span> <span class="nf">myreceive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bytes_recd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">bytes_recd</span> <span class="o">&lt;</span> <span class="n">MSGLEN</span><span class="p">:</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">MSGLEN</span> <span class="o">-</span> <span class="n">bytes_recd</span><span class="p">,</span> <span class="mi">2048</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">chunk</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;socket connection broken&quot;</span><span class="p">)</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
            <span class="n">bytes_recd</span> <span class="o">=</span> <span class="n">bytes_recd</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
</pre></div>
</div>
<p>Le code d'envoi ici est utilisable pour presque tous les systèmes de messagerie — en Python, vous envoyez des chaînes de caractères, et vous pouvez utiliser <code class="docutils literal notranslate"><span class="pre">len()</span></code> pour en déterminer la longueur (même si elle contient des caractères <code class="docutils literal notranslate"><span class="pre">\0</span></code>). C'est surtout le code de réception qui devient plus complexe. (Et en C, ce n'est pas bien pire, sauf que vous ne pouvez pas utiliser <code class="docutils literal notranslate"><span class="pre">strlen</span></code> si le message contient des <code class="docutils literal notranslate"><span class="pre">\0</span></code>s).</p>
<p>Le plus simple est de faire du premier caractère du message un indicateur du type de message, et de faire en sorte que le type détermine la longueur. Vous avez maintenant deux <code class="docutils literal notranslate"><span class="pre">recv</span></code>s — le premier pour obtenir (au moins) ce premier caractère afin de pouvoir déterminer la longueur, et le second dans une boucle pour obtenir le reste. Si vous décidez de suivre la route délimitée, vous recevrez un morceau de taille arbitraire (4096 ou 8192 est fréquemment une bonne valeur pour correspondre à la taille de la mémoire tampon du réseau), et vous analyserez ce que vous avez reçu pour trouver un délimiteur.</p>
<p>Une subtilité dont il faut être conscient : si votre protocole de conversation permet de renvoyer plusieurs messages les uns à la suite des autres (sans aucune sorte de réponse), et que vous passez à <code class="docutils literal notranslate"><span class="pre">recv</span></code> une taille de morceau arbitraire, vous pouvez en arriver à lire le début du message suivant. Vous devrez alors le mettre de côté et le conserver, jusqu'à ce que vous en ayez besoin.</p>
<p>Préfixer le message avec sa longueur (disons, sous la forme de 5 caractères numériques) devient plus complexe, parce que (croyez-le ou non), vous pouvez ne pas recevoir les 5 caractères en un seul <code class="docutils literal notranslate"><span class="pre">recv</span></code>. Pour une utilisation triviale, vous vous en tirerez à bon compte ; mais en cas de forte charge réseau, votre code se cassera très rapidement, à moins que vous n’utilisiez deux boucles <code class="docutils literal notranslate"><span class="pre">recv</span></code> — la première pour déterminer la longueur, la deuxième pour obtenir la partie « données » du message. Vilain. C’est aussi à ce moment que vous découvrirez que « l’envoi » via <code class="docutils literal notranslate"><span class="pre">send</span></code> ne parvient pas toujours à tout évacuer en un seul passage. Et bien que vous ayez lu cet avertissement, vous finirez par vous faire avoir par cette subtilité !</p>
<p>Pour garder une longueur raisonnable à cette page, pour forger votre caractère (et afin de garder l’avantage concurrentiel que j’ai sur vous), ces améliorations ne seront pas abordées et sont laissées en exercice au lecteur. Passons maintenant au nettoyage.</p>
<section id="binary-data">
<h3>Données binaires<a class="headerlink" href="#binary-data" title="Lien permanent vers ce titre">¶</a></h3>
<p>Il est parfaitement possible d'envoyer des données binaires par l'intermédiaire d'un connecteur. Le problème majeur est que toutes les machines n'utilisent pas les mêmes formats pour les données binaires. Par exemple, l’<a class="reference external" href="https://fr.wikipedia.org/wiki/Boutisme#Dans_les_communications">ordre des octets du réseau</a> est gros-boutiste, avec l'octet le plus significatif en premier, de sorte qu'un entier de 16 bits avec la valeur <code class="docutils literal notranslate"><span class="pre">1</span></code> serait les deux octets hexadécimaux <code class="docutils literal notranslate"><span class="pre">00</span> <span class="pre">01</span></code>. Cependant, la plupart des processeurs courants (x86/AMD64, ARM, RISC-V) sont petit-boutistes, avec l'octet le moins significatif en premier - ce même <code class="docutils literal notranslate"><span class="pre">1</span></code> serait <code class="docutils literal notranslate"><span class="pre">01</span> <span class="pre">00</span></code>.</p>
<p>Les bibliothèques de sockets ont des appels pour convertir les entiers 16 et 32 bits - <code class="docutils literal notranslate"><span class="pre">ntohl,</span> <span class="pre">htonl,</span> <span class="pre">ntohs,</span> <span class="pre">htons</span></code> où « n » signifie <em>network</em> (réseau) et « h » signifie <em>host</em> (hôte), « s » signifie <em>short</em> (court) et « l » signifie <em>long</em>. Lorsque l’ordre du réseau est l’ordre de l’hôte, ils ne font rien, mais lorsque la machine fonctionne en ordre inversé, ils échangent les octets de manière appropriée.</p>
<p>De nos jours, avec les machines 64 bits, la représentation <em>ASCII</em> des données binaires est souvent plus compacte que la représentation binaire. C’est parce que dans un nombre surprenant de cas, tous ces <em>entiers</em> ont la valeur 0 et parfois 1. La chaîne « 0 » serait codée sur deux octets, alors qu'elle le serait sur 8 en tant que binaire 64 bits. Bien sûr, cela ne fonctionne pas très bien avec les messages de longueur fixe. C’est une affaire de choix.</p>
</section>
</section>
<section id="disconnecting">
<h2>Déconnexion<a class="headerlink" href="#disconnecting" title="Lien permanent vers ce titre">¶</a></h2>
<p>À proprement parler, vous êtes censé utiliser <code class="docutils literal notranslate"><span class="pre">shutdown</span></code> sur un connecteur pour l’arrêter avant de le fermer via <code class="docutils literal notranslate"><span class="pre">close</span></code>. Le <code class="docutils literal notranslate"><span class="pre">shutdown</span></code> est un avertissement au connecteur de l’autre côté. Selon l’argument que vous lui passez, cela peut signifier « Je ne vais plus envoyer, mais je vais quand même écouter », ou « Je n’écoute pas, bon débarras ! ». La plupart des bibliothèques de connecteurs, cependant, sont tellement habituées à ce que les programmeurs négligent d’utiliser ce morceau d’étiquette que normalement un <code class="docutils literal notranslate"><span class="pre">close</span></code> est équivalent à <code class="docutils literal notranslate"><span class="pre">shutdown()</span> <span class="pre">;</span> <span class="pre">close()</span></code>. Ainsi, dans la plupart des situations, un <code class="docutils literal notranslate"><span class="pre">shutdown</span></code> explicite n’est pas nécessaire.</p>
<p>Une façon d’utiliser efficacement le <code class="docutils literal notranslate"><span class="pre">shutdown</span></code> est d’utiliser un échange de type HTTP. Le client envoie une requête et effectue ensuite un <code class="docutils literal notranslate"><span class="pre">shutdown(1)</span></code>. Cela indique au serveur que « ce client a fini d’envoyer, mais peut encore recevoir ». Le serveur peut détecter <em>EOF</em> par une réception de 0 octet. Il peut supposer qu’il a la requête complète. Le serveur envoie une réponse. Si le <code class="docutils literal notranslate"><span class="pre">send</span></code> se termine avec succès, alors, en effet, le client était encore en train de recevoir.</p>
<p>Python pousse l’arrêt automatique un peu plus loin, et dit que lorsqu’un connecteur est collecté par le ramasse-miette, il effectue automatiquement une fermeture via <code class="docutils literal notranslate"><span class="pre">close</span></code> si elle est nécessaire. Mais c’est une très mauvaise habitude de s’appuyer sur ce système. Si votre connecteur disparaît sans avoir fait un <code class="docutils literal notranslate"><span class="pre">close</span></code>, le connecteur à l’autre bout peut rester suspendu indéfiniment, pensant que vous êtes juste lent. Fermez vos connecteurs quand vous avez terminé <em>s’il vous plaît</em>.</p>
<section id="when-sockets-die">
<h3>Quand les connecteurs meurent<a class="headerlink" href="#when-sockets-die" title="Lien permanent vers ce titre">¶</a></h3>
<p>Le pire dans l'utilisation de connecteurs bloquants est probablement ce qui se passe lorsque l'autre côté s'interrompt brutalement (sans faire de fermeture via <code class="docutils literal notranslate"><span class="pre">close</span></code>). Votre connecteur risque d’attendre infiniment. TCP est un protocole fiable, et il attendra très, très longtemps avant d'abandonner une connexion. Si vous utilisez des fils d’exécution, le fil entier est pratiquement mort. Il n'y a pas grand-chose que vous puissiez faire à ce sujet. Du moment que vous ne faites rien de stupide, comme tenir un verrou verrouillé pendant une lecture bloquante, le fil ne consomme pas vraiment beaucoup de ressources. N'essayez <em>pas</em> de tuer le fil — si les fils sont plus efficients que les processus, c'est en partie parce qu'ils évitent les coûts significatifs liés au recyclage automatique des ressources. En d'autres termes, si vous parvenez à tuer le fil, tout votre processus risque d'être foutu.</p>
</section>
</section>
<section id="non-blocking-sockets">
<h2>Connecteurs non bloquants<a class="headerlink" href="#non-blocking-sockets" title="Lien permanent vers ce titre">¶</a></h2>
<p>Si vous avez compris ce qui précède, vous savez déjà tout ce que vous devez savoir sur la mécanique de l’utilisation des connecteurs. Vous utiliserez toujours les mêmes appels, de la même façon. Il n’y que ça. Si vous le faites bien, c’est presque dans la poche.</p>
<p>En Python, vous utilisez <code class="docutils literal notranslate"><span class="pre">socket.setblocking(0)</span></code> pour rendre non-bloquant. En C, c’est plus complexe (pour commencer, vous devez choisir entre la version BSD <code class="docutils literal notranslate"><span class="pre">O_NONBLOCK</span></code> et la version POSIX presque impossible à distinguer <code class="docutils literal notranslate"><span class="pre">O_NDELAY</span></code>, qui est complètement différente de <code class="docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code>), mais c’est exactement la même idée. Vous le faites après avoir créé le connecteur mais avant de l’utiliser (en fait, si vous êtes fou, vous pouvez alterner).</p>
<p>La différence majeure de fonctionnement est que <code class="docutils literal notranslate"><span class="pre">send</span></code>, <code class="docutils literal notranslate"><span class="pre">recv</span></code>, <code class="docutils literal notranslate"><span class="pre">connect</span></code> et <code class="docutils literal notranslate"><span class="pre">accept</span></code> peuvent rendre la main sans avoir rien fait. Vous avez (bien sûr) un certain nombre de choix. Vous pouvez vérifier le code de retour et les codes d'erreur et, en général, devenir fou. Si vous ne me croyez pas, essayez un jour. Votre application va grossir, boguer et vampiriser le processeur. Alors, évitons les solutions vouées à l’échec dès le départ et faisons les choses correctement.</p>
<p>Utilisation de <code class="docutils literal notranslate"><span class="pre">select</span></code>.</p>
<p>En C, implémenter <code class="docutils literal notranslate"><span class="pre">select</span></code> est assez complexe. En Python, c'est du gâteau, mais c'est assez proche de la version C ; aussi, si vous comprenez <code class="docutils literal notranslate"><span class="pre">select</span></code> en Python, vous aurez peu de problèmes en C :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ready_to_read</span><span class="p">,</span> <span class="n">ready_to_write</span><span class="p">,</span> <span class="n">in_error</span> <span class="o">=</span> \
               <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                  <span class="n">potential_readers</span><span class="p">,</span>
                  <span class="n">potential_writers</span><span class="p">,</span>
                  <span class="n">potential_errs</span><span class="p">,</span>
                  <span class="n">timeout</span><span class="p">)</span>
</pre></div>
</div>
<p>Vous passez à <code class="docutils literal notranslate"><span class="pre">select</span></code> trois listes : la première contient tous les connecteurs dont vous souhaiter lire le contenu ; la deuxième tous les connecteurs sur lesquels vous voudriez écrire, et la dernière (normalement laissée vide) ceux sur lesquels vous voudriez vérifier s’il y a des erreurs. Prenez note qu'un connecteur peut figurer dans plus d'une liste. L'appel à <code class="docutils literal notranslate"><span class="pre">select</span></code> est bloquant, mais vous pouvez lui donner un délai d'attente. C'est généralement une bonne chose à faire — donnez-lui un bon gros délai d'attente (disons une minute), à moins que vous n'ayez une bonne raison de ne pas le faire.</p>
<p>En retour, vous recevrez trois listes. Elles contiennent les connecteurs qui sont réellement lisibles, inscriptibles et en erreur. Chacune de ces listes est un sous-ensemble (éventuellement vide) de la liste correspondante que vous avez transmise.</p>
<p>Si un connecteur se trouve dans la liste renvoyée des connecteurs lisibles, vous pouvez être pratiquement certain qu'un <code class="docutils literal notranslate"><span class="pre">recv</span></code> sur ce connecteur renvoie <em>quelque chose</em>. Même chose pour la liste renvoyée des connecteurs inscriptibles. Vous pourrez envoyer <em>quelque chose</em>. Peut-être pas tout ce que vous voudrez, mais <em>quelque chose</em> est mieux que rien (en fait, n'importe quel connecteur raisonnablement sain sera présent dans la liste des connecteurs inscriptibles — cela signifie simplement que l'espace tampon réseau sortant est disponible).</p>
<p>Si vous avez un connecteur « serveur », mettez-le dans la liste des connecteurs potentiellement lisibles <code class="docutils literal notranslate"><span class="pre">potential_readers</span></code>. S’il apparaît dans la liste renvoyée des connecteurs que vous pouvez lire, votre <code class="docutils literal notranslate"><span class="pre">accept</span></code> fonctionnera (presque certainement). Si vous avez créé un nouveau connecteur pour se connecter via <code class="docutils literal notranslate"><span class="pre">connect</span></code> à quelqu'un d'autre, mettez-le dans la liste des connecteurs potentiellement inscriptibles. S’il apparaît dans la liste renvoyée des connecteurs sur lesquels vous pouvez écrire, vous avez une bonne chance qu'il se soit connecté.</p>
<p>En fait, <code class="docutils literal notranslate"><span class="pre">select</span></code> peut être pratique même avec des connecteurs bloquants. C'est une façon de déterminer si vous allez bloquer — le connecteur est renvoyé comme lisible lorsqu'il y a quelque chose dans les mémoires tampons. Cependant, cela n'aide pas encore à déterminer si l'autre extrémité a terminé, ou si elle est simplement occupée par autre chose.</p>
<p><strong>Alerte de portabilité</strong> : Sous Unix, <code class="docutils literal notranslate"><span class="pre">select</span></code> fonctionne aussi bien avec les connecteurs qu'avec les fichiers. N'essayez pas cela sous Windows. Sous Windows, <code class="docutils literal notranslate"><span class="pre">select</span></code> ne fonctionne qu'avec les connecteurs. Notez également qu'en C, la plupart des options de connecteurs les plus avancées se font différemment sous Windows. En fait, sous Windows, j'utilise habituellement des fils d'exécution (qui fonctionnent très, très bien) avec mes connecteurs.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#">Guide pratique : programmation avec les <em>sockets</em></a><ul>
<li><a class="reference internal" href="#sockets">Connecteurs (<em>sockets</em>)</a><ul>
<li><a class="reference internal" href="#history">Historique</a></li>
</ul>
</li>
<li><a class="reference internal" href="#creating-a-socket">Création d'un connecteur</a><ul>
<li><a class="reference internal" href="#ipc"><em>IPC</em> (Communication Entre Processus)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-a-socket">Utilisation d'un connecteur</a><ul>
<li><a class="reference internal" href="#binary-data">Données binaires</a></li>
</ul>
</li>
<li><a class="reference internal" href="#disconnecting">Déconnexion</a><ul>
<li><a class="reference internal" href="#when-sockets-die">Quand les connecteurs meurent</a></li>
</ul>
</li>
<li><a class="reference internal" href="#non-blocking-sockets">Connecteurs non bloquants</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="regex.html"
                          title="Chapitre précédent">Guide des expressions régulières</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="sorting.html"
                          title="Chapitre suivant">Guide pour le tri</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/howto/sockets.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="sorting.html" title="Guide pour le tri"
             >suivant</a> |</li>
        <li class="right" >
          <a href="regex.html" title="Guide des expressions régulières"
             >précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Les HOWTOs de Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Guide pratique : programmation avec les <em>sockets</em></a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Mis à jour le oct. 26, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Créé en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>