
<!DOCTYPE html>

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="unittest — Framework de tests unitaires" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/unittest.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Code source : Lib/unittest/__init__.py(Si vous êtes déjà familier des concepts de base concernant les tests, vous pouvez souhaiter passer à la liste des méthodes.) Le cadre applicatif de tests unit..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Code source : Lib/unittest/__init__.py(Si vous êtes déjà familier des concepts de base concernant les tests, vous pouvez souhaiter passer à la liste des méthodes.) Le cadre applicatif de tests unit..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>unittest — Framework de tests unitaires &#8212; Documentation Python 3.12.0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=b37c26da2f7529d09fe70b41c4b2133fe4931a90" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Recherchez dans Documentation Python 3.12.0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="À propos de ces documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="unittest.mock — Bibliothèque d&#39;objets simulacres" href="unittest.mock.html" />
    <link rel="prev" title="doctest — Exemples de tests interactifs en Python" href="doctest.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/unittest.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" />
                <input type="submit" value="Go"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> — <em>Framework</em> de tests unitaires</a><ul>
<li><a class="reference internal" href="#basic-example">Exemple basique</a></li>
<li><a class="reference internal" href="#command-line-interface">Interface en ligne de commande</a><ul>
<li><a class="reference internal" href="#command-line-options">Options de la ligne de commande</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-discovery">Découverte des tests</a></li>
<li><a class="reference internal" href="#organizing-test-code">Organiser le code de test</a></li>
<li><a class="reference internal" href="#re-using-old-test-code">Réutilisation d'ancien code de test</a></li>
<li><a class="reference internal" href="#skipping-tests-and-expected-failures">Ignorer des tests et des erreurs prévisibles</a></li>
<li><a class="reference internal" href="#distinguishing-test-iterations-using-subtests">Distinguer les itérations de test à l'aide de sous-tests</a></li>
<li><a class="reference internal" href="#classes-and-functions">Classes et fonctions</a><ul>
<li><a class="reference internal" href="#test-cases">Scénarios de tests</a></li>
<li><a class="reference internal" href="#grouping-tests">Regroupement des tests</a></li>
<li><a class="reference internal" href="#loading-and-running-tests">Chargement et exécution des tests</a><ul>
<li><a class="reference internal" href="#load-tests-protocol">Protocole de chargement des tests (<em>load_tests Protocol</em>)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#class-and-module-fixtures">Classes et modules d'aménagements des tests</a><ul>
<li><a class="reference internal" href="#setupclass-and-teardownclass">Classes de mise en place (<em>setUpClass</em>) et de démantèlement des tests (<em>tearDownClass</em>)</a></li>
<li><a class="reference internal" href="#setupmodule-and-teardownmodule">Module de mise en place (<em>setUpModule</em>) et de démantèlement des tests (<em>tearDownModule</em>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#signal-handling">Traitement des signaux</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="doctest.html"
                          title="Chapitre précédent"><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code> — Exemples de tests interactifs en Python</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="unittest.mock.html"
                          title="Chapitre suivant"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.mock</span></code> — Bibliothèque d'objets simulacres</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/unittest.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="unittest.mock.html" title="unittest.mock — Bibliothèque d&#39;objets simulacres"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="doctest — Exemples de tests interactifs en Python"
             accesskey="P">précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La bibliothèque standard</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">Outils de développement</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> — <em>Framework</em> de tests unitaires</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-unittest">
<span id="unittest-unit-testing-framework"></span><h1><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> — <em>Framework</em> de tests unitaires<a class="headerlink" href="#module-unittest" title="Lien permanent vers ce titre">¶</a></h1>
<p><strong>Code source :</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/unittest/__init__.py">Lib/unittest/__init__.py</a></p>
<hr class="docutils" />
<p>(Si vous êtes déjà familier des concepts de base concernant les tests, vous pouvez souhaiter passer à <a class="reference internal" href="#assert-methods"><span class="std std-ref">la liste des méthodes</span></a>.)</p>
<p>Le cadre applicatif de tests unitaires <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> était au départ inspiré par <em>JUnit</em> et ressemble aux principaux <em>frameworks</em> de tests unitaires des autres langages. Il gère l'automatisation des tests,  le partage de code pour la mise en place et la finalisation des tests, l'agrégation de tests en collections, et l'indépendance des tests par rapport au <em>framework</em> utilisé.</p>
<p>Pour y parvenir, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> gère quelques concepts importants avec une approche orientée objet :</p>
<dl class="simple">
<dt>aménagement de test (<em>fixture</em>)</dt><dd><p>Un <em class="dfn">aménagement de test &lt;test fixture&gt;</em> (<em>fixture</em> en anglais) désigne la préparation nécessaire au déroulement d'un ou plusieurs tests, et toutes les actions de nettoyage associées. Cela peut concerner, par exemple, la création de bases de données temporaires ou mandataires, de répertoires, ou le démarrage d'un processus serveur.</p>
</dd>
<dt>scénario de test</dt><dd><p>Un <em class="dfn">scénario de test</em> est l'élément de base des tests. Il attend une réponse spécifique pour un ensemble particulier d'entrées. <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> fournit une classe de base, <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>, qui peut être utilisée pour créer de nouveaux scénarios de test.</p>
</dd>
<dt>suite de tests</dt><dd><p>Une <em class="dfn">suite de tests</em> est une collection de scénarios de test, de suites de tests ou les deux. Cela sert à regrouper les tests qui devraient être exécutés ensemble.</p>
</dd>
<dt>lanceur de tests</dt><dd><p>Un <em class="dfn">lanceur de tests</em> est un composant qui orchestre l'exécution des tests et fournit le résultat pour l'utilisateur. Le lanceur peut utiliser une interface graphique, une interface textuelle, ou renvoie une valeur spéciale pour indiquer les résultats de l'exécution des tests.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<dl class="simple">
<dt>Module <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a></dt><dd><p>Un autre module de test adoptant une approche très différente.</p>
</dd>
<dt><a class="reference external" href="https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm">Simple Smalltalk Testing: With Patterns</a></dt><dd><p>Le papier originel de Kent Beck sur les <em>frameworks</em> de test utilisant le modèle sur lequel s'appuie <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>.</p>
</dd>
<dt><a class="reference external" href="https://docs.pytest.org/">pytest</a></dt><dd><p>Des cadres applicatifs tiers de tests unitaires avec une syntaxe allégée pour l'écriture des tests. Par exemple, <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">func(10)</span> <span class="pre">==</span> <span class="pre">42</span></code>.</p>
</dd>
<dt><a class="reference external" href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">The Python Testing Tools Taxonomy</a></dt><dd><p>Une liste étendue des outils de test pour Python comprenant des <em>frameworks</em> de tests fonctionnels et des bibliothèques d'objets simulés (<em>mocks</em>).</p>
</dd>
<dt><a class="reference external" href="http://lists.idyll.org/listinfo/testing-in-python">Testing in Python Mailing List</a></dt><dd><p>Un groupe de discussion dédié aux tests, et outils de test, en Python.</p>
</dd>
</dl>
<p>The script <code class="file docutils literal notranslate"><span class="pre">Tools/unittestgui/unittestgui.py</span></code> in the Python source distribution is
a GUI tool for test discovery and execution.  This is intended largely for ease of use
for those new to unit testing.  For production environments it is
recommended that tests be driven by a continuous integration system such as
<a class="reference external" href="https://buildbot.net/">Buildbot</a>, <a class="reference external" href="https://www.jenkins.io/">Jenkins</a>,
<a class="reference external" href="https://github.com/features/actions">GitHub Actions</a>, or
<a class="reference external" href="https://www.appveyor.com/">AppVeyor</a>.</p>
</div>
<section id="basic-example">
<span id="unittest-minimal-example"></span><h2>Exemple basique<a class="headerlink" href="#basic-example" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le module <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> fournit un riche ensemble d'outils pour construire et lancer des tests. Cette section montre qu'une petite partie des outils suffit pour satisfaire les besoins de la plupart des utilisateurs.</p>
<p>Voici un court script pour tester trois méthodes de <em>string</em> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">TestStringMethods</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="s1">&#39;FOO&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_isupper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="s1">&#39;FOO&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="s1">&#39;Foo&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">test_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;hello world&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">])</span>
        <span class="c1"># check that s.split fails when the separator is not a string</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
            <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>Un scénario de test est créé comme classe-fille de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a>. Les trois tests individuels sont définis par des méthodes dont les noms commencent par les lettres <code class="docutils literal notranslate"><span class="pre">test</span></code>. Cette convention de nommage signale au lanceur de tests quelles méthodes sont des tests.</p>
<p>Le cœur de chaque test est un appel à <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> pour vérifier un résultat attendu ; <a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue()</span></code></a> ou <a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse()</span></code></a> pour vérifier une condition ; ou <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> pour vérifier qu'une exception particulière est levée. Ces méthodes sont utilisées à la place du mot-clé <a class="reference internal" href="../reference/simple_stmts.html#assert"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a>  pour que le lanceur de tests puisse récupérer les résultats de tous les tests et produire un rapport.</p>
<p>Les méthodes <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> et <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> vous autorisent à définir des instructions qui seront exécutées avant et après chaque méthode test. Elles sont davantage détaillées dans la section <a class="reference internal" href="#organizing-tests"><span class="std std-ref">Organiser le code de test</span></a>.</p>
<p>Le bloc final montre une manière simple de lancer les tests. <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> fournit une interface en ligne de commande pour le script de test. Lorsqu'il est lancé en ligne de commande, le script ci-dessus produit une sortie qui ressemble à ceci :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.000</span><span class="n">s</span>

<span class="n">OK</span>
</pre></div>
</div>
<p>Passer l'option <code class="docutils literal notranslate"><span class="pre">-v</span></code> à votre script de test informera <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> qu'il doit fournir un niveau plus important de détails, et produit la sortie suivante :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_isupper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="o">.</span><span class="n">test_isupper</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_split</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="o">.</span><span class="n">test_split</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_upper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="o">.</span><span class="n">test_upper</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.001</span><span class="n">s</span>

<span class="n">OK</span>
</pre></div>
</div>
<p>Les exemples ci-dessus montrent les fonctionnalités d'<a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> les plus communément utilisées et qui sont suffisantes pour couvrir les besoins courants en matière de test. Le reste de la documentation explore l'ensemble complet des fonctionnalités depuis les premiers principes.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>The behavior of returning a value from a test method (other than the default
<code class="docutils literal notranslate"><span class="pre">None</span></code> value), is now deprecated.</p>
</div>
</section>
<section id="command-line-interface">
<span id="unittest-command-line-interface"></span><h2>Interface en ligne de commande<a class="headerlink" href="#command-line-interface" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le module <em>unittest</em> est utilisable depuis la ligne de commande pour exécuter des tests à partir de modules, de classes ou même de méthodes de test individuelles :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module1</span> <span class="n">test_module2</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module</span><span class="o">.</span><span class="n">TestClass</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module</span><span class="o">.</span><span class="n">TestClass</span><span class="o">.</span><span class="n">test_method</span>
</pre></div>
</div>
<p>La commande accepte en argument une liste de n'importe quelle combinaison de noms de modules et de noms de classes ou de méthodes entièrement qualifiés.</p>
<p>Les modules de test peuvent également être spécifiés par un chemin de fichier :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">tests</span><span class="o">/</span><span class="n">test_something</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>Cette fonctionnalité permet d'utiliser la complétion de l'interpréteur de commandes système (<em>le shell</em>) pour spécifier le module de test. Le chemin est converti en nom de module en supprimant le <code class="docutils literal notranslate"><span class="pre">.py</span></code> et en convertissant les séparateurs de chemin en '.'. Si vous voulez exécuter un fichier test qui n'est pas importable en tant que module, exécutez directement le fichier.</p>
<p>Pour obtenir plus de détails lors de l'exécution utilisez l'option <code class="docutils literal notranslate"><span class="pre">-v</span></code> (plus de verbosité) :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="o">-</span><span class="n">v</span> <span class="n">test_module</span>
</pre></div>
</div>
<p>Quand la commande est exécutée sans arguments <a class="reference internal" href="#unittest-test-discovery"><span class="std std-ref">Découverte des tests</span></a> est lancée :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span>
</pre></div>
</div>
<p>Pour afficher la liste de toutes les options de la commande utilisez l'option <code class="docutils literal notranslate"><span class="pre">-h</span></code> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="o">-</span><span class="n">h</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.2: </span>Dans les versions antérieures, il était seulement possible d'exécuter des méthodes de test individuelles et non des modules ou des classes.</p>
</div>
<section id="command-line-options">
<h3>Options de la ligne de commande<a class="headerlink" href="#command-line-options" title="Lien permanent vers ce titre">¶</a></h3>
<p>Le programme <strong class="program">unittest</strong> gère ces options de la ligne de commande :</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-unittest-b">
<span id="cmdoption-unittest-buffer"></span><span class="sig-name descname"><span class="pre">-b</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--buffer</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-unittest-b" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Les flux de sortie et d'erreur standards sont mis en mémoire tampon pendant l'exécution des tests. L'affichage produit par un test réussi n'est pas pris en compte. Les sorties d'affichages d'un test en échec ou en erreur sont conservés et  ajoutés aux messages d'erreur.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-unittest-c">
<span id="cmdoption-unittest-catch"></span><span class="sig-name descname"><span class="pre">-c</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--catch</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-unittest-c" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Utiliser <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> pendant l'exécution des tests attend que le test en cours se termine, puis affiche tous les résultats obtenus jusqu'ici. Une seconde utilisation de <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> provoque l'exception normale <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>.</p>
<p>Voir <a class="reference internal" href="#signal-handling">Signal Handling</a> pour les fonctions qui utilisent cette fonctionnalité.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-unittest-f">
<span id="cmdoption-unittest-failfast"></span><span class="sig-name descname"><span class="pre">-f</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--failfast</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-unittest-f" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Arrête l'exécution des tests lors du premier cas d'erreur ou d'échec.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-unittest-k">
<span class="sig-name descname"><span class="pre">-k</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-unittest-k" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Only run test methods and classes that match the pattern or substring.
This option may be used multiple times, in which case all test cases that
match any of the given patterns are included.</p>
<p>Les motifs qui contiennent un caractère de remplacement (<code class="docutils literal notranslate"><span class="pre">*</span></code>) sont comparés au nom du test en utilisant <a class="reference internal" href="fnmatch.html#fnmatch.fnmatchcase" title="fnmatch.fnmatchcase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fnmatch.fnmatchcase()</span></code></a> ; sinon, une recherche simple de sous chaîne respectant la casse est faite.</p>
<p>Les motifs sont comparés au nom de la méthode de test complètement qualifiée tel qu'importé par le chargeur de test.</p>
<p>Par exemple, <code class="docutils literal notranslate"><span class="pre">-k</span> <span class="pre">machin</span></code> retient les tests <code class="docutils literal notranslate"><span class="pre">machin_tests.UnTest.test_untruc</span></code>, <code class="docutils literal notranslate"><span class="pre">truc_tests.UnTest.test_machin</span></code>, mais pas <code class="docutils literal notranslate"><span class="pre">truc_tests.MachinTest.test_untruc</span></code>.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-unittest-locals">
<span class="sig-name descname"><span class="pre">--locals</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-unittest-locals" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Affiche les variables locales dans les traces d'appels.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-unittest-durations">
<span class="sig-name descname"><span class="pre">--durations</span></span><span class="sig-prename descclassname"> <span class="pre">N</span></span><a class="headerlink" href="#cmdoption-unittest-durations" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Show the N slowest test cases (N=0 for all).</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2: </span>Les options de ligne de commande <code class="docutils literal notranslate"><span class="pre">-b</span></code>, <code class="docutils literal notranslate"><span class="pre">-c</span></code> et <code class="docutils literal notranslate"><span class="pre">-f</span></code> ont été ajoutées.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.5: </span>Ajout de l'option de ligne de commande <code class="docutils literal notranslate"><span class="pre">--locals</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7: </span>Ajout de l'option de ligne de commande <code class="docutils literal notranslate"><span class="pre">-k</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.12: </span>The command-line option <code class="docutils literal notranslate"><span class="pre">--durations</span></code>.</p>
</div>
<p>La ligne de commande peut également être utilisée pour découvrir les tests, pour exécuter tous les tests dans un projet ou juste un sous-ensemble.</p>
</section>
</section>
<section id="test-discovery">
<span id="unittest-test-discovery"></span><h2>Découverte des tests<a class="headerlink" href="#test-discovery" title="Lien permanent vers ce titre">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
<p>Unittest supports simple test discovery. In order to be compatible with test
discovery, all of the test files must be <a class="reference internal" href="../tutorial/modules.html#tut-modules"><span class="std std-ref">modules</span></a> or
<a class="reference internal" href="../tutorial/modules.html#tut-packages"><span class="std std-ref">packages</span></a> importable from the top-level directory of
the project (this means that their filenames must be valid <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">identifiers</span></a>).</p>
<p>La découverte de tests est implémentée dans <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.discover()</span></code></a>, mais peut également être utilisée depuis la ligne de commande. Par exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">project_directory</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Comme raccourci, <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span></code> est l'équivalent de <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span> <span class="pre">discover</span></code>. Pour passer des arguments au système de découverte des tests, la sous-commande <code class="docutils literal notranslate"><span class="pre">discover</span></code> doit être utilisée explicitement.</p>
</div>
<p>La sous-commande <code class="docutils literal notranslate"><span class="pre">discover</span></code> a les options suivantes :</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-unittest-discover-v">
<span id="cmdoption-unittest-discover-verbose"></span><span class="sig-name descname"><span class="pre">-v</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--verbose</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-unittest-discover-v" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Affichage plus détaillé</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-unittest-discover-s">
<span id="cmdoption-unittest-discover-start-directory"></span><span class="sig-name descname"><span class="pre">-s</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--start-directory</span></span><span class="sig-prename descclassname"> <span class="pre">directory</span></span><a class="headerlink" href="#cmdoption-unittest-discover-s" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Répertoire racine pour démarrer la découverte (<code class="docutils literal notranslate"><span class="pre">.</span></code> par défaut).</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-unittest-discover-p">
<span id="cmdoption-unittest-discover-pattern"></span><span class="sig-name descname"><span class="pre">-p</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--pattern</span></span><span class="sig-prename descclassname"> <span class="pre">pattern</span></span><a class="headerlink" href="#cmdoption-unittest-discover-p" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Motif de détection des fichiers de test (<code class="docutils literal notranslate"><span class="pre">test*.py</span></code> par défaut)</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-unittest-discover-t">
<span id="cmdoption-unittest-discover-top-level-directory"></span><span class="sig-name descname"><span class="pre">-t</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--top-level-directory</span></span><span class="sig-prename descclassname"> <span class="pre">directory</span></span><a class="headerlink" href="#cmdoption-unittest-discover-t" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Dossier du premier niveau du projet (Par défaut le dossier de départ)</p>
</dd></dl>

<p>Les options <a class="reference internal" href="#cmdoption-unittest-discover-s"><code class="xref std std-option docutils literal notranslate"><span class="pre">-s</span></code></a>, <a class="reference internal" href="#cmdoption-unittest-discover-p"><code class="xref std std-option docutils literal notranslate"><span class="pre">-p</span></code></a> et <a class="reference internal" href="#cmdoption-unittest-discover-t"><code class="xref std std-option docutils literal notranslate"><span class="pre">-t</span></code></a> peuvent être passées en arguments positionnels dans cet ordre. Les deux lignes de commande suivantes sont équivalentes :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="o">-</span><span class="n">s</span> <span class="n">project_directory</span> <span class="o">-</span><span class="n">p</span> <span class="s2">&quot;*_test.py&quot;</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="n">project_directory</span> <span class="s2">&quot;*_test.py&quot;</span>
</pre></div>
</div>
<p>Il est aussi possible de passer un nom de paquet plutôt qu'un chemin, par exemple <code class="docutils literal notranslate"><span class="pre">monprojet.souspaquet.test</span></code>, comme répertoire racine. Le nom du paquet fourni est alors importé et son emplacement sur le système de fichiers est utilisé comme répertoire racine.</p>
<div class="admonition caution">
<p class="admonition-title">Prudence</p>
<p>Le mécanisme de découverte charge les tests en les important. Une fois que le système a trouvé tous les fichiers de tests du répertoire de démarrage spécifié, il transforme les chemins en noms de paquets à importer. Par exemple <code class="file docutils literal notranslate"><span class="pre">truc/bidule/machin.py</span></code> est importé sous <code class="docutils literal notranslate"><span class="pre">truc.bidule.machin</span></code>.</p>
<p>Si un paquet est installé globalement et que le mécanisme de découverte de tests est effectué sur une copie différente du paquet, l'importation <em>peut</em> se produire à partir du mauvais endroit. Si cela arrive, le système émet un avertissement et se termine.</p>
<p>Si vous donnez le répertoire racine sous la forme d'un nom de paquet plutôt que d'un chemin d'accès à un répertoire, alors Python suppose que l'emplacement à partir duquel il importe est l'emplacement que vous voulez, vous ne verrez donc pas l'avertissement.</p>
</div>
<p>Les modules de test et les paquets peuvent adapter le chargement et la découverte des tests en utilisant le protocole <a class="reference internal" href="#load-tests-protocol">load_tests protocol</a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.4: </span>Test discovery supports <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">namespace packages</span></a>
for the start directory. Note that you need to specify the top level
directory too (e.g.
<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span> <span class="pre">discover</span> <span class="pre">-s</span> <span class="pre">root/namespace</span> <span class="pre">-t</span> <span class="pre">root</span></code>).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>Python 3.11 dropped the <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">namespace packages</span></a>
support. It has been broken since Python 3.7. Start directory and
subdirectories containing tests must be regular package that have
<code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file.</p>
<p>Directories containing start directory still can be a namespace package.
In this case, you need to specify start directory as dotted package name,
and target directory explicitly. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># proj/  &lt;-- current directory</span>
<span class="c1">#   namespace/</span>
<span class="c1">#     mypkg/</span>
<span class="c1">#       __init__.py</span>
<span class="c1">#       test_mypkg.py</span>

<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="o">-</span><span class="n">s</span> <span class="n">namespace</span><span class="o">.</span><span class="n">mypkg</span> <span class="o">-</span><span class="n">t</span> <span class="o">.</span>
</pre></div>
</div>
</div>
</section>
<section id="organizing-test-code">
<span id="organizing-tests"></span><h2>Organiser le code de test<a class="headerlink" href="#organizing-test-code" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les éléments de base des tests unitaires sont les <em class="dfn">scénarios de tests</em>  (<em>test cases</em> en anglais) --- Des scénarios uniques qui sont mis en place et exécutés pour vérifier qu'ils sont corrects.  Dans <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>, les scénarios de test sont représentés par des instances de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a>. Pour créer vos propres scénarios de test, vous devez écrire des sous-classes de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> ou utiliser <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a>.</p>
<p>Le code de test d'une instance de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> doit être entièrement autonome, de sorte qu'il puisse être exécuté soit de manière isolée, soit en combinaison arbitraire avec un nombre quelconque d'autres scénarios de test.</p>
<p>La sous-classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> la plus simple va tout simplement implémenter une méthode de test (c'est-à-dire une méthode dont le nom commence par <code class="docutils literal notranslate"><span class="pre">test</span></code>) afin d'exécuter un code de test spécifique :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">DefaultWidgetSizeTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_default_widget_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
</pre></div>
</div>
<p>Notez que pour tester quelque chose, on utilise l'une des méthodes <code class="xref py py-meth docutils literal notranslate"><span class="pre">assert*()</span></code> fournies par la classe de base <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>.  Si le test échoue, une exception est levée avec un message explicatif, et <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> identifie ce scénario de test comme un <em class="dfn">échec</em>.  Toute autre exception est traitée comme une <em class="dfn">erreur</em>.</p>
<p>Les tests peuvent être nombreux et leur mise en place peut être répétitive.  Heureusement, on peut factoriser le code de mise en place en implémentant une méthode appelée <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>, que le système de test appelle automatiquement pour chaque test exécuté :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">WidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_default_widget_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
                         <span class="s1">&#39;incorrect default size&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_widget_resize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">),</span>
                         <span class="s1">&#39;wrong size after resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>L'ordre dans lequel les différents tests sont exécutés est déterminé en classant les noms des méthodes de test en fonction de la relation d'ordre des chaines de caractères .</p>
</div>
<p>Si la méthode <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> lève une exception pendant l'exécution du test, le système considère que le test a subi une erreur, et la méthode test n'est pas exécutée.</p>
<p>De même, on peut fournir une méthode <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> qui nettoie après l'exécution de la méthode de test :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">WidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
</pre></div>
</div>
<p>Si <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> a réussi, <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> est exécutée, que la méthode de test ait réussi ou non.</p>
<p>Un tel environnement de travail pour le code de test s'appelle un <em class="dfn">aménagement de test</em> (<em>fixture</em> en anglais).  Une nouvelle instance de <em>TestCase</em> est créée sous la forme d'un dispositif de test unique utilisé pour exécuter chaque méthode de test individuelle.  Ainsi <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> et <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> ne sont appelées qu'une fois par test.</p>
<p>Il est recommandé d'utiliser <em>TestCase</em> pour regrouper les tests en fonction des fonctionnalités qu'ils testent. <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> fournit un mécanisme pour cela : la <em class="dfn">suite de tests</em>, représentée par <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> du module <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>. Dans la plupart des cas, appeler <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> fait correctement les choses et trouve tous les scénarios de test du module pour vous et les exécute.</p>
<p>Cependant, si vous voulez personnaliser la construction de votre suite de tests, vous pouvez le faire vous-même :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_default_widget_size&#39;</span><span class="p">))</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_widget_resize&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">suite</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">runner</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TextTestRunner</span><span class="p">()</span>
    <span class="n">runner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">suite</span><span class="p">())</span>
</pre></div>
</div>
<p>Vous pouvez placer les définitions des scénarios de test et des suites de test dans le même module que le code à tester (tel que <code class="file docutils literal notranslate"><span class="pre">composant.py</span></code>), mais il y a plusieurs avantages à placer le code de test dans un module séparé, tel que <code class="file docutils literal notranslate"><span class="pre">test_composant.py</span></code> :</p>
<ul class="simple">
<li><p>Le module de test peut être exécuté indépendamment depuis la ligne de commande.</p></li>
<li><p>Le code de test est plus facilement séparable du code livré.</p></li>
<li><p>La tentation est moins grande de changer le code de test pour l'adapter au code qu'il teste sans avoir une bonne raison.</p></li>
<li><p>Le code de test doit être modifié beaucoup moins souvent que le code qu'il teste.</p></li>
<li><p>Le code testé peut être réusiné plus facilement.</p></li>
<li><p>Les tests pour les modules écrits en C doivent de toute façon être dans des modules séparés, alors pourquoi ne pas être cohérent ?</p></li>
<li><p>Si la stratégie de test change, il n'est pas nécessaire de changer le code source.</p></li>
</ul>
</section>
<section id="re-using-old-test-code">
<span id="legacy-unit-tests"></span><h2>Réutilisation d'ancien code de test<a class="headerlink" href="#re-using-old-test-code" title="Lien permanent vers ce titre">¶</a></h2>
<p>Certains utilisateurs constatent qu'ils ont du code de test existant qu'ils souhaitent exécuter à partir de <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>, sans convertir chaque ancienne fonction de test en une sous-classe de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>.</p>
<p>Pour cette raison, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> fournit une classe <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a>. Cette sous-classe de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> peut être utilisée pour encapsuler une fonction de test existante. Des fonctions de mise en place (<em>setUp</em>) et de démantèlement (<em>tearDown</em>) peuvent également être fournies.</p>
<p>Étant donnée la fonction de test suivante :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">testSomething</span><span class="p">():</span>
    <span class="n">something</span> <span class="o">=</span> <span class="n">makeSomething</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">something</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>on peut créer une instance de scénario de test équivalente, avec des méthodes optionnelles de mise en place et de démantèlement :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">testcase</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">FunctionTestCase</span><span class="p">(</span><span class="n">testSomething</span><span class="p">,</span>
                                     <span class="n">setUp</span><span class="o">=</span><span class="n">makeSomethingDB</span><span class="p">,</span>
                                     <span class="n">tearDown</span><span class="o">=</span><span class="n">deleteSomethingDB</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Même si  la classe <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a> peut être utilisée pour convertir rapidement une base de test existante vers un système basé sur <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>, cette approche n'est pas recommandée.  Prendre le temps de bien configurer les sous-classes de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> simplifiera considérablement les futurs réusinages des tests.</p>
</div>
<p>Dans certains cas, les tests déjà existants ont pu être écrits avec le module <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>.  Dans ce cas, <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> fournit une classe <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestSuite</span></code> qui peut construire automatiquement des instances de la classe <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a> depuis des tests basés sur le module <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>.</p>
</section>
<section id="skipping-tests-and-expected-failures">
<span id="unittest-skipping"></span><h2>Ignorer des tests et des erreurs prévisibles<a class="headerlink" href="#skipping-tests-and-expected-failures" title="Lien permanent vers ce titre">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
<p><em>Unittest</em> permet d'ignorer des méthodes de test individuelles et même des classes entières de tests. De plus, il prend en charge le marquage d'un test comme étant une &quot;erreur prévue&quot;. Un test qui est cassé et qui échoue, mais qui ne doit pas être considéré comme un échec dans la classe <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>.</p>
<p>Ignorer un test consiste à soit utiliser le <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">décorateur</span></a> <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code class="xref py py-func docutils literal notranslate"><span class="pre">skip()</span></code></a> ou une de ses variantes conditionnelles, soit appeler <a class="reference internal" href="#unittest.TestCase.skipTest" title="unittest.TestCase.skipTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.skipTest()</span></code></a> à l'intérieur d'une méthode <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> ou de test, soit lever <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> directement.</p>
<p>Un exemple de tests à ignorer :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;demonstrating skipping&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_nothing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s2">&quot;shouldn&#39;t happen&quot;</span><span class="p">)</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipIf</span><span class="p">(</span><span class="n">mylib</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                     <span class="s2">&quot;not supported in this library version&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Tests that work for only a certain version of the library.</span>
        <span class="k">pass</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipUnless</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;win&quot;</span><span class="p">),</span> <span class="s2">&quot;requires Windows&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_windows_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># windows specific testing code</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">test_maybe_skipped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">external_resource_available</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipTest</span><span class="p">(</span><span class="s2">&quot;external resource not available&quot;</span><span class="p">)</span>
        <span class="c1"># test code that depends on the external resource</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>Ceci est le résultat de l'exécution de l'exemple ci-dessus en mode verbeux :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_format</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="o">.</span><span class="n">test_format</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;not supported in this library version&#39;</span>
<span class="n">test_nothing</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="o">.</span><span class="n">test_nothing</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;demonstrating skipping&#39;</span>
<span class="n">test_maybe_skipped</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="o">.</span><span class="n">test_maybe_skipped</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;external resource not available&#39;</span>
<span class="n">test_windows_support</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="o">.</span><span class="n">test_windows_support</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;requires Windows&#39;</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">4</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.005</span><span class="n">s</span>

<span class="n">OK</span> <span class="p">(</span><span class="n">skipped</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>Les classes peuvent être ignorées tout comme les méthodes :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;showing class skipping&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MySkippedTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_not_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>La méthode <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.setUp()</span></code></a> permet également d'ignorer le test.  Ceci est utile lorsqu'une ressource qui doit être configurée n'est pas disponible.</p>
<p>Les erreurs prévisibles utilisent le décorateur <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExpectedFailureTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@unittest</span><span class="o">.</span><span class="n">expectedFailure</span>
    <span class="k">def</span> <span class="nf">test_fail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;broken&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Il est facile de faire ses propres décorateurs en créant un décorateur qui appelle <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code class="xref py py-func docutils literal notranslate"><span class="pre">skip()</span></code></a> sur le test que vous voulez ignorer. Par exemple, ce décorateur ignore le test à moins que l'objet passé ne possède un certain attribut :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">skipUnlessHasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">:</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> doesn&#39;t have </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
</pre></div>
</div>
<p>Les décorateurs et exceptions suivants implémentent le système d'omission des tests et les erreurs prévisibles :</p>
<dl class="py function">
<dt class="sig sig-object py" id="unittest.skip">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">skip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reason</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skip" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ignore sans condition le test décoré.  <em>La raison</em> doit décrire la raison pour laquelle le test est omis.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.skipIf">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">skipIf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reason</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skipIf" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ignore le test décoré si la <em>condition</em> est vraie.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.skipUnless">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">skipUnless</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reason</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skipUnless" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ignore le test décoré sauf si la <em>condition</em> est vraie.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.expectedFailure">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">expectedFailure</span></span><a class="headerlink" href="#unittest.expectedFailure" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Mark the test as an expected failure or error.  If the test fails or errors
in the test function itself (rather than in one of the <em class="dfn">test fixture</em>
methods) then it will be considered a success.  If the test passes, it will
be considered a failure.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="unittest.SkipTest">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">SkipTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reason</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.SkipTest" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette exception est levée pour ignorer un test.</p>
<p>Habituellement, on utilise <a class="reference internal" href="#unittest.TestCase.skipTest" title="unittest.TestCase.skipTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.skipTest()</span></code></a> ou l'un des décorateurs d'omission au lieu de le lever une exception directement.</p>
</dd></dl>

<p>Les tests ignorés ne lancent ni <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> ni <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a>. Les classes ignorées ne lancent ni <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> ni <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a>. Les modules sautés n'ont pas <code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code> ou <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> d'exécutés.</p>
</section>
<section id="distinguishing-test-iterations-using-subtests">
<span id="subtests"></span><h2>Distinguer les itérations de test à l'aide de sous-tests<a class="headerlink" href="#distinguishing-test-iterations-using-subtests" title="Lien permanent vers ce titre">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.4.</span></p>
</div>
<p>Lorsque certains de vos tests ne diffèrent que par de très petites différences, par exemple certains paramètres, <em>unittest</em> vous permet de les distinguer en utilisant le gestionnaire de contexte <a class="reference internal" href="#unittest.TestCase.subTest" title="unittest.TestCase.subTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subTest()</span></code></a> dans le corps d'une méthode de test.</p>
<p>Par exemple, le test suivant :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NumbersTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_even</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test that numbers between 0 and 5 are all even.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">subTest</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>produit le résultat suivant :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="o">.</span><span class="n">test_even</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Test</span> <span class="n">that</span> <span class="n">numbers</span> <span class="n">between</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">5</span> <span class="n">are</span> <span class="nb">all</span> <span class="n">even</span><span class="o">.</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">11</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="o">.</span><span class="n">test_even</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Test</span> <span class="n">that</span> <span class="n">numbers</span> <span class="n">between</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">5</span> <span class="n">are</span> <span class="nb">all</span> <span class="n">even</span><span class="o">.</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">11</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="o">.</span><span class="n">test_even</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Test</span> <span class="n">that</span> <span class="n">numbers</span> <span class="n">between</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">5</span> <span class="n">are</span> <span class="nb">all</span> <span class="n">even</span><span class="o">.</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">11</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Sans l'utilisation d'un sous-test, l'exécution se termine après le premier échec, et l'erreur est moins facile à diagnostiquer car la valeur de <code class="docutils literal notranslate"><span class="pre">i</span></code> ne s'affiche pas :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="o">.</span><span class="n">test_even</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>
</pre></div>
</div>
</section>
<section id="classes-and-functions">
<span id="unittest-contents"></span><h2>Classes et fonctions<a class="headerlink" href="#classes-and-functions" title="Lien permanent vers ce titre">¶</a></h2>
<p>Cette section décrit en détail l'API de <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>.</p>
<section id="test-cases">
<span id="testcase-objects"></span><h3>Scénarios de tests<a class="headerlink" href="#test-cases" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="unittest.TestCase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">TestCase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Les instances de la classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> représentent des tests logiques unitaires dans l'univers <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>. Cette classe est conçue pour être utilisée comme classe de base. Les scénarios de tests sont à implémenter en héritant de cette classe. La classe implémente l'interface nécessaire au lanceur de tests pour lui permettre de les exécuter ainsi que les méthodes que le code de test peut utiliser pour vérifier et signaler les différents types d'erreurs.</p>
<p>Chaque instance de la classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> n'exécute qu'une seule méthode de base : la méthode nommée <em>methodName</em> . Dans la plupart des utilisations de la classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>, vous n'avez pas à changer le nom de la méthode, ni à réimplémenter la méthode <code class="docutils literal notranslate"><span class="pre">runTest()</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.2: </span>La classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> peut désormais être utilisée sans passer de paramètre <em>methodName</em>. Cela facilite l'usage de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> dans l'interpréteur interactif.</p>
</div>
<p>Les instances de la classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> fournissent trois groupes de méthodes : un groupe utilisé pour exécuter le test, un autre utilisé par l'implémentation du test pour vérifier les conditions et signaler les échecs, et quelques méthodes de recherche permettant de recueillir des informations sur le test lui-même.</p>
<p>Les méthodes du premier groupe (exécution du test) sont :</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.setUp">
<span class="sig-name descname"><span class="pre">setUp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.setUp" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Méthode appelée pour réaliser la mise en place du test. Elle est exécutée immédiatement avant l'appel de la méthode de test ; à l'exception de <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> ou <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>, toute exception levée par cette méthode est considérée comme une erreur et non pas comme un échec du test. L'implémentation par défaut ne fait rien.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.tearDown">
<span class="sig-name descname"><span class="pre">tearDown</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.tearDown" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Méthode appelée immédiatement après l'appel de la méthode de test et l'enregistrement du résultat.  Elle est appelée même si la méthode de test a levé une exception. De fait, l'implémentation d'un sous-classes doit être fait avec précaution  si vous vérifiez l'état interne de la classe. Toute exception, autre que <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> ou <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>, levée par cette méthode est considérée comme une erreur supplémentaire plutôt que comme un échec du test (augmentant ainsi le nombre total des erreurs signalées). Cette méthode est appelée uniquement si l'exécution de <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> est réussie quel que soit le résultat de la méthode de test. L'implémentation par défaut ne fait rien.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.setUpClass">
<span class="sig-name descname"><span class="pre">setUpClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.setUpClass" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Méthode de classe appelée avant l'exécution des tests dans la classe en question. <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> est appelée avec la classe comme seul argument et doit être décorée comme une  <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Voir <a class="reference internal" href="#class-and-module-fixtures">Class and Module Fixtures</a> pour plus de détails.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.tearDownClass">
<span class="sig-name descname"><span class="pre">tearDownClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.tearDownClass" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Méthode de classe appelée après l'exécution des tests de la classe en question. <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> est appelée avec la classe comme seul argument et doit être décorée comme une <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classmethod()</span></code></a> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Voir <a class="reference internal" href="#class-and-module-fixtures">Class and Module Fixtures</a> pour plus de détails.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.run" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Exécute le test, en collectant le résultat dans l'objet <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> passé comme <em>result</em>.  Si <em>result</em> est omis ou vaut <code class="docutils literal notranslate"><span class="pre">None</span></code>, un objet temporaire de résultat est créé (en appelant la méthode <a class="reference internal" href="#unittest.TestCase.defaultTestResult" title="unittest.TestCase.defaultTestResult"><code class="xref py py-meth docutils literal notranslate"><span class="pre">defaultTestResult()</span></code></a>) et utilisé. L'objet résultat est renvoyé à l'appelant de <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>.</p>
<p>Le même effet peut être obtenu en appelant simplement l'instance <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.3: </span>Les versions précédentes de <code class="docutils literal notranslate"><span class="pre">run</span></code> ne renvoyaient pas le résultat. Pas plus que l'appel d'une instance.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.skipTest">
<span class="sig-name descname"><span class="pre">skipTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reason</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.skipTest" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appeler cette fonction pendant l'exécution d'une méthode de test ou de <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> permet d'ignorer le test en cours.  Voir <a class="reference internal" href="#unittest-skipping"><span class="std std-ref">Ignorer des tests et des erreurs prévisibles</span></a> pour plus d'informations.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.subTest">
<span class="sig-name descname"><span class="pre">subTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.subTest" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un gestionnaire de contexte qui exécute le bloc de code du contexte comme un sous-test. <em>msg</em> et <em>params</em> sont des valeurs optionnelles et arbitraires qui sont affichées chaque fois qu'un sous-test échoue, permettant de les identifier clairement.</p>
<p>Un scénario de test peut contenir un nombre quelconque de déclarations de sous-test, et elles peuvent être imbriquées librement.</p>
<p>Voir <a class="reference internal" href="#subtests"><span class="std std-ref">Distinguer les itérations de test à l'aide de sous-tests</span></a> pour plus d'informations.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.debug">
<span class="sig-name descname"><span class="pre">debug</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.debug" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Lance le test sans collecter le résultat.  Ceci permet aux exceptions levées par le test d'être propagées à l'appelant, et donc peut être utilisé pour exécuter des tests sous un débogueur.</p>
</dd></dl>

<p id="assert-methods">La classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> fournit plusieurs méthodes d'assertion pour vérifier et signaler les échecs.  Le tableau suivant énumère les méthodes les plus couramment utilisées (voir les tableaux ci-dessous pour plus de méthodes d'assertion) :</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 48%" />
<col style="width: 34%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Méthode</p></th>
<th class="head"><p>Vérifie que</p></th>
<th class="head"><p>Disponible en</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">True</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">False</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIs(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNot" title="unittest.TestCase.assertIsNot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNot(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNone" title="unittest.TestCase.assertIsNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNone(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">None</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNotNone" title="unittest.TestCase.assertIsNotNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNotNone(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIn" title="unittest.TestCase.assertIn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIn(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">in</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotIn" title="unittest.TestCase.assertNotIn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotIn(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsInstance" title="unittest.TestCase.assertIsInstance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsInstance(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">isinstance(a,</span> <span class="pre">b)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotIsInstance" title="unittest.TestCase.assertNotIsInstance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotIsInstance(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">isinstance(a,</span> <span class="pre">b)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
</tbody>
</table>
<p>Toutes les méthodes <em>assert</em> prennent en charge un argument <em>msg</em> qui, s'il est spécifié, est utilisé comme message d'erreur en cas d'échec (voir aussi <a class="reference internal" href="#unittest.TestCase.longMessage" title="unittest.TestCase.longMessage"><code class="xref py py-data docutils literal notranslate"><span class="pre">longMessage</span></code></a>). Notez que l'argument nommé <em>msg</em> peut être passé à <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertWarnsRegex" title="unittest.TestCase.assertWarnsRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarnsRegex()</span></code></a>, seulement quand elles sont utilisées comme gestionnaire de contexte.</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertEqual">
<span class="sig-name descname"><span class="pre">assertEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertEqual" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que <em>first</em> et <em>second</em> sont égaux.  Si les valeurs ne sont pas égales, le test échouera.</p>
<p>En outre, si <em>first</em> et <em>second</em> ont exactement le même type et sont de type <em>list</em>, <em>tuple</em>, <em>dict</em>, <em>set</em>, <em>frozenset</em> ou <em>str</em> ou tout autre type de sous classe enregistrée dans <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTypeEqualityFunc()</span></code></a>. La fonction égalité spécifique au type sera appelée pour générer une erreur plus utile (voir aussi <a class="reference internal" href="#type-specific-methods"><span class="std std-ref">liste des méthodes spécifiques de type</span></a>).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.1: </span>Ajout de l'appel automatique de la fonction d'égalité spécifique au type.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.2: </span>Ajout de <a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual()</span></code></a> comme fonction d'égalité de type par défaut pour comparer les chaînes.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertNotEqual">
<span class="sig-name descname"><span class="pre">assertNotEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotEqual" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que <em>first</em> et <em>second</em> ne sont pas égaux.  Si les valeurs sont égales, le test échouera.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertTrue">
<span class="sig-name descname"><span class="pre">assertTrue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertTrue" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertFalse">
<span class="sig-name descname"><span class="pre">assertFalse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertFalse" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que <em>expr</em> est vraie (ou fausse).</p>
<p>Notez que cela revient à utiliser <code class="docutils literal notranslate"><span class="pre">bool(expr)</span> <span class="pre">is</span> <span class="pre">True</span></code> et non à <code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">is</span> <span class="pre">True</span></code> (utilisez <code class="docutils literal notranslate"><span class="pre">assertIs(expr,</span> <span class="pre">True)</span></code> pour cette dernière). Cette méthode doit également être évitée lorsque des méthodes plus spécifiques sont disponibles (par exemple <code class="docutils literal notranslate"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></code> au lieu de <code class="docutils literal notranslate"><span class="pre">assertTrue(a</span> <span class="pre">==</span> <span class="pre">b)</span></code>), car elles fournissent un meilleur message d'erreur en cas d' échec.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertIs">
<span class="sig-name descname"><span class="pre">assertIs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIs" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertIsNot">
<span class="sig-name descname"><span class="pre">assertIsNot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNot" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que <em>first</em> et <em>second</em> sont (ou ne sont pas) le même objet.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertIsNone">
<span class="sig-name descname"><span class="pre">assertIsNone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNone" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertIsNotNone">
<span class="sig-name descname"><span class="pre">assertIsNotNone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNotNone" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que <em>expr</em> est (ou n'est pas) la valeur <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertIn">
<span class="sig-name descname"><span class="pre">assertIn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">member</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">container</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIn" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertNotIn">
<span class="sig-name descname"><span class="pre">assertNotIn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">member</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">container</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotIn" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que <em>member</em> est (ou n'est pas) dans <em>container</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertIsInstance">
<span class="sig-name descname"><span class="pre">assertIsInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsInstance" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertNotIsInstance">
<span class="sig-name descname"><span class="pre">assertNotIsInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotIsInstance" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que <em>obj</em> est (ou n'est pas) une instance de <em>cls</em> (Ce qui peut être une classe ou un <em>n</em>-uplet de classes, comme utilisée par <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>). Pour vérifier le type exact, utilisez <a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code class="xref py py-func docutils literal notranslate"><span class="pre">assertIs(type(obj),</span> <span class="pre">cls)</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
</dd></dl>

<p>Il est également possible de vérifier la production des exceptions, des avertissements et des messages de journaux à l'aide des méthodes suivantes :</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 53%" />
<col style="width: 36%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Méthode</p></th>
<th class="head"><p>Vérifie que</p></th>
<th class="head"><p>Disponible en</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises(exc,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> lève bien l'exception <em>exc</em></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex(exc,</span> <span class="pre">r,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> lève bien l'exception <em>exc</em> et que le message correspond au motif de l'expression régulière <em>r</em></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns(warn,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> lève bien l'avertissement <em>warn</em></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertWarnsRegex" title="unittest.TestCase.assertWarnsRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarnsRegex(warn,</span> <span class="pre">r,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> lève bien l'avertissement <em>warn</em> et que le message correspond au motif de l'expression régulière <em>r</em></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertLogs" title="unittest.TestCase.assertLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLogs(logger,</span> <span class="pre">level)</span></code></a></p></td>
<td><p>Le bloc <code class="docutils literal notranslate"><span class="pre">with</span></code> écrit dans le <em>logger</em>  avec un niveau minimum égal à <em>level</em></p></td>
<td><p>3.4</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNoLogs" title="unittest.TestCase.assertNoLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNoLogs(logger,</span> <span class="pre">level)</span></code></a></p></td>
<td><dl class="simple">
<dt>The <code class="docutils literal notranslate"><span class="pre">with</span></code> block does not log on</dt><dd><p><em>logger</em> with minimum <em>level</em></p>
</dd>
</dl>
</td>
<td><p>3.10</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertRaises">
<span class="sig-name descname"><span class="pre">assertRaises</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRaises" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">assertRaises</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Vérifie qu'une exception est levée lorsque <em>callable</em> est appelé avec n'importe quel argument positionnel ou nommé qui est également passé à <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a>.  Le test réussit si <em>exception</em> est levée, est en erreur si une autre exception est levée, ou en échec si aucune exception n'est levée. Pour capturer une exception d'un groupe d'exceptions, un <em>n</em>-uplet contenant les classes d'exceptions peut être passé à <em>exception</em>.</p>
<p>Si seuls les arguments <em>exception</em> et éventuellement <em>msg</em> sont donnés, renvoie un gestionnaire de contexte pour que le code sous test puisse être écrit en ligne plutôt que comme une fonction :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">()</span>
</pre></div>
</div>
<p>Lorsqu'il est utilisé comme gestionnaire de contexte, <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> accepte l'argument nommé supplémentaire <em>msg</em>.</p>
<p>Le gestionnaire de contexte enregistre l'exception interceptée dans son attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">exception</span></code>. Ceci est particulièrement utile si l'intention est d'effectuer des contrôles supplémentaires sur l'exception levée :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>

<span class="n">the_exception</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">exception</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">the_exception</span><span class="o">.</span><span class="n">error_code</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.1: </span>Ajout de la possibilité d'utiliser <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> comme gestionnaire de contexte.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.2: </span>Ajout de l'attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">exception</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.3: </span>Ajout de l'argument nommé <em>msg</em> lorsqu'il est utilisé comme gestionnaire de contexte.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertRaisesRegex">
<span class="sig-name descname"><span class="pre">assertRaisesRegex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRaisesRegex" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">assertRaisesRegex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regex</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Comme <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> mais vérifie aussi que <em>regex</em> correspond à la représentation de la chaîne de caractères de l'exception levée.  <em>regex</em> peut être un objet d'expression rationnelle ou une chaîne contenant une expression rationnelle appropriée pour être utilisée par <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>.  Exemples :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegex</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;invalid literal for.*XYZ&#39;$&quot;</span><span class="p">,</span>
                       <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>ou :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegex</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s1">&#39;literal&#39;</span><span class="p">):</span>
   <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1: </span>Sous le nom <code class="docutils literal notranslate"><span class="pre">assertRaisesRegexp</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.2: </span>Renommé en <a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.3: </span>Ajout de l'argument nommé <em>msg</em> lorsqu'il est utilisé comme gestionnaire de contexte.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertWarns">
<span class="sig-name descname"><span class="pre">assertWarns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">warning</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertWarns" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">assertWarns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">warning</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Test qu'un avertissement est déclenché lorsque <em>callable</em> est appelé avec n'importe quel argument positionnel ou nommé qui est également passé à <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a>. Le test passe si <em>warning</em> est déclenché et échoue s'il ne l'est pas. Toute exception est une erreur. Pour capturer un avertissement dans un ensemble d'avertissements, un <em>n</em>-uplet contenant les classes d'avertissement peut être passé à <em>warnings</em>.</p>
<p>Si seuls les arguments * warning* et éventuellement <em>msg</em> sont donnés, renvoie un gestionnaire de contexte pour que le code testé puisse être écrit en ligne plutôt que comme une fonction :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarns</span><span class="p">(</span><span class="n">SomeWarning</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">()</span>
</pre></div>
</div>
<p>Lorsqu'il est utilisé comme gestionnaire de contexte, <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a> accepte l'argument nommé supplémentaire <em>msg</em>.</p>
<p>Le gestionnaire de contexte stocke l'avertissement capturé dans son attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">warning</span></code>, et la ligne source qui a déclenché les avertissements dans les attributs <code class="xref py py-attr docutils literal notranslate"><span class="pre">filename</span></code> et <code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code>. Cette fonction peut être utile si l'intention est d'effectuer des contrôles supplémentaires sur l'avertissement capturé :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarns</span><span class="p">(</span><span class="n">SomeWarning</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>

<span class="bp">self</span><span class="o">.</span><span class="n">assertIn</span><span class="p">(</span><span class="s1">&#39;myfile.py&#39;</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">lineno</span><span class="p">)</span>
</pre></div>
</div>
<p>Cette méthode fonctionne indépendamment des filtres d'avertissement en place lorsqu'elle est appelée.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.3: </span>Ajout de l'argument nommé <em>msg</em> lorsqu'il est utilisé comme gestionnaire de contexte.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertWarnsRegex">
<span class="sig-name descname"><span class="pre">assertWarnsRegex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">warning</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertWarnsRegex" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">assertWarnsRegex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">warning</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regex</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Comme <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a> mais vérifie aussi qu'une <em>regex</em> corresponde au message de l'avertissement. <em>regex</em> peut être un objet d'expression régulière ou une chaîne contenant une expression régulière appropriée pour être utilisée par <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>. Exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">assertWarnsRegex</span><span class="p">(</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                      <span class="sa">r</span><span class="s1">&#39;legacy_function\(\) is deprecated&#39;</span><span class="p">,</span>
                      <span class="n">legacy_function</span><span class="p">,</span> <span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>ou :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarnsRegex</span><span class="p">(</span><span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="s1">&#39;unsafe frobnicating&#39;</span><span class="p">):</span>
    <span class="n">frobnicate</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.3: </span>Ajout de l'argument nommé <em>msg</em> lorsqu'il est utilisé comme gestionnaire de contexte.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertLogs">
<span class="sig-name descname"><span class="pre">assertLogs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLogs" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Un gestionnaire de contexte pour tester qu'au moins un message est enregistré sur le <em>logger</em> ou un de ses enfants, avec au moins le <em>niveau</em> donné.</p>
<p>Si donné, <em>logger</em> doit être une classe <code class="xref py py-class docutils literal notranslate"><span class="pre">logging.logger</span></code> objet ou une classe <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> donnant le nom d'un journal. La valeur par défaut est le journal racine <em>root</em>, qui capture tous les messages qui n'ont pas été arrêtés par un <em>logger</em> ne propageant pas les messages.</p>
<p>If given, <em>level</em> should be either a numeric logging level or
its string equivalent (for example either <code class="docutils literal notranslate"><span class="pre">&quot;ERROR&quot;</span></code> or
<a class="reference internal" href="logging.html#logging.ERROR" title="logging.ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">logging.ERROR</span></code></a>).  The default is <a class="reference internal" href="logging.html#logging.INFO" title="logging.INFO"><code class="xref py py-const docutils literal notranslate"><span class="pre">logging.INFO</span></code></a>.</p>
<p>Le test passe si au moins un message émis à l'intérieur du bloc <code class="docutils literal notranslate"><span class="pre">with</span></code> correspond aux conditions <em>logger</em> et <em>level</em>, sinon il échoue.</p>
<p>L'objet retourné par le gestionnaire de contexte est une aide à l'enregistrement qui garde la trace des messages de journal correspondants. Il a deux attributs :</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestCase.records">
<span class="sig-name descname"><span class="pre">records</span></span><a class="headerlink" href="#unittest.TestCase.records" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Une liste d'objets <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.LogRecord</span></code></a> de messages de log correspondants.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestCase.output">
<span class="sig-name descname"><span class="pre">output</span></span><a class="headerlink" href="#unittest.TestCase.output" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Une liste d'objets <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> avec la sortie formatée des messages correspondants.</p>
</dd></dl>

<p>Exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertLogs</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;INFO&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;first message&#39;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;foo.bar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;second message&#39;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;INFO:foo:first message&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;ERROR:foo.bar:second message&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertNoLogs">
<span class="sig-name descname"><span class="pre">assertNoLogs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNoLogs" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>A context manager to test that no messages are logged on
the <em>logger</em> or one of its children, with at least the given
<em>level</em>.</p>
<p>If given, <em>logger</em> should be a <a class="reference internal" href="logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Logger</span></code></a> object or a
<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> giving the name of a logger.  The default is the root
logger, which will catch all messages.</p>
<p>If given, <em>level</em> should be either a numeric logging level or
its string equivalent (for example either <code class="docutils literal notranslate"><span class="pre">&quot;ERROR&quot;</span></code> or
<a class="reference internal" href="logging.html#logging.ERROR" title="logging.ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">logging.ERROR</span></code></a>).  The default is <a class="reference internal" href="logging.html#logging.INFO" title="logging.INFO"><code class="xref py py-const docutils literal notranslate"><span class="pre">logging.INFO</span></code></a>.</p>
<p>Unlike <a class="reference internal" href="#unittest.TestCase.assertLogs" title="unittest.TestCase.assertLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLogs()</span></code></a>, nothing will be returned by the context
manager.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.10.</span></p>
</div>
</dd></dl>

<p>Il existe également d'autres méthodes utilisées pour effectuer des contrôles plus spécifiques, telles que :</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 38%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Méthode</p></th>
<th class="head"><p>Vérifie que</p></th>
<th class="head"><p>Disponible en</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">==</span> <span class="pre">0</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">!=</span> <span class="pre">0</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertGreater" title="unittest.TestCase.assertGreater"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertGreater(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertGreaterEqual" title="unittest.TestCase.assertGreaterEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertGreaterEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertLess" title="unittest.TestCase.assertLess"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLess(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertLessEqual" title="unittest.TestCase.assertLessEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLessEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex(s,</span> <span class="pre">r)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r.search(s)</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex(s,</span> <span class="pre">r)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">r.search(s)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertCountEqual" title="unittest.TestCase.assertCountEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertCountEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><em>a</em> et <em>b</em> ont les mêmes éléments dans le même nombre, quel que soit leur ordre.</p></td>
<td><p>3.2</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertAlmostEqual">
<span class="sig-name descname"><span class="pre">assertAlmostEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">places</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertAlmostEqual" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertNotAlmostEqual">
<span class="sig-name descname"><span class="pre">assertNotAlmostEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">places</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotAlmostEqual" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que <em>first</em> et <em>second</em> sont approximativement (ou pas approximativement) égaux en calculant la différence, en arrondissant au nombre donné de décimales <em>places</em> (par défaut 7), et en comparant à zéro. Notez que ces méthodes arrondissent les valeurs au nombre donné de <em>décimales</em> (par exemple comme la fonction <a class="reference internal" href="functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a>) et non aux <em>chiffres significatifs</em>.</p>
<p>Si <em>delta</em> est fourni au lieu de <em>places</em>, la différence entre <em>first</em> et <em>second</em> doit être inférieure ou égale (ou supérieure) à <em>delta</em>.</p>
<p>Fournir à la fois <em>delta</em> et <em>places</em> lève une <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.2: </span><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual()</span></code></a> considère automatiquement des objets presque égaux qui se comparent égaux. <code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotNotAlmostEqual()</span></code> échoue automatiquement si les objets qui se comparent sont égaux.  Ajout de l'argument nommé <em>delta</em>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertGreater">
<span class="sig-name descname"><span class="pre">assertGreater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertGreater" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertGreaterEqual">
<span class="sig-name descname"><span class="pre">assertGreaterEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertGreaterEqual" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertLess">
<span class="sig-name descname"><span class="pre">assertLess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLess" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertLessEqual">
<span class="sig-name descname"><span class="pre">assertLessEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLessEqual" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que <em>first</em> est respectivement &gt;, &gt;=, &gt;=, &lt; ou &lt;= à <em>second</em> selon le nom de la méthode.  Sinon, le test échouera :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">assertGreaterEqual</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">AssertionError: &quot;3&quot; unexpectedly not greater than or equal to &quot;4&quot;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertRegex">
<span class="sig-name descname"><span class="pre">assertRegex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRegex" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertNotRegex">
<span class="sig-name descname"><span class="pre">assertNotRegex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotRegex" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie qu'une  recherche par motif <em>regex</em> correspond (ou ne correspond pas) à <em>text</em>.  En cas d'échec, le message d'erreur inclura le motif et le <em>texte</em> (ou le motif et la partie du <em>texte</em> qui correspond de manière inattendue).  <em>regex</em> peut être un objet d'expression régulière ou une chaîne contenant une expression régulière appropriée pour être utilisée par <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1: </span>Ajouté sous le nom <code class="docutils literal notranslate"><span class="pre">assertRegexpMatches</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.2: </span>La méthode <code class="docutils literal notranslate"><span class="pre">assertRegexpMatches()</span></code> a été renommé en <a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2: </span><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertCountEqual">
<span class="sig-name descname"><span class="pre">assertCountEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertCountEqual" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que la séquence <em>first</em> contient les mêmes éléments que <em>second</em>, quel que soit leur ordre. Si ce n'est pas le cas, un message d'erreur indiquant les différences entre les séquences est généré.</p>
<p>Les éléments en double ne sont <em>pas</em> ignorés lors de la comparaison entre <em>first</em> et <em>second</em>. Il vérifie si chaque élément a le même nombre dans les deux séquences. Équivalent à : <code class="docutils literal notranslate"><span class="pre">assertEqual(Counter(list(first))),</span> <span class="pre">Counter(list(second)))</span></code> mais fonctionne aussi avec des séquences d'objets non <em>hachables</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
</dd></dl>

<p id="type-specific-methods">La méthode <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> envoie le contrôle d'égalité pour les objets du même type à différentes méthodes spécifiques au type. Ces méthodes sont déjà implémentées pour la plupart des types intégrés, mais il est également possible d'enregistrer de nouvelles méthodes en utilisant <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTypeEqualityFunc()</span></code></a> :</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.addTypeEqualityFunc">
<span class="sig-name descname"><span class="pre">addTypeEqualityFunc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typeobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addTypeEqualityFunc" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Enregistre une méthode spécifique appelée par <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> pour vérifier si deux objets exactement du même <em>typeobj</em> (et non leurs sous-classes) sont égaux. <em>function</em> doit prendre deux arguments positionnels et un troisième argument nommé <em>msg=None</em> tout comme <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> le fait. Il doit lever <a class="reference internal" href="#unittest.TestCase.failureException" title="unittest.TestCase.failureException"><code class="xref py py-data docutils literal notranslate"><span class="pre">self.failureException(msg)</span></code></a> lorsqu'une inégalité entre les deux premiers paramètres est détectée en fournissant éventuellement des informations utiles et expliquant l'inégalité en détail dans le message d'erreur.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<p>La liste des méthodes spécifiques utilisées automatiquement par <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> est résumée dans le tableau suivant.  Notez qu'il n'est généralement pas nécessaire d'invoquer ces méthodes directement.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 49%" />
<col style="width: 35%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Méthode</p></th>
<th class="head"><p>Utilisé pour comparer</p></th>
<th class="head"><p>Disponible en</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>chaînes</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSequenceEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>séquences</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertListEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>listes</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTupleEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><em>n</em>-uplets</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertSetEqual" title="unittest.TestCase.assertSetEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSetEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><em>sets</em> ou <em>frozensets</em></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>dictionnaires</p></td>
<td><p>3.1</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertMultiLineEqual">
<span class="sig-name descname"><span class="pre">assertMultiLineEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertMultiLineEqual" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que la chaîne sur plusieurs lignes <em>first</em> est égale à la chaîne <em>second</em>. Si les deux chaînes de caractères ne sont pas égales, un <em>diff</em> mettant en évidence les différences est inclus dans le message d'erreur. Cette méthode est utilisée par défaut pour comparer les chaînes avec <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertSequenceEqual">
<span class="sig-name descname"><span class="pre">assertSequenceEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertSequenceEqual" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que deux séquences sont égales. Si un <em>seq_type</em> est fourni, <em>first</em> et <em>second</em> doivent tous deux être des instances de <em>seq_type</em> ou un échec est levé. Si les séquences sont différentes, un message d'erreur indiquant la différence entre les deux est généré.</p>
<p>Cette méthode n'est pas appelée directement par <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>, mais sert à implémenter <a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertListEqual()</span></code></a> et <a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTupleEqual()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertListEqual">
<span class="sig-name descname"><span class="pre">assertListEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertListEqual" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertTupleEqual">
<span class="sig-name descname"><span class="pre">assertTupleEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertTupleEqual" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que deux listes ou deux <em>n</em>-uplets sont égaux.  Si ce n'est pas le cas, un message d'erreur qui ne montre que les différences entre les deux est généré.  Une erreur est également signalée si l'un ou l'autre des paramètres n'est pas du bon type. Ces méthodes sont utilisées par défaut pour comparer des listes ou des <em>n</em>-uplets avec <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertSetEqual">
<span class="sig-name descname"><span class="pre">assertSetEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertSetEqual" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que deux ensembles sont égaux. Si ce n'est pas le cas, un message d'erreur s'affiche et indique les différences entre les <em>sets</em>. Cette méthode est utilisée par défaut lors de la comparaison de <em>sets</em> ou de <em>frozensets</em> avec <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>.</p>
<p>Échoue si l'un des objets <em>first</em> ou <em>second</em> n'a pas de méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">set.difference()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertDictEqual">
<span class="sig-name descname"><span class="pre">assertDictEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertDictEqual" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie que deux dictionnaires sont égaux. Si ce n'est pas le cas, un message d'erreur qui montre les différences dans les dictionnaires est généré. Cette méthode est utilisée par défaut pour comparer les dictionnaires dans les appels à <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<p id="other-methods-and-attrs">Enfin, la classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> fournit les méthodes et attributs suivants :</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.fail">
<span class="sig-name descname"><span class="pre">fail</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.fail" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Indique un échec du test sans condition, avec <em>msg</em> ou <code class="docutils literal notranslate"><span class="pre">None</span></code> pour le message d'erreur.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestCase.failureException">
<span class="sig-name descname"><span class="pre">failureException</span></span><a class="headerlink" href="#unittest.TestCase.failureException" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cet attribut de classe donne l'exception levée par la méthode de test.  Si un <em>framework</em> de tests doit utiliser une exception spécialisée, probablement pour enrichir l'exception d'informations additionnels., il doit hériter de cette classe d'exception pour <em>bien fonctionner</em>  avec le <em>framework</em>. La valeur initiale de cet attribut est <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestCase.longMessage">
<span class="sig-name descname"><span class="pre">longMessage</span></span><a class="headerlink" href="#unittest.TestCase.longMessage" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cet attribut de classe détermine ce qui se passe lorsqu'un message d'échec personnalisé est passé en argument au paramètre <em>msg</em> à un appel <em>assertXYYY</em> qui échoue. <code class="docutils literal notranslate"><span class="pre">True</span></code> est la valeur par défaut. Dans ce cas, le message personnalisé est ajouté à la fin du message d'erreur standard. Lorsqu'il est réglé sur <code class="docutils literal notranslate"><span class="pre">False</span></code>, le message personnalisé remplace le message standard.</p>
<p>Le paramétrage de la classe peut être écrasé dans les méthodes de test individuelles en assignant un attribut d'instance, <em>self.longMessage</em>, à <code class="docutils literal notranslate"><span class="pre">True</span></code> ou <code class="docutils literal notranslate"><span class="pre">False</span></code> avant d'appeler les méthodes d'assertion.</p>
<p>Le réglage de la classe est réinitialisé avant chaque appel de test.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestCase.maxDiff">
<span class="sig-name descname"><span class="pre">maxDiff</span></span><a class="headerlink" href="#unittest.TestCase.maxDiff" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cet attribut contrôle la longueur maximale des <em>diffs</em> en sortie des méthodes qui génèrent des <em>diffs</em> en cas d'échec. La valeur par défaut est 80*8 caractères. Les méthodes d'assertions affectées par cet attribut sont <a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSequenceEqual()</span></code></a> (y compris toutes les méthodes de comparaison de séquences qui lui sont déléguées), <a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictEqual()</span></code></a> et <a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual()</span></code></a>.</p>
<p>Régler <code class="docutils literal notranslate"><span class="pre">maxDiff</span></code> sur <code class="docutils literal notranslate"><span class="pre">None</span></code> signifie qu'il n'y a pas de longueur maximale pour les <em>diffs</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
</dd></dl>

<p>Les <em>frameworks</em> de test peuvent utiliser les méthodes suivantes pour recueillir des informations sur le test :</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.countTestCases">
<span class="sig-name descname"><span class="pre">countTestCases</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.countTestCases" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie le nombre de tests représentés par cet objet test. Pour les instances de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>, c'est toujours <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.defaultTestResult">
<span class="sig-name descname"><span class="pre">defaultTestResult</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.defaultTestResult" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Retourne une instance de la classe de résultat de test qui doit être utilisée pour cette classe de cas de test (si aucune autre instance de résultat n'est fournie à la méthode <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>).</p>
<p>Pour les instances de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>, c'est toujours une instance de <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> ; les sous-classes de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> peuvent la remplacer au besoin.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.id">
<span class="sig-name descname"><span class="pre">id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.id" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Retourne une chaîne identifiant le cas de test spécifique. Il s'agit généralement du nom complet de la méthode de test, y compris le nom du module et de la classe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.shortDescription">
<span class="sig-name descname"><span class="pre">shortDescription</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.shortDescription" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie une description du test, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> si aucune description n'a été fournie. L'implémentation par défaut de cette méthode renvoie la première ligne de la <em>docstring</em> de la méthode de test, si disponible, ou <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.1: </span>En 3.1, ceci a été modifié pour ajouter le nom du test à la description courte, même en présence d'une <em>docstring</em>. Cela a causé des problèmes de compatibilité avec les extensions <em>unittest</em> et l'ajout du nom du test a été déplacé dans la classe <a class="reference internal" href="#unittest.TextTestResult" title="unittest.TextTestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestResult</span></code></a> dans Python 3.2.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.addCleanup">
<span class="sig-name descname"><span class="pre">addCleanup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addCleanup" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ajout d'une fonction à appeler après <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> pour nettoyer les ressources utilisées pendant le test. Les fonctions seront appelées dans l'ordre inverse de l'ordre dans lequel elles ont été ajoutées (<abbr title="dernier entré, premier sorti">LIFO</abbr>).  Elles sont appelées avec tous les arguments positionnels et arguments nommés passés à <a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a> quand elles sont ajoutées.</p>
<p>Si <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> échoue, cela signifie que <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> n'est pas appelé, alors que les fonctions de nettoyage ajoutées seront toujours appelées.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.enterContext">
<span class="sig-name descname"><span class="pre">enterContext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.enterContext" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Enter the supplied <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a>.  If successful, also
add its <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> method as a cleanup function by
<a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a> and return the result of the
<a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> method.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.doCleanups">
<span class="sig-name descname"><span class="pre">doCleanups</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.doCleanups" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette méthode est appelée sans conditions après <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a>, ou après <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> si <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> lève une exception.</p>
<p>Cette méthode est chargée d'appeler toutes les fonctions de nettoyage ajoutées par <a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a>. Si vous avez besoin de fonctions de nettoyage à appeler <em>avant</em> l'appel à <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> alors vous pouvez appeler <a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanups()</span></code></a> vous-même.</p>
<p><a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanups()</span></code></a> extrait les méthodes de la pile des fonctions de nettoyage une à la fois, de sorte qu'elles peuvent être appelées à tout moment.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.addClassCleanup">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">addClassCleanup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addClassCleanup" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ajout d'une fonction à appeler après <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> pour nettoyer les ressources utilisées par la classe test. Les fonctions sont appelées dans l'ordre inverse de l'ordre dans lequel elles ont été ajoutées (<abbr title="dernier entré, premier sorti">LIFO</abbr>). Elles sont appelées avec tous les arguments positionnels et nommés passés à <a class="reference internal" href="#unittest.TestCase.addClassCleanup" title="unittest.TestCase.addClassCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addClassCleanup()</span></code></a> quand elles sont ajoutées.</p>
<p>Si <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> échoue, impliquant que <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> n'est pas appelé, alors les fonctions de nettoyage ajoutées sont quand même appelées.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.enterClassContext">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enterClassContext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.enterClassContext" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Enter the supplied <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a>.  If successful, also
add its <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> method as a cleanup function by
<a class="reference internal" href="#unittest.TestCase.addClassCleanup" title="unittest.TestCase.addClassCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addClassCleanup()</span></code></a> and return the result of the
<a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> method.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.doClassCleanups">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">doClassCleanups</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.doClassCleanups" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette méthode est appelée sans conditions après <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a>, ou après <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> si <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> lève une exception.</p>
<p>Cette méthode est chargée d'appeler toutes les fonctions de nettoyage ajoutées par <a class="reference internal" href="#unittest.TestCase.addClassCleanup" title="unittest.TestCase.addClassCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addClassCleanup()</span></code></a>. Si vous avez besoin de fonctions de nettoyage à appeler <em>avant</em> l'appel à <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> alors vous pouvez appeler <a class="reference internal" href="#unittest.TestCase.doClassCleanups" title="unittest.TestCase.doClassCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doClassCleanups()</span></code></a> vous-même.</p>
<p><a class="reference internal" href="#unittest.TestCase.doClassCleanups" title="unittest.TestCase.doClassCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doClassCleanups()</span></code></a> extrait les méthodes de la pile des fonctions de nettoyage une à la fois, de sorte qu'elles peuvent être appelées à tout moment.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.8.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="unittest.IsolatedAsyncioTestCase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">IsolatedAsyncioTestCase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette classe fournit une API similaire à <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> et accepte aussi les coroutines en tant que fonctions de test.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.8.</span></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.IsolatedAsyncioTestCase.asyncSetUp">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">asyncSetUp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.asyncSetUp" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Méthode appelée pour réaliser la mise en place du test. Celle-ci est exécutée après <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code>. Elle est exécutée immédiatement avant l'appel de la méthode de test ; à l'exception de <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> ou <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>, toute exception levée par cette méthode est considérée comme une erreur et non pas comme un échec du test. L'implémentation par défaut ne fait rien.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.IsolatedAsyncioTestCase.asyncTearDown">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">asyncTearDown</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.asyncTearDown" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Méthode appelée immédiatement après l'appel de la méthode de test et l'enregistrement du résultat. Elle est appelée avant <code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code>. Elle est appelée même si la méthode de test a levé une exception. De fait, l'implémentation d'une sous-classe doit être faite avec précaution si vous vérifiez l'état interne de la classe. Toute exception, autre que <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> ou <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>, levée par cette méthode est considérée comme une erreur supplémentaire plutôt que comme un échec du test (augmentant ainsi le nombre total des erreurs signalées). Cette méthode est appelée uniquement si l'exécution de <a class="reference internal" href="#unittest.IsolatedAsyncioTestCase.asyncSetUp" title="unittest.IsolatedAsyncioTestCase.asyncSetUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncSetUp()</span></code></a> est réussie quel que soit le résultat de la méthode de test. L'implémentation par défaut ne fait rien.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.IsolatedAsyncioTestCase.addAsyncCleanup">
<span class="sig-name descname"><span class="pre">addAsyncCleanup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.addAsyncCleanup" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette méthode accepte une coroutine qui peut être utilisée comme fonction de nettoyage.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.IsolatedAsyncioTestCase.enterAsyncContext">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">enterAsyncContext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.enterAsyncContext" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Enter the supplied <a class="reference internal" href="../glossary.html#term-asynchronous-context-manager"><span class="xref std std-term">asynchronous context manager</span></a>.  If successful,
also add its <a class="reference internal" href="../reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a> method as a cleanup function by
<a class="reference internal" href="#unittest.IsolatedAsyncioTestCase.addAsyncCleanup" title="unittest.IsolatedAsyncioTestCase.addAsyncCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addAsyncCleanup()</span></code></a> and return the result of the
<a class="reference internal" href="../reference/datamodel.html#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> method.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.IsolatedAsyncioTestCase.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.run" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Configure une nouvelle boucle d'évènements pour exécuter le test, en collectant le résultat dans l'objet <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> passé comme <em>result</em>. Si <em>result</em> est omis ou vaut <code class="docutils literal notranslate"><span class="pre">None</span></code>, un objet temporaire de résultat est créé (en appelant la méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">defaultTestResult()</span></code>) et utilisé. L'objet résultat est renvoyé à l'appelant de <a class="reference internal" href="#unittest.IsolatedAsyncioTestCase.run" title="unittest.IsolatedAsyncioTestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>. À la fin du test, toutes les taches de la boucle d’événements sont annulées.</p>
</dd></dl>

<p>Exemple illustrant l'ordre :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">IsolatedAsyncioTestCase</span>

<span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">IsolatedAsyncioTestCase</span><span class="p">):</span>


    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;setUp&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncSetUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span> <span class="o">=</span> <span class="k">await</span> <span class="n">AsyncConnection</span><span class="p">()</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;asyncSetUp&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">test_response</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;test_response&quot;</span><span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;https://example.com&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addAsyncCleanup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_cleanup</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;tearDown&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncTearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;asyncTearDown&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;cleanup&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>Après avoir lancé les tests, <code class="docutils literal notranslate"><span class="pre">events</span></code> contiendrait <code class="docutils literal notranslate"><span class="pre">[&quot;setUp&quot;,</span> <span class="pre">&quot;asyncSetUp&quot;,</span> <span class="pre">&quot;test_response&quot;,</span> <span class="pre">&quot;asyncTearDown&quot;,</span> <span class="pre">&quot;tearDown&quot;,</span> <span class="pre">&quot;cleanup&quot;]</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="unittest.FunctionTestCase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">FunctionTestCase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">testFunc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">setUp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tearDown</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">description</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.FunctionTestCase" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette classe implémente la partie de l'interface <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> qui permet au lanceur de test de piloter le scénario de test, mais ne fournit pas les méthodes que le code test peut utiliser pour vérifier et signaler les erreurs. Ceci est utilisé pour créer des scénario de test utilisant du code de test existant afin de faciliter l'intégration dans un <em>framework</em> de test basé sur <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>.</p>
</dd></dl>

</section>
<section id="grouping-tests">
<span id="testsuite-objects"></span><h3>Regroupement des tests<a class="headerlink" href="#grouping-tests" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="unittest.TestSuite">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">TestSuite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tests</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette classe représente une agrégation de cas de test individuels et de suites de tests. La classe présente l'interface requise par le lanceur de test pour être exécutée comme tout autre cas de test. L'exécution d'une instance de <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> est identique à l'itération sur la suite, en exécutant chaque test indépendamment.</p>
<p>Si <em>tests</em> est fourni, il doit s'agir d'un itérable de cas de test individuels ou d'autres suites de test qui seront utilisés pour construire la suite initial. Des méthodes supplémentaires sont fournies pour ajouter ultérieurement des cas de test et des suites à la collection.</p>
<p>Les objets <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> se comportent comme les objets <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>, sauf qu'ils n'implémentent pas réellement un test. Au lieu de cela, ils sont utilisés pour regrouper les tests en groupes de tests qui doivent être exécutés ensemble. Des méthodes supplémentaires sont disponibles pour ajouter des tests aux instances de <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> :</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestSuite.addTest">
<span class="sig-name descname"><span class="pre">addTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.addTest" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ajouter un objet <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> ou <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> à la suite de tests.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestSuite.addTests">
<span class="sig-name descname"><span class="pre">addTests</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tests</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.addTests" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ajouter tous les tests d'un itérable d'instances de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> et de <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> à cette suite de tests.</p>
<p>C'est l'équivalent d'une itération sur <em>tests</em>, appelant <a class="reference internal" href="#unittest.TestSuite.addTest" title="unittest.TestSuite.addTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTest()</span></code></a> pour chaque élément.</p>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> partage les méthodes suivantes avec <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> :</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestSuite.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.run" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Exécute les tests associés à cette suite, en collectant le résultat dans l'objet de résultat de test passé par <em>result</em>.  Remarquer que contrairement à <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.run()</span></code></a>, <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a> nécessite que l'objet résultat soit passé.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestSuite.debug">
<span class="sig-name descname"><span class="pre">debug</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.debug" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Exécute les tests associés à cette suite sans collecter le résultat. Ceci permet aux exceptions levées par le test d'être propagées à l'appelant et peut être utilisé pour exécuter des tests sous un débogueur.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestSuite.countTestCases">
<span class="sig-name descname"><span class="pre">countTestCases</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.countTestCases" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie le nombre de tests représentés par cet objet de test, y compris tous les tests individuels et les sous-suites.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestSuite.__iter__">
<span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.__iter__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Les tests groupés par une classe <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> sont toujours accessibles par itération. Les sous-classes peuvent fournir paresseusement des tests en surchargeant <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>. Notez que cette méthode peut être appelée plusieurs fois sur une même suite (par exemple lors du comptage des tests ou de la comparaison pour l'égalité) et que les tests retournés par itérations répétées avant <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a> doivent être les mêmes pour chaque itération. Après <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a>, les appelants ne devraient pas se fier aux tests retournés par cette méthode à moins qu'ils n'utilisent une sous-classe qui remplace <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite._removeTestAtIndex()</span></code> pour préserver les références des tests.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.2: </span>Dans les versions précédentes, la classe <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> accédait aux tests directement plutôt que par itération, donc surcharger la méthode <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> n'était pas suffisante pour fournir les tests.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.4: </span>Dans les versions précédentes, la classe <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> contenait des références à chaque <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> après l'appel à <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a>. Les sous-classes peuvent restaurer ce comportement en surchargeant <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite._removeTestAtIndex()</span></code>.</p>
</div>
</dd></dl>

<p>Dans l'utilisation typique de l'objet <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>, la méthode <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> est invoquée par une classe <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code> plutôt que par le système de test de l'utilisateur.</p>
</dd></dl>

</section>
<section id="loading-and-running-tests">
<h3>Chargement et exécution des tests<a class="headerlink" href="#loading-and-running-tests" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="unittest.TestLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">TestLoader</span></span><a class="headerlink" href="#unittest.TestLoader" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>La classe <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> est utilisée pour créer des suites de tests à partir de classes et de modules. Normalement, il n'est pas nécessaire de créer une instance de cette classe ; le module <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> fournit une instance qui peut être partagée comme <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code class="xref py py-data docutils literal notranslate"><span class="pre">unittest.defaultTestLoader</span></code></a>. L'utilisation d'une sous-classe ou d'une instance permet cependant de personnaliser certaines propriétés configurables.</p>
<p>Les objets de la classe <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> ont les attributs suivants :</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestLoader.errors">
<span class="sig-name descname"><span class="pre">errors</span></span><a class="headerlink" href="#unittest.TestLoader.errors" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>A list of the non-fatal errors encountered while loading tests. Not reset
by the loader at any point. Fatal errors are signalled by the relevant
method raising an exception to the caller. Non-fatal errors are also
indicated by a synthetic test that will raise the original error when
run.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.5.</span></p>
</div>
</dd></dl>

<p>Les objets de la classe <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> ont les attributs suivants :</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestLoader.loadTestsFromTestCase">
<span class="sig-name descname"><span class="pre">loadTestsFromTestCase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">testCaseClass</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromTestCase" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie une suite de tous les cas de test contenus dans la classe <code class="xref py py-class docutils literal notranslate"><span class="pre">TestCaseClass</span></code>dérivée de <code class="xref py py-class docutils literal notranslate"><span class="pre">testCase</span></code>.</p>
<p>Une instance de cas de test est créée pour chaque méthode nommée par <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a>. Par défaut, ce sont les noms des méthodes commençant par &quot;test&quot;. Si <code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestTestCaseNames()</span></code> ne renvoie aucune méthode, mais que la méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">runTest()</span></code> est implémentée, un seul cas de test est créé pour cette méthode à la place.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestLoader.loadTestsFromModule">
<span class="sig-name descname"><span class="pre">loadTestsFromModule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pattern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromModule" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie une suite de tous les cas de test contenus dans le module donné. Cette méthode recherche <em>module</em> pour les classes dérivées de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> et crée une instance de la classe pour chaque méthode de test définie pour cette classe.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Bien que l'utilisation d'une hiérarchie de classes <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> (les classes dérivées de <em>TestCase</em>) peut être un moyen pratique de partager des <em>fixtures</em> et des fonctions utilitaires, définir une méthode de test pour des classes de base non destinées à être directement instanciée ne marche pas bien avec cette méthode. Cela peut toutefois s'avérer utile lorsque les <em>fixtures</em> sont différentes et définies dans des sous-classes.</p>
</div>
<p>Si un module fournit une fonction <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>, il est appelé pour charger les tests. Cela permet aux modules de personnaliser le chargement des tests. C'est le protocole <a class="reference internal" href="#load-tests-protocol">load_tests protocol</a>.  L'argument <em>pattern</em> est passé comme troisième argument à <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.2: </span>Ajout de la prise en charge de <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>Support for a keyword-only argument <em>pattern</em> has been added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.12: </span>The undocumented and unofficial <em>use_load_tests</em> parameter has been
removed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestLoader.loadTestsFromName">
<span class="sig-name descname"><span class="pre">loadTestsFromName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">module</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromName" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie une suite de tous les cas de test en fonction d'un spécificateur de chaîne de caractères.</p>
<p>Le spécificateur <em>name</em> est un &quot;nom pointillé&quot; qui peut être résolu soit par un module, une classe de cas de test, une méthode de test dans une classe de cas de test, une instance de <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>, ou un objet appelable qui retourne une instance de classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> ou de classe <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>. Ces contrôles sont appliqués dans l'ordre indiqué ici, c'est-à-dire qu'une méthode sur une classe de cas de test possible sera choisie comme &quot;méthode de test dans une classe de cas de test&quot;, plutôt que comme &quot;un objet appelable&quot;.</p>
<p>Par exemple, si vous avez un module <code class="xref py py-mod docutils literal notranslate"><span class="pre">SampleTests</span></code> contenant une classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> (classe dérivée de la classe <code class="xref py py-class docutils literal notranslate"><span class="pre">SampleTestCase</span></code>) avec trois méthodes de test (<code class="xref py py-meth docutils literal notranslate"><span class="pre">test_one()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_two()</span></code> et <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_three()</span></code>), l'élément spécificateur <code class="docutils literal notranslate"><span class="pre">SampleTests.sampleTestCase</span></code> renvoie une suite qui va exécuter les trois méthodes de tests. L'utilisation du spécificateur <code class="docutils literal notranslate"><span class="pre">SampleTests.SampleTestCase.test_two</span></code> permettrait de retourner une suite de tests qui ne lancerait que la méthode test <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_two()</span></code>. Le spécificateur peut se référer à des modules et packages qui n'ont pas été importés. Ils seront importés par un effet de bord.</p>
<p>La méthode résout facultativement <em>name</em> relatif au <em>module</em> donné.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>Si une <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> ou <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> se produit pendant la traversée de <em>name</em>, un test synthétique qui enrichie l'erreur produite lors de l'exécution est renvoyé. Ces erreurs sont incluses dans les erreurs accumulées par <em>self.errors</em>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestLoader.loadTestsFromNames">
<span class="sig-name descname"><span class="pre">loadTestsFromNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">module</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromNames" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Similaire à <a class="reference internal" href="#unittest.TestLoader.loadTestsFromName" title="unittest.TestLoader.loadTestsFromName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFromName()</span></code></a>, mais prend une séquence de noms plutôt qu'un seul nom.  La valeur renvoyée est une suite de tests qui gère tous les tests définis pour chaque nom.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestLoader.getTestCaseNames">
<span class="sig-name descname"><span class="pre">getTestCaseNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">testCaseClass</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.getTestCaseNames" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie une séquence triée de noms de méthodes trouvés dans <em>testCaseClass</em> ; ceci doit être une sous-classe de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestLoader.discover">
<span class="sig-name descname"><span class="pre">discover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pattern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'test*.py'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_level_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.discover" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Trouve tous les modules de test en parcourant les sous-répertoires du répertoire de démarrage spécifié, et renvoie un objet <em>TestSuite</em> qui les contient. Seuls les fichiers de test qui correspondent à <em>pattern</em> sont chargés. Seuls les noms de modules qui sont importables (c'est-à-dire qui sont des identifiants Python valides) sont chargés.</p>
<p>Tous les modules de test doivent être importables depuis la racine du projet. Si le répertoire de démarrage n'est pas la racine, le répertoire racine doit être spécifié séparément.</p>
<p>Si l'importation d'un module échoue, par exemple en raison d'une erreur de syntaxe, celle-ci est alors enregistrée comme une erreur unique et la découverte se poursuit.  Si l'échec de l'importation est dû au fait que <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> est levé, il est enregistré comme un saut plutôt que comme un message d'erreur.</p>
<p>Si un paquet (un répertoire contenant un fichier nommé <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code>) est trouvé, le paquet est alors vérifié pour une fonction <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>. Si elle existe, elle s'appellera <code class="docutils literal notranslate"><span class="pre">package.load_tests(loader,</span> <span class="pre">tests,</span> <span class="pre">pattern)</span></code>. Le mécanisme de découverte de test prend soin de s'assurer qu'un paquet n'est vérifié qu'une seule fois au cours d'une invocation, même si la fonction <em>load_tests</em> appelle elle-même <code class="docutils literal notranslate"><span class="pre">loader.discover</span></code>.</p>
<p>Si <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> existe alors la découverte ne poursuit pas la récursion dans le paquet, <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> a la responsabilité de charger tous les tests dans le paquet.</p>
<p>Le motif n'est délibérément pas stocké en tant qu'attribut du chargeur afin que les paquets puissent continuer à être découverts eux-mêmes. <em>top_level_dir</em> est stocké de sorte que <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> n'a pas besoin de passer cet argument a <code class="docutils literal notranslate"><span class="pre">loader.</span> <span class="pre">discover()</span></code>.</p>
<p><em>start_dir</em> peut être un nom de module ainsi qu'un répertoire.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.4: </span>Les modules levant une exception <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> au moment de leur importation ne sont pas considérés comme des erreurs, et sont marqués à sauter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.4: </span><em>start_dir</em> peut être un <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">paquet-espace de nommage</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.4: </span>Les chemins sont classés avant d'être importés afin que l'ordre d'exécution soit toujours le même, même si le système de fichiers sous-jacent ne classe pas les fichiers par leur nom.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>Les paquets trouvés sont maintenant vérifiés pour <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> indépendamment du fait que leur chemin d'accès corresponde ou non à <em>pattern</em>, car il est impossible pour un nom de paquet de correspondre au motif par défaut.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span><em>start_dir</em> can not be a <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">namespace packages</span></a>.
It has been broken since Python 3.7 and Python 3.11 officially remove it.</p>
</div>
</dd></dl>

<p>Les attributs suivants d'une classe <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> peuvent être configurés soit par héritage, soit par affectation sur une instance :</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestLoader.testMethodPrefix">
<span class="sig-name descname"><span class="pre">testMethodPrefix</span></span><a class="headerlink" href="#unittest.TestLoader.testMethodPrefix" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Chaîne donnant le préfixe des noms de méthodes qui seront interprétés comme méthodes de test. La valeur par défaut est <code class="docutils literal notranslate"><span class="pre">'test'</span></code>.</p>
<p>Ceci affecte les méthodes <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a> et toutes les méthodes <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestLoader.sortTestMethodsUsing">
<span class="sig-name descname"><span class="pre">sortTestMethodsUsing</span></span><a class="headerlink" href="#unittest.TestLoader.sortTestMethodsUsing" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Fonction à utiliser pour comparer les noms de méthodes lors de leur tri dans les méthodes <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a> et toutes les méthodes <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestLoader.suiteClass">
<span class="sig-name descname"><span class="pre">suiteClass</span></span><a class="headerlink" href="#unittest.TestLoader.suiteClass" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Objet appelable qui construit une suite de tests à partir d'une liste de tests. Aucune méthode sur l'objet résultant n'est nécessaire.  La valeur par défaut est la classe <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>.</p>
<p>Cela affecte toutes les méthodes <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestLoader.testNamePatterns">
<span class="sig-name descname"><span class="pre">testNamePatterns</span></span><a class="headerlink" href="#unittest.TestLoader.testNamePatterns" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>List of Unix shell-style wildcard test name patterns that test methods
have to match to be included in test suites (see <code class="docutils literal notranslate"><span class="pre">-k</span></code> option).</p>
<p>If this attribute is not <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), all test methods to be
included in test suites must match one of the patterns in this list.
Note that matches are always performed using <a class="reference internal" href="fnmatch.html#fnmatch.fnmatchcase" title="fnmatch.fnmatchcase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fnmatch.fnmatchcase()</span></code></a>,
so unlike patterns passed to the <code class="docutils literal notranslate"><span class="pre">-k</span></code> option, simple substring patterns
will have to be converted using <code class="docutils literal notranslate"><span class="pre">*</span></code> wildcards.</p>
<p>Cela affecte toutes les méthodes <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="unittest.TestResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">TestResult</span></span><a class="headerlink" href="#unittest.TestResult" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette classe est utilisée pour compiler des informations sur les tests qui ont réussi et ceux qui ont échoué.</p>
<p>Un objet <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> stocke les résultats d'un ensemble de tests. Les classes <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> et <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> s'assurent que les résultats sont correctement enregistrés. Les auteurs du test n'ont pas à se soucier de l'enregistrement des résultats des tests.</p>
<p>Les cadriciels de test construits sur <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> peuvent nécessiter l'accès à l'objet <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> généré en exécutant un ensemble de tests à des fins de génération de comptes-rendu. Une instance de <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> est alors renvoyée par la méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestRunner.run()</span></code> à cette fin.</p>
<p>Les instance de <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> ont les attributs suivants qui sont intéressant pour l'inspection des résultats de l'exécution d'un ensemble de tests :</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.errors">
<span class="sig-name descname"><span class="pre">errors</span></span><a class="headerlink" href="#unittest.TestResult.errors" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Une liste contenant des paires d'instances de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> et de chaînes de caractères contenant des traces de pile d'appels formatées. Chaque paire représente un test qui a levé une exception inattendue.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.failures">
<span class="sig-name descname"><span class="pre">failures</span></span><a class="headerlink" href="#unittest.TestResult.failures" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Une liste contenant des paires d'instances de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> et de chaînes de caractères contenant des traces de pile d'appels formatées. Chaque paire représente un test où un échec a été explicitement signalé en utilisant les méthodes <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.assert*()</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.skipped">
<span class="sig-name descname"><span class="pre">skipped</span></span><a class="headerlink" href="#unittest.TestResult.skipped" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Une liste contenant des paires d'instances de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> et de chaînes de caractères contenant la raison de l'omission du test.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.expectedFailures">
<span class="sig-name descname"><span class="pre">expectedFailures</span></span><a class="headerlink" href="#unittest.TestResult.expectedFailures" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Une liste contenant des paires d'instances <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> et de chaînes de caractères contenant des traces de pile d'appels formatées. Chaque paire représente un échec attendu ou une erreur du scénario de test.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.unexpectedSuccesses">
<span class="sig-name descname"><span class="pre">unexpectedSuccesses</span></span><a class="headerlink" href="#unittest.TestResult.unexpectedSuccesses" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Une liste contenant les instances <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> qui ont été marquées comme des échecs attendus, mais qui ont réussi.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.collectedDurations">
<span class="sig-name descname"><span class="pre">collectedDurations</span></span><a class="headerlink" href="#unittest.TestResult.collectedDurations" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>A list containing 2-tuples of test case names and floats
representing the elapsed time of each test which was run.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.shouldStop">
<span class="sig-name descname"><span class="pre">shouldStop</span></span><a class="headerlink" href="#unittest.TestResult.shouldStop" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>A positionner sur <code class="docutils literal notranslate"><span class="pre">True</span></code> quand l'exécution des tests doit être arrêter par <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.testsRun">
<span class="sig-name descname"><span class="pre">testsRun</span></span><a class="headerlink" href="#unittest.TestResult.testsRun" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Le nombre total de tests effectués jusqu'à présent.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.buffer">
<span class="sig-name descname"><span class="pre">buffer</span></span><a class="headerlink" href="#unittest.TestResult.buffer" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>S'il est défini sur <em>true</em>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> et <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> sont mis dans un tampon entre les appels de <a class="reference internal" href="#unittest.TestResult.startTest" title="unittest.TestResult.startTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startTest()</span></code></a> et <a class="reference internal" href="#unittest.TestResult.stopTest" title="unittest.TestResult.stopTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stopTest()</span></code></a>. La sortie collectée est répercutée sur les sorties <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> et <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> réels uniquement en cas d'échec ou d'erreur du test. Toute sortie est également attachée au message d'erreur.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.failfast">
<span class="sig-name descname"><span class="pre">failfast</span></span><a class="headerlink" href="#unittest.TestResult.failfast" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Si la valeur est <em>true</em> <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> est appelée lors de la première défaillance ou erreur, ce qui interrompt le test en cours d'exécution.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.tb_locals">
<span class="sig-name descname"><span class="pre">tb_locals</span></span><a class="headerlink" href="#unittest.TestResult.tb_locals" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Si la valeur est <em>true</em>, les variables locales sont affichées dans les traces d'appels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.wasSuccessful">
<span class="sig-name descname"><span class="pre">wasSuccessful</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.wasSuccessful" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie <code class="docutils literal notranslate"><span class="pre">True</span></code> si tous les tests effectués jusqu'à présent ont réussi, sinon renvoie <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.4: </span>Renvoie <code class="docutils literal notranslate"><span class="pre">False</span></code> s'il y a eu des <a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unexpectedSuccesses</span></code></a> dans les tests annotés avec le décorateur <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.stop">
<span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stop" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette méthode peut être appelée pour signaler que l'ensemble des tests en cours d'exécution doit être annulé en définissant l'attribut <a class="reference internal" href="#unittest.TestResult.shouldStop" title="unittest.TestResult.shouldStop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shouldStop</span></code></a> sur <code class="docutils literal notranslate"><span class="pre">True</span></code>. Les instances de <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code> doivent respecter ce signal et se terminer sans exécuter de tests supplémentaires.</p>
<p>Par exemple, cette fonctionnalité est utilisée par la classe <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestRunner</span></code></a> pour arrêter le cadriciel de test lorsque l'utilisateur lance une interruption clavier. Les outils interactifs qui fournissent des implémentations de <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code> peuvent l'utiliser de la même manière.</p>
</dd></dl>

<p>Les méthodes suivantes de la classe <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> sont utilisées pour maintenir les structures de données internes, et peuvent être étendues dans des sous-classes pour gérer des exigences supplémentaires en termes de compte-rendu.  Cette fonction est particulièrement utile pour créer des outils qui prennent en charge la génération de rapports interactifs pendant l'exécution des tests.</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.startTest">
<span class="sig-name descname"><span class="pre">startTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.startTest" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelé lorsque le scénario de test <em>test</em> est sur le point d'être exécuté.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.stopTest">
<span class="sig-name descname"><span class="pre">stopTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stopTest" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelé après l'exécution du cas de test <em>test</em>, quel qu'en soit le résultat.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.startTestRun">
<span class="sig-name descname"><span class="pre">startTestRun</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.startTestRun" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelé une fois avant l'exécution des tests.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.stopTestRun">
<span class="sig-name descname"><span class="pre">stopTestRun</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stopTestRun" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelé une fois après l'exécution des tests.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addError">
<span class="sig-name descname"><span class="pre">addError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addError" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelé lorsque le cas de test <em>test</em> soulève une exception inattendue. <em>err</em> est un <em>n</em>-uplet de la même forme que celle renvoyée par <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> : <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">valeur,</span> <span class="pre">traceback)</span></code>.</p>
<p>L'implémentation par défaut ajoute un <em>n</em>-uplet <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> à l'attribut <a class="reference internal" href="#unittest.TestResult.errors" title="unittest.TestResult.errors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errors</span></code></a> de l'instance, où <em>formatted_err</em> est une trace formatée à partir de <em>err</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addFailure">
<span class="sig-name descname"><span class="pre">addFailure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addFailure" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelé lorsque le cas de test <em>test</em> soulève une exception inattendue. <em>err</em> est un triplet de la même forme que celui renvoyé par <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> : <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">valeur,</span> <span class="pre">traceback)</span></code>.</p>
<p>L'implémentation par défaut ajoute un <em>n</em>-uplet <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> à l'attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">errors</span></code> de l'instance, où <em>formatted_err</em> est une trace formatée à partir de <em>err</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addSuccess">
<span class="sig-name descname"><span class="pre">addSuccess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSuccess" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelé lorsque le scénario de test <em>test</em> réussit.</p>
<p>L'implémentation par défaut ne fait rien.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addSkip">
<span class="sig-name descname"><span class="pre">addSkip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reason</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSkip" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelé lorsque le scénario de test <em>test</em> est ignoré. <em>raison</em> est la raison pour laquelle le test donné à été ignoré.</p>
<p>L'implémentation par défaut ajoute un <em>n</em>-uplet <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">raison)</span></code> à l'attribut <a class="reference internal" href="#unittest.TestResult.skipped" title="unittest.TestResult.skipped"><code class="xref py py-attr docutils literal notranslate"><span class="pre">skipped</span></code></a> de l'instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addExpectedFailure">
<span class="sig-name descname"><span class="pre">addExpectedFailure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addExpectedFailure" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelé lorsque le scénario de test <em>test</em> échoue (assertion ou exception), mais qui a été marqué avec le décorateur <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a>.</p>
<p>L'implémentation par défaut ajoute un <em>n</em>-uplet <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> à l'attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">errors</span></code> de l'instance, où <em>formatted_err</em> est une trace formatée à partir de <em>err</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addUnexpectedSuccess">
<span class="sig-name descname"><span class="pre">addUnexpectedSuccess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addUnexpectedSuccess" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelé lorsque le scénario de test <em>test</em> réussit, mais que ce scénario a été marqué avec le décorateur <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a>.</p>
<p>L'implémentation par défaut ajoute le test à l'attribut <a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unexpectedSuccesses</span></code></a> de l'instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addSubTest">
<span class="sig-name descname"><span class="pre">addSubTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subtest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outcome</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSubTest" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelé à la fin d'un sous-test. <em>test</em> est le cas de test correspondant à la méthode de test. <em>subtest</em> est une instance dérivée de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> décrivant le sous-test.</p>
<p>Si <em>outcome</em> est <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, le sous-test a réussi. Sinon, il a échoué avec une exception où <em>outcome</em> est un triplet du formulaire renvoyé par <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> : <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">valeur,</span> <span class="pre">traceback)</span></code>.</p>
<p>L'implémentation par défaut ne fait rien lorsque le résultat est un succès, et enregistre les échecs de sous-test comme des échecs normaux.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addDuration">
<span class="sig-name descname"><span class="pre">addDuration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elapsed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addDuration" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Called when the test case finishes.  <em>elapsed</em> is the time represented in
seconds, and it includes the execution of cleanup functions.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.12.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="unittest.TextTestResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">TextTestResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descriptions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">durations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestResult" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>A concrete implementation of <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> used by the
<a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestRunner</span></code></a>. Subclasses should accept <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> to ensure
compatibility as the interface changes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.12: </span>Added <em>durations</em> keyword argument.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="unittest.defaultTestLoader">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">defaultTestLoader</span></span><a class="headerlink" href="#unittest.defaultTestLoader" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Instance de la classe <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> destinée à être partagée. Si aucune personnalisation de la classe <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> n'est nécessaire, cette instance peut être utilisée au lieu de créer plusieurs fois de nouvelles instances.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="unittest.TextTestRunner">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">TextTestRunner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descriptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">failfast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resultclass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warnings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tb_locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">durations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Une implémentation de base d'un lanceur de test qui fournit les résultats dans un flux. Si <em>stream</em> est <code class="docutils literal notranslate"><span class="pre">None</span></code>, par défaut, <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> est utilisé comme flux de sortie. Cette classe a quelques paramètres configurables, mais est essentiellement très simple. Les applications graphiques qui exécutent des suites de tests doivent fournir des implémentations alternatives. De telles implémentations doivent accepter <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> car l'interface pour construire les lanceurs change lorsque des fonctionnalités sont ajoutées à <em>unittest</em>.</p>
<p>By default this runner shows <a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>,
<a class="reference internal" href="exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a>, <a class="reference internal" href="exceptions.html#ResourceWarning" title="ResourceWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ResourceWarning</span></code></a> and
<a class="reference internal" href="exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a> even if they are <a class="reference internal" href="warnings.html#warning-ignored"><span class="std std-ref">ignored by default</span></a>.  This behavior can
be overridden using Python's <code class="xref std std-option docutils literal notranslate"><span class="pre">-Wd</span></code> or <code class="xref std std-option docutils literal notranslate"><span class="pre">-Wa</span></code> options
(see <a class="reference internal" href="../using/cmdline.html#using-on-warnings"><span class="std std-ref">Warning control</span></a>) and leaving
<em>warnings</em> to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.2: </span>Added the <em>warnings</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.2: </span>Le flux par défaut est défini sur <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> au moment de l'instanciation plutôt qu'à l'importation.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>Added the <em>tb_locals</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.12: </span>Added the <em>durations</em> parameter.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TextTestRunner._makeResult">
<span class="sig-name descname"><span class="pre">_makeResult</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner._makeResult" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette méthode renvoie l'instance de <code class="docutils literal notranslate"><span class="pre">TestResult</span></code> utilisée par <a class="reference internal" href="#unittest.TextTestRunner.run" title="unittest.TextTestRunner.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>. Il n'est pas destiné à être appelé directement, mais peut être surchargée dans des sous-classes pour fournir un <code class="docutils literal notranslate"><span class="pre">TestResult</span></code> personnalisé.</p>
<p><code class="docutils literal notranslate"><span class="pre">_makeResult()</span></code> instancie la classe ou l'appelable passé dans le constructeur <code class="docutils literal notranslate"><span class="pre">TextTestRunner</span></code> comme argument <code class="docutils literal notranslate"><span class="pre">resultclass</span></code>. Il vaut par défaut <a class="reference internal" href="#unittest.TextTestResult" title="unittest.TextTestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestResult</span></code></a> si aucune <code class="docutils literal notranslate"><span class="pre">resultclass</span></code> n'est fournie. La classe de résultat est instanciée avec les arguments suivants :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">stream</span><span class="p">,</span> <span class="n">descriptions</span><span class="p">,</span> <span class="n">verbosity</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TextTestRunner.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner.run" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette méthode est l'interface publique principale du <code class="docutils literal notranslate"><span class="pre">TextTestRunner</span></code>. Cette méthode prend une instance <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> ou <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>. Un <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> est créé en appelant <a class="reference internal" href="#unittest.TextTestRunner._makeResult" title="unittest.TextTestRunner._makeResult"><code class="xref py py-func docutils literal notranslate"><span class="pre">_makeResult()</span></code></a> et le ou les tests sont exécutés et les résultats affichés sur la sortie standard.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.main">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">main</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'__main__'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">defaultTest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">argv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">testRunner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">testLoader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">unittest.defaultTestLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">failfast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">catchbreak</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warnings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.main" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Un programme en ligne de commande qui charge un ensemble de tests à partir du <em>module</em> et les exécute. L'utilisation principale est de rendre les modules de test facilement exécutables. L'utilisation la plus simple pour cette fonction est d'inclure la ligne suivante à la fin d'un script de test :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>Vous pouvez exécuter des tests avec des informations plus détaillées en utilisant l'option de verbosité :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>L'argument <em>defaultTest</em> est soit le nom d'un seul test, soit un itérable de noms de test à exécuter si aucun nom de test n'est spécifié via <em>argv</em>. Si aucun nom de test n'est fourni via <em>argv</em>, tous les tests trouvés dans <em>module</em> sont exécutés.</p>
<p>L'argument <em>argv</em> peut être une liste d'options passées au programme, le premier élément étant le nom du programme. S'il n'est pas spécifié ou vaut <code class="docutils literal notranslate"><span class="pre">None</span></code>, les valeurs de <a class="reference internal" href="sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a> sont utilisées.</p>
<p>The <em>testRunner</em> argument can either be a test runner class or an already
created instance of it. By default <code class="docutils literal notranslate"><span class="pre">main</span></code> calls <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> with
an exit code indicating success (0) or failure (1) of the tests run.
An exit code of 5 indicates that no tests were run.</p>
<p>L'argument <em>testLoader</em> doit être une instance de <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a>, et par défaut de <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code class="xref py py-data docutils literal notranslate"><span class="pre">defaultTestLoader</span></code></a>.</p>
<p>Les <code class="docutils literal notranslate"><span class="pre">main</span></code> sont utilisés à partir de l'interpréteur interactif en passant dans l'argument <code class="docutils literal notranslate"><span class="pre">exit=False</span></code>. Ceci affiche le résultat sur la sortie standard sans appeler <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">main</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="s1">&#39;test_module&#39;</span><span class="p">,</span> <span class="n">exit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Les paramètres <em>failfast</em>, <em>catchbreak</em> et <em>buffer</em> ont le même effet que la même option en ligne de commande <a class="reference internal" href="#command-line-options">command-line options</a>.</p>
<p>L'argument <em>warnings</em> spécifie l'argument <a class="reference internal" href="warnings.html#warning-filter"><span class="std std-ref">filtre d'avertissement</span></a> qui doit être utilisé lors de l'exécution des tests. Si elle n'est pas spécifiée, elle reste réglée sur <code class="docutils literal notranslate"><span class="pre">None</span></code> si une option <code class="xref std std-option docutils literal notranslate"><span class="pre">-W'</span></code> est passée à <strong class="program">python</strong> (voir <a class="reference internal" href="../using/cmdline.html#using-on-warnings"><span class="std std-ref">Utilisation des avertissements</span></a>), sinon elle sera réglée sur <code class="docutils literal notranslate"><span class="pre">'default'</span></code>.</p>
<p>L'appel de <code class="docutils literal notranslate"><span class="pre">main</span></code> renvoie en fait une instance de la classe <code class="docutils literal notranslate"><span class="pre">TestProgram</span></code>. Le résultat des tests effectués est enregistré sous l'attribut <code class="docutils literal notranslate"><span class="pre">result</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.1: </span>Ajout du paramètre <em>exit</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.2: </span>Ajout des paramètres <em>verbosity</em>, <em>failfast</em>, <em>catchbreak</em>, <em>buffer</em> et <em>warnings</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.4: </span>Le paramètre <em>defaultTest</em> a été modifié pour accepter également un itérable de noms de test.</p>
</div>
</dd></dl>

<section id="load-tests-protocol">
<h4>Protocole de chargement des tests (<em>load_tests Protocol</em>)<a class="headerlink" href="#load-tests-protocol" title="Lien permanent vers ce titre">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
<p>Les modules ou paquets peuvent personnaliser la façon dont les tests sont chargés à partir de ceux-ci pendant l'exécution des tests ou pendant la découverte de tests en implémentant une fonction appelée <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>.</p>
<p>Si un module de test définit <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> il est appelé par <a class="reference internal" href="#unittest.TestLoader.loadTestsFromModule" title="unittest.TestLoader.loadTestsFromModule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.loadTestsFromModule()</span></code></a> avec les arguments suivants :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>où <em>pattern</em> est passé directement depuis <code class="docutils literal notranslate"><span class="pre">loadTestsFromModule</span></code>. La valeur par défaut est <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Elle doit renvoyer une classe <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>.</p>
<p><em>loader</em> est l'instance de <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> qui effectue le chargement. <em>standard_tests</em> sont les tests qui sont chargés par défaut depuis le module. Il est courant que les modules de test veuillent seulement ajouter ou supprimer des tests de l'ensemble standard de tests. Le troisième argument est utilisé lors du chargement de paquets dans le cadre de la découverte de tests.</p>
<p>Une fonction typique de <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> qui charge les tests d'un ensemble spécifique de classes <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> peut ressembler à :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_cases</span> <span class="o">=</span> <span class="p">(</span><span class="n">TestCase1</span><span class="p">,</span> <span class="n">TestCase2</span><span class="p">,</span> <span class="n">TestCase3</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">TestSuite</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">test_class</span> <span class="ow">in</span> <span class="n">test_cases</span><span class="p">:</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">test_class</span><span class="p">)</span>
        <span class="n">suite</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>Si la découverte est lancée dans un répertoire contenant un paquet, soit à partir de la ligne de commande, soit en appelant <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.discover()</span></code></a>, alors le système recherche dans le fichier du paquet <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> la fonction <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>. Si cette fonction n'existe pas, la découverte se poursuit dans le paquet comme si c'était juste un autre répertoire. Sinon, la découverte des tests du paquet est effectuée par <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> qui est appelé avec les arguments suivants :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>Doit renvoyer une classe <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> représentant tous les tests du paquet. (<code class="docutils literal notranslate"><span class="pre">standard_tests</span></code> ne contient que les tests collectés dans le fichier <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code>).</p>
<p>Comme le motif est passé à <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>, le paquet est libre de continuer (et potentiellement de modifier) la découverte des tests. Une fonction « ne rien faire » <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> pour un paquet de test ressemblerait à :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="c1"># top level directory cached on loader instance</span>
    <span class="n">this_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
    <span class="n">package_tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">discover</span><span class="p">(</span><span class="n">start_dir</span><span class="o">=</span><span class="n">this_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">standard_tests</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">package_tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">standard_tests</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>La découverte de test ne vérifie plus que les noms de paquets correspondent à <em>pattern</em> en raison de l'impossibilité de trouver des noms de paquets correspondant au motif par défaut.</p>
</div>
</section>
</section>
</section>
<section id="class-and-module-fixtures">
<h2>Classes et modules d'aménagements des tests<a class="headerlink" href="#class-and-module-fixtures" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les classes et modules d'aménagements des tests sont implémentés dans <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>. Lorsque la suite de tests rencontre un test d'une nouvelle classe, alors <code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code> de la classe précédente (s'il y en a une) est appelé, suivi de <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code> de la nouvelle classe.</p>
<p>De même, si un test provient d'un module différent du test précédent, alors <code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code> du module précédent est exécuté, suivi par <code class="docutils literal notranslate"><span class="pre">setUpModule</span></code> du nouveau module.</p>
<p>Après que tous les tests ont été exécutés, les <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> et <code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code> finaux sont exécutés.</p>
<p>Notez que les aménagements de tests partagés ne fonctionnent pas bien avec de « potentielles » fonctions comme la parallélisation de test et qu'ils brisent l'isolation des tests. Ils doivent être utilisés avec parcimonie.</p>
<p>L'ordre par défaut des tests créés par les chargeurs de tests unitaires est de regrouper tous les tests des mêmes modules et classes. Cela à pour conséquence que <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> / <code class="docutils literal notranslate"><span class="pre">setUpModule</span></code> (etc) sont appelé exactement une fois par classe et module. Si vous rendez l'ordre aléatoire, de sorte que les tests de différents modules et classes soient adjacents les uns aux autres, alors ces fonctions d'aménagements partagées peuvent être appelées plusieurs fois dans un même test.</p>
<p>Les aménagements de tests partagés ne sont pas conçus pour fonctionner avec des suites dont la commande n'est pas standard. Une <code class="docutils literal notranslate"><span class="pre">BaseTestSuite</span></code> existe toujours pour les cadriciels qui ne veulent pas gérer les aménagements de tests partagés.</p>
<p>S'il y a des exceptions levées pendant l'une des fonctions d'aménagement de tests partagés, le test est signalé comme étant en erreur. Parce qu'il n'y a pas d'instance de test correspondante, un objet <code class="docutils literal notranslate"><span class="pre">_ErrorHolder</span></code> (qui a la même interface qu'une classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>) est créé pour représenter l'erreur. Si vous n'utilisez que le lanceur de test unitaire standard, ce détail n'a pas d'importance, mais si vous êtes un auteur de cadriciel de test, il peut être pertinent.</p>
<section id="setupclass-and-teardownclass">
<h3>Classes de mise en place (<em>setUpClass</em>) et de démantèlement des tests (<em>tearDownClass</em>)<a class="headerlink" href="#setupclass-and-teardownclass" title="Lien permanent vers ce titre">¶</a></h3>
<p>Elles doivent être implémentées en tant que méthodes de classe :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">createExpensiveConnectionObject</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
</pre></div>
</div>
<p>Si vous voulez que les classes de base <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> et <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> soient appelées, vous devez les appeler vous-même. Les implémentations dans <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> sont vides.</p>
<p>Si une exception est levée pendant l'exécution de <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> alors les tests dans la classe ne sont pas exécutés et la classe <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> n'est pas exécutée. Les classes ignorées n'auront pas d'exécution de <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> ou <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code>. Si l'exception est une exception <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> alors la classe est signalée comme ayant été ignorée au lieu d'être en échec.</p>
</section>
<section id="setupmodule-and-teardownmodule">
<h3>Module de mise en place (<em>setUpModule</em>) et de démantèlement des tests (<em>tearDownModule</em>)<a class="headerlink" href="#setupmodule-and-teardownmodule" title="Lien permanent vers ce titre">¶</a></h3>
<p>Elles doivent être implémentées en tant que fonctions :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setUpModule</span><span class="p">():</span>
    <span class="n">createConnection</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">tearDownModule</span><span class="p">():</span>
    <span class="n">closeConnection</span><span class="p">()</span>
</pre></div>
</div>
<p>Si une exception est levée pendant l'exécution de la fonction <code class="docutils literal notranslate"><span class="pre">setUpModule</span></code> alors aucun des tests du module ne sera exécuté et la fonction <code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code> ne sera pas exécutée. Si l'exception est une exception <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> alors le module est signalé comme ayant été ignoré au lieu d'être en échec.</p>
<p>Pour ajouter du code de nettoyage qui doit être exécuté même en cas d'exception, utilisez <code class="docutils literal notranslate"><span class="pre">addModuleCleanup</span></code> :</p>
<dl class="py function">
<dt class="sig sig-object py" id="unittest.addModuleCleanup">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">addModuleCleanup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.addModuleCleanup" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ajout d'une fonction à appeler après <code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownModule()</span></code> pour nettoyer les ressources utilisées pendant le test. Les fonctions seront appelées dans l'ordre inverse de l'ordre dans lequel elles ont été ajoutées (<abbr title="dernier entré, premier sorti">LIFO</abbr>). Elles sont appelées avec tous les arguments et arguments nommés passés à <a class="reference internal" href="#unittest.addModuleCleanup" title="unittest.addModuleCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addModuleCleanup()</span></code></a> quand elles sont ajoutées.</p>
<p>Si <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpModule()</span></code> échoue, impliquant que <code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownModule()</span></code> n'est pas appelée, alors les fonctions de nettoyage ajoutées sont quand même toujours appelées.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.enterModuleContext">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">enterModuleContext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.enterModuleContext" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Enter the supplied <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a>.  If successful, also
add its <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> method as a cleanup function by
<a class="reference internal" href="#unittest.addModuleCleanup" title="unittest.addModuleCleanup"><code class="xref py py-func docutils literal notranslate"><span class="pre">addModuleCleanup()</span></code></a> and return the result of the
<a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> method.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.doModuleCleanups">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">doModuleCleanups</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.doModuleCleanups" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette méthode est appelée sans conditions après <code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownModule()</span></code>, ou après <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpModule()</span></code> si <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpModule()</span></code> lève une exception.</p>
<p>It is responsible for calling all the cleanup functions added by
<a class="reference internal" href="#unittest.addModuleCleanup" title="unittest.addModuleCleanup"><code class="xref py py-func docutils literal notranslate"><span class="pre">addModuleCleanup()</span></code></a>. If you need cleanup functions to be called
<em>prior</em> to <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> then you can call
<a class="reference internal" href="#unittest.doModuleCleanups" title="unittest.doModuleCleanups"><code class="xref py py-func docutils literal notranslate"><span class="pre">doModuleCleanups()</span></code></a> yourself.</p>
<p><a class="reference internal" href="#unittest.doModuleCleanups" title="unittest.doModuleCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doModuleCleanups()</span></code></a> extrait les méthodes de la pile des fonctions de nettoyage une à la fois, de sorte qu'elles peuvent être appelées à tout moment.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.8.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="signal-handling">
<h2>Traitement des signaux<a class="headerlink" href="#signal-handling" title="Lien permanent vers ce titre">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.2.</span></p>
</div>
<p>L'option <a class="reference internal" href="#cmdoption-unittest-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c/--catch</span></code></a> en ligne de commande pour <em>unittest</em>, ainsi que le paramètre <code class="docutils literal notranslate"><span class="pre">catchbreak</span></code> vers <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a>, permettent une utilisation simplifiée du contrôle-C pendant un test. Avec l'activation de <code class="docutils literal notranslate"><span class="pre">catchbreak</span></code>, l'utilisation du contrôle-C permet de terminer le test en cours d'exécution, et le test se termine et rapporte tous les résultats obtenus jusqu'à présent. Un deuxième contrôle-C lève une exception classique <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>.</p>
<p>Le gestionnaire du signal <em>contrôle-C</em> tente de rester compatible avec le code ou les tests qui installent leur propre gestionnaire <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a>. Si le gestionnaire <code class="docutils literal notranslate"><span class="pre">unittest</span></code> est appelé mais <em>n'est pas</em> le gestionnaire installé <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a>, c'est-à-dire qu'il a été remplacé par le système sous test et délégué, alors il appelle le gestionnaire par défaut. C'est normalement le comportement attendu par un code qui remplace un gestionnaire installé et lui délègue. Pour les tests individuels qui ont besoin que le signal <em>contrôle-C</em> &quot;<em>unittest</em>&quot; soit désactivée, le décorateur <a class="reference internal" href="#unittest.removeHandler" title="unittest.removeHandler"><code class="xref py py-func docutils literal notranslate"><span class="pre">removeHandler()</span></code></a> peut être utilisé.</p>
<p>Il existe quelques fonctions de support pour les auteurs de cadriciel afin d'activer la fonctionnalité  de gestion des <em>contrôle-C</em> dans les cadriciels de test.</p>
<dl class="py function">
<dt class="sig sig-object py" id="unittest.installHandler">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">installHandler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.installHandler" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Installe le gestionnaire <em>contrôle-c</em>. Quand un <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a> est reçu (généralement en réponse à l'utilisateur appuyant sur <em>contrôle-c</em>) tous les résultats enregistrés vont appeler la méthode <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.registerResult">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">registerResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.registerResult" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Enregistre un objet <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> pour la gestion du <em>contrôle-C</em>. L'enregistrement d'un résultat stocke une référence faible sur celui-ci, de sorte qu'il n'empêche pas que le résultat soit collecté par le ramasse-miette.</p>
<p>L'enregistrement d'un objet <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> n'a pas d'effets de bord si la gestion du <em>contrôle-c</em> n'est pas activée, donc les cadriciels de test peuvent enregistrer sans condition tous les résultats qu'ils créent indépendamment du fait que la gestion soit activée ou non.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.removeResult">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">removeResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.removeResult" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Supprime un résultat enregistré. Une fois qu'un résultat a été supprimé, <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> n'est plus appelé sur cet objet résultat en réponse à un <em>contrôle-c</em>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.removeHandler">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">removeHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.removeHandler" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Lorsqu'elle est appelée sans arguments, cette fonction supprime le gestionnaire <em>contrôle-c</em> s'il a été installé. Cette fonction peut également être utilisée comme décorateur de test pour supprimer temporairement le gestionnaire pendant l'exécution du test :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@unittest</span><span class="o">.</span><span class="n">removeHandler</span>
<span class="k">def</span> <span class="nf">test_signal_handling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> — <em>Framework</em> de tests unitaires</a><ul>
<li><a class="reference internal" href="#basic-example">Exemple basique</a></li>
<li><a class="reference internal" href="#command-line-interface">Interface en ligne de commande</a><ul>
<li><a class="reference internal" href="#command-line-options">Options de la ligne de commande</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-discovery">Découverte des tests</a></li>
<li><a class="reference internal" href="#organizing-test-code">Organiser le code de test</a></li>
<li><a class="reference internal" href="#re-using-old-test-code">Réutilisation d'ancien code de test</a></li>
<li><a class="reference internal" href="#skipping-tests-and-expected-failures">Ignorer des tests et des erreurs prévisibles</a></li>
<li><a class="reference internal" href="#distinguishing-test-iterations-using-subtests">Distinguer les itérations de test à l'aide de sous-tests</a></li>
<li><a class="reference internal" href="#classes-and-functions">Classes et fonctions</a><ul>
<li><a class="reference internal" href="#test-cases">Scénarios de tests</a></li>
<li><a class="reference internal" href="#grouping-tests">Regroupement des tests</a></li>
<li><a class="reference internal" href="#loading-and-running-tests">Chargement et exécution des tests</a><ul>
<li><a class="reference internal" href="#load-tests-protocol">Protocole de chargement des tests (<em>load_tests Protocol</em>)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#class-and-module-fixtures">Classes et modules d'aménagements des tests</a><ul>
<li><a class="reference internal" href="#setupclass-and-teardownclass">Classes de mise en place (<em>setUpClass</em>) et de démantèlement des tests (<em>tearDownClass</em>)</a></li>
<li><a class="reference internal" href="#setupmodule-and-teardownmodule">Module de mise en place (<em>setUpModule</em>) et de démantèlement des tests (<em>tearDownModule</em>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#signal-handling">Traitement des signaux</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="doctest.html"
                          title="Chapitre précédent"><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code> — Exemples de tests interactifs en Python</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="unittest.mock.html"
                          title="Chapitre suivant"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.mock</span></code> — Bibliothèque d'objets simulacres</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/unittest.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="unittest.mock.html" title="unittest.mock — Bibliothèque d&#39;objets simulacres"
             >suivant</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="doctest — Exemples de tests interactifs en Python"
             >précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La bibliothèque standard</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >Outils de développement</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> — <em>Framework</em> de tests unitaires</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Mis à jour le oct. 26, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Créé en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>