
<!DOCTYPE html>

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="re — Opérations à base d'expressions rationnelles" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/re.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Code source : Lib/re/ Ce module fournit des opérations sur les expressions rationnelles similaires à celles que l'on trouve dans Perl. Les motifs, comme les chaînes, à analyser peuvent aussi bien ê..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Code source : Lib/re/ Ce module fournit des opérations sur les expressions rationnelles similaires à celles que l'on trouve dans Perl. Les motifs, comme les chaînes, à analyser peuvent aussi bien ê..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>re — Opérations à base d&#39;expressions rationnelles &#8212; Documentation Python 3.12.0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=b37c26da2f7529d09fe70b41c4b2133fe4931a90" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Recherchez dans Documentation Python 3.12.0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="À propos de ces documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="difflib — Utilitaires pour le calcul des deltas" href="difflib.html" />
    <link rel="prev" title="string — Opérations usuelles sur des chaînes" href="string.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/re.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" />
                <input type="submit" value="Go"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Opérations à base d'expressions rationnelles</a><ul>
<li><a class="reference internal" href="#regular-expression-syntax">Syntaxe des expressions rationnelles</a></li>
<li><a class="reference internal" href="#module-contents">Contenu du module</a><ul>
<li><a class="reference internal" href="#flags">Flags</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#exceptions">Exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regular-expression-objects">Objets d'expressions rationnelles</a></li>
<li><a class="reference internal" href="#match-objects">Objets de correspondance</a></li>
<li><a class="reference internal" href="#regular-expression-examples">Exemples d'expressions rationnelles</a><ul>
<li><a class="reference internal" href="#checking-for-a-pair">Rechercher une paire</a></li>
<li><a class="reference internal" href="#simulating-scanf">Simuler <em>scanf()</em></a></li>
<li><a class="reference internal" href="#search-vs-match">Comparaison de <em>search()</em> et <em>match()</em></a></li>
<li><a class="reference internal" href="#making-a-phonebook">Construire un répertoire téléphonique</a></li>
<li><a class="reference internal" href="#text-munging">Mélanger les lettres des mots</a></li>
<li><a class="reference internal" href="#finding-all-adverbs">Trouver tous les adverbes</a></li>
<li><a class="reference internal" href="#finding-all-adverbs-and-their-positions">Trouver tous les adverbes et leurs positions</a></li>
<li><a class="reference internal" href="#raw-string-notation">Notation brute de chaînes</a></li>
<li><a class="reference internal" href="#writing-a-tokenizer">Écrire un analyseur lexical</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="string.html"
                          title="Chapitre précédent"><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code> — Opérations usuelles sur des chaînes</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="difflib.html"
                          title="Chapitre suivant"><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code> — Utilitaires pour le calcul des deltas</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/re.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="difflib.html" title="difflib — Utilitaires pour le calcul des deltas"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="string.html" title="string — Opérations usuelles sur des chaînes"
             accesskey="P">précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La bibliothèque standard</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" accesskey="U">Services de Manipulation de Texte</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Opérations à base d'expressions rationnelles</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-re">
<span id="re-regular-expression-operations"></span><h1><a class="reference internal" href="#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> — Opérations à base d'expressions rationnelles<a class="headerlink" href="#module-re" title="Lien permanent vers ce titre">¶</a></h1>
<p><strong>Code source :</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/re/">Lib/re/</a></p>
<hr class="docutils" />
<p>Ce module fournit des opérations sur les expressions rationnelles similaires à celles que l'on trouve dans Perl.</p>
<p>Les motifs, comme les chaînes, à analyser peuvent aussi bien être des chaînes Unicode (<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) que des chaînes 8-bits (<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>). Cependant, les chaînes Unicode et 8-bits ne peuvent pas être mélangées : c’est à dire que vous ne pouvez pas analyser une chaîne Unicode avec un motif 8-bit, et inversement ; de même, lors d'une substitution, la chaîne de remplacement doit être du même type que le motif et la chaîne analysée.</p>
<p>Regular expressions use the backslash character (<code class="docutils literal notranslate"><span class="pre">'\'</span></code>) to indicate
special forms or to allow special characters to be used without invoking
their special meaning.  This collides with Python's usage of the same
character for the same purpose in string literals; for example, to match
a literal backslash, one might have to write <code class="docutils literal notranslate"><span class="pre">'\\\\'</span></code> as the pattern
string, because the regular expression must be <code class="docutils literal notranslate"><span class="pre">\\</span></code>, and each
backslash must be expressed as <code class="docutils literal notranslate"><span class="pre">\\</span></code> inside a regular Python string
literal. Also, please note that any invalid escape sequences in Python's
usage of the backslash in string literals now generate a <a class="reference internal" href="exceptions.html#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a>
and in the future this will become a <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>. This behaviour
will happen even if it is a valid escape sequence for a regular expression.</p>
<p>La solution est d'utiliser la notation des chaînes brutes en Python pour les expressions rationnelles ; Les <em>backslashs</em> ne provoquent aucun traitement spécifique dans les chaînes littérales préfixées par <code class="docutils literal notranslate"><span class="pre">'r'</span></code>. Ainsi, <code class="docutils literal notranslate"><span class="pre">r&quot;\n&quot;</span></code> est une chaîne de deux caractères contenant <code class="docutils literal notranslate"><span class="pre">'\'</span></code> et <code class="docutils literal notranslate"><span class="pre">'n'</span></code>, tandis que <code class="docutils literal notranslate"><span class="pre">&quot;\n&quot;</span></code> est une chaîne contenant un unique caractère : un saut de ligne. Généralement, les motifs seront exprimés en Python à l'aide de chaînes brutes.</p>
<p>Il est important de noter que la plupart des opérations sur les expressions rationnelles sont disponibles comme fonctions au niveau du module et comme méthodes des <a class="reference internal" href="#re-objects"><span class="std std-ref">expressions rationnelles compilées</span></a>. Les fonctions sont des raccourcis qui ne vous obligent pas à d'abord compiler un objet <em>regex</em>, mais auxquelles manquent certains paramètres de configuration fine.</p>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p>Le module tiers <a class="reference external" href="https://pypi.org/project/regex/">regex</a>, dont l'interface est compatible avec le module <a class="reference internal" href="#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> de la bibliothèque standard, mais offre des fonctionnalités additionnelles et une meilleure gestion de l'Unicode.</p>
</div>
<section id="regular-expression-syntax">
<span id="re-syntax"></span><h2>Syntaxe des expressions rationnelles<a class="headerlink" href="#regular-expression-syntax" title="Lien permanent vers ce titre">¶</a></h2>
<p>Une expression rationnelle (<em>regular expression</em> ou <em>RE</em>) spécifie un ensemble de chaînes de caractères qui lui correspondent ; les fonctions de ce module vous permettent de vérifier si une chaîne particulière correspond à une expression rationnelle donnée (ou si un expression rationnelle donnée correspond à une chaîne particulière, ce qui revient à la même chose).</p>
<p>Les expressions rationnelles peuvent être concaténées pour former de nouvelles expressions : si <em>A</em> et <em>B</em> sont deux expressions rationnelles, alors <em>AB</em> est aussi une expression rationnelle. En général, si une chaîne <em>p</em> valide <em>A</em> et qu'une autre chaîne <em>q</em> valide <em>B</em>, la chaîne <em>pq</em> validera AB. Cela est vrai tant que <em>A</em> et <em>B</em> ne contiennent pas d'opérations de priorité ; de conditions de frontière entre <em>A</em> et <em>B</em> ; ou de références vers des groupes numérotés. Ainsi, des expressions complexes peuvent facilement être construites depuis de plus simples expressions primitives comme celles décrites ici. Pour plus de détails sur la théorie et l'implémentation des expressions rationnelles, consultez le livre de Friedl <a class="reference internal" href="#frie09" id="id1"><span>[Frie09]</span></a>, ou à peu près n'importe quel livre dédié à la construction de compilateurs.</p>
<p>Une brève explication sur le format des expressions rationnelles suit. Pour de plus amples informations et une présentation plus simple, référez-vous au <a class="reference internal" href="../howto/regex.html#regex-howto"><span class="std std-ref">Guide des expressions régulières</span></a>.</p>
<p>Les expressions rationnelles peuvent contenir à la fois des caractères spéciaux et ordinaires. Les plus ordinaires, comme <code class="docutils literal notranslate"><span class="pre">'A'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'0'</span></code> sont les expressions rationnelles les plus simples : elles correspondent simplement à elles-mêmes.  Vous pouvez concaténer des caractères ordinaires, ainsi <code class="docutils literal notranslate"><span class="pre">last</span></code> correspond à la chaîne <code class="docutils literal notranslate"><span class="pre">'last'</span></code>. (Dans la suite de cette section, nous écrirons les expressions rationnelles dans <code class="docutils literal notranslate"><span class="pre">ce</span> <span class="pre">style</span> <span class="pre">spécifique</span></code>, généralement sans guillemets, et les chaînes à tester <code class="docutils literal notranslate"><span class="pre">'entourées</span> <span class="pre">de</span> <span class="pre">simples</span> <span class="pre">guillemets'</span></code>.)</p>
<p>Certains caractères, comme <code class="docutils literal notranslate"><span class="pre">'|'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'('</span></code>, sont spéciaux. Des caractères spéciaux peuvent aussi exister pour les classes de caractères ordinaires, ou affecter comment les expressions rationnelles autour d'eux seront interprétées.</p>
<p>Les caractères de répétition ou quantificateurs (<code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code>, etc.) ne peuvent être directement imbriqués. Cela empêche l'ambiguïté avec le suffixe modificateur non gourmand <code class="docutils literal notranslate"><span class="pre">?</span></code> et avec les autres modificateurs dans d'autres implémentations. Pour appliquer une seconde répétition à une première, des parenthèses peuvent être utilisées. Par exemple, l'expression <code class="docutils literal notranslate"><span class="pre">(?:a{6})*</span></code> valide toutes les chaînes composées d'un nombre de caractères <code class="docutils literal notranslate"><span class="pre">'a'</span></code> multiple de six.</p>
<p>Les caractères spéciaux sont :</p>
<dl class="simple" id="index-0">
<dt><code class="docutils literal notranslate"><span class="pre">.</span></code></dt><dd><p>(Point.) Dans le mode par défaut, il valide tout caractère à l'exception du saut de ligne. Si l'option <a class="reference internal" href="#re.DOTALL" title="re.DOTALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">DOTALL</span></code></a> a été spécifiée, il valide tout caractère, saut de ligne compris.</p>
</dd>
</dl>
<dl class="simple" id="index-1">
<dt><code class="docutils literal notranslate"><span class="pre">^</span></code></dt><dd><p>(Accent circonflexe.) Valide le début d'une chaîne de caractères, ainsi que ce qui suit chaque saut de ligne en mode <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a>.</p>
</dd>
</dl>
<dl class="simple" id="index-2">
<dt><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p>Valide la fin d'une chaîne de caractères, ou juste avant le saut de ligne à la fin de la chaîne, ainsi qu'avant chaque saut de ligne en mode <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a>. <code class="docutils literal notranslate"><span class="pre">foo</span></code> valide à la fois <em>foo</em> et <em>foobar</em>, tandis que l'expression rationnelle <code class="docutils literal notranslate"><span class="pre">foo$</span></code> ne correspond qu'à <code class="docutils literal notranslate"><span class="pre">'foo'</span></code>. Plus intéressant, chercher <code class="docutils literal notranslate"><span class="pre">foo.$</span></code> dans <code class="docutils literal notranslate"><span class="pre">'foo1\nfoo2\n'</span></code> trouve normalement <code class="docutils literal notranslate"><span class="pre">'foo2'</span></code>, mais <code class="docutils literal notranslate"><span class="pre">'foo1'</span></code> en mode <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> ; chercher un simple <code class="docutils literal notranslate"><span class="pre">$</span></code> dans <code class="docutils literal notranslate"><span class="pre">'foo\n'</span></code> trouvera deux correspondances (vides) : une juste avant le saut de ligne, et une à la fin de la chaîne.</p>
</dd>
</dl>
<dl class="simple" id="index-3">
<dt><code class="docutils literal notranslate"><span class="pre">*</span></code></dt><dd><p>Fait valider par l'expression rationnelle résultante 0 répétition ou plus de l'expression qui précède, avec autant de répétitions que possible. <code class="docutils literal notranslate"><span class="pre">ab*</span></code> validera 'a', 'ab' ou 'a' suivi de n'importe quel nombre de 'b'.</p>
</dd>
</dl>
<dl class="simple" id="index-4">
<dt><code class="docutils literal notranslate"><span class="pre">+</span></code></dt><dd><p>Fait valider par l'expression rationnelle résultante 1 répétition ou plus de l'expression qui précède. <code class="docutils literal notranslate"><span class="pre">ab+</span></code> validera 'a' suivi de n'importe quel nombre non nul de 'b' ; cela ne validera pas la chaîne 'a'.</p>
</dd>
</dl>
<dl class="simple" id="index-5">
<dt><code class="docutils literal notranslate"><span class="pre">?</span></code></dt><dd><p>Fait valider par l'expression rationnelle résultante 0 ou 1 répétition de l'expression qui précède. <code class="docutils literal notranslate"><span class="pre">ab?</span></code> correspondra à 'a' ou 'ab'.</p>
</dd>
</dl>
<dl class="simple" id="index-6">
<dt><code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">+?</span></code>, <code class="docutils literal notranslate"><span class="pre">??</span></code></dt><dd><p>Les quantificateurs <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code> et <code class="docutils literal notranslate"><span class="pre">'?'</span></code> sont tous <em class="dfn">greedy</em> (gourmands) ; ils valident autant de texte que possible.  Parfois ce comportement n'est pas désiré ; si l'expression rationnelle <code class="docutils literal notranslate"><span class="pre">&lt;.*&gt;</span></code> est testée avec la chaîne <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;</span> <span class="pre">b</span> <span class="pre">&lt;c&gt;'</span></code>, cela correspondra à la chaîne entière, et non juste à <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>.  Ajouter <code class="docutils literal notranslate"><span class="pre">?</span></code> derrière le quantificateur lui fait réaliser l'opération de façon <em class="dfn">non-greedy</em> (ou <em class="dfn">minimal</em>) ; le <em>moins</em> de caractères possibles seront validés.  Utiliser l'expression rationnelle <code class="docutils literal notranslate"><span class="pre">&lt;.*?&gt;</span></code> validera uniquement <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>.</p>
</dd>
</dl>
<dl id="index-7">
<dt><code class="docutils literal notranslate"><span class="pre">*+</span></code>, <code class="docutils literal notranslate"><span class="pre">++</span></code>, <code class="docutils literal notranslate"><span class="pre">?+</span></code></dt><dd><p>Like the <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'?'</span></code> quantifiers, those where <code class="docutils literal notranslate"><span class="pre">'+'</span></code> is
appended also match as many times as possible.
However, unlike the true greedy quantifiers, these do not allow
back-tracking when the expression following it fails to match.
These are known as <em class="dfn">possessive</em> quantifiers.
For example, <code class="docutils literal notranslate"><span class="pre">a*a</span></code> will match <code class="docutils literal notranslate"><span class="pre">'aaaa'</span></code> because the <code class="docutils literal notranslate"><span class="pre">a*</span></code> will match
all 4 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s, but, when the final <code class="docutils literal notranslate"><span class="pre">'a'</span></code> is encountered, the
expression is backtracked so that in the end the <code class="docutils literal notranslate"><span class="pre">a*</span></code> ends up matching
3 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s total, and the fourth <code class="docutils literal notranslate"><span class="pre">'a'</span></code> is matched by the final <code class="docutils literal notranslate"><span class="pre">'a'</span></code>.
However, when <code class="docutils literal notranslate"><span class="pre">a*+a</span></code> is used to match <code class="docutils literal notranslate"><span class="pre">'aaaa'</span></code>, the <code class="docutils literal notranslate"><span class="pre">a*+</span></code> will
match all 4 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, but when the final <code class="docutils literal notranslate"><span class="pre">'a'</span></code> fails to find any more
characters to match, the expression cannot be backtracked and will thus
fail to match.
<code class="docutils literal notranslate"><span class="pre">x*+</span></code>, <code class="docutils literal notranslate"><span class="pre">x++</span></code> and <code class="docutils literal notranslate"><span class="pre">x?+</span></code> are equivalent to <code class="docutils literal notranslate"><span class="pre">(?&gt;x*)</span></code>, <code class="docutils literal notranslate"><span class="pre">(?&gt;x+)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(?&gt;x?)</span></code> correspondingly.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.11.</span></p>
</div>
</dd>
</dl>
<dl id="index-8">
<dt><code class="docutils literal notranslate"><span class="pre">{m}</span></code></dt><dd><p>Spécifie qu'exactement <em>m</em> copies de l'expression rationnelle qui précède devront être validées ; un nombre plus faible de correspondances empêche l'expression entière de correspondre. Par exemple, <code class="docutils literal notranslate"><span class="pre">a{6}</span></code> correspondra exactement à six caractères <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, mais pas à cinq.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}</span></code></dt><dd><p>Fait valider par l'expression rationnelle résultante entre <em>m</em> et <em>n</em> répétitions de l'expression qui précède, cherchant à en valider le plus possible.  Par exemple, <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> validera entre 3 et 5 caractères <code class="docutils literal notranslate"><span class="pre">'a'</span></code>.  Omettre <em>m</em> revient à spécifier 0 comme borne inférieure, et omettre <em>n</em> à avoir une borne supérieure infinie.  Par exemple, <code class="docutils literal notranslate"><span class="pre">a{4,}b</span></code> correspondra à <code class="docutils literal notranslate"><span class="pre">'aaaab'</span></code> ou à un millier de caractères <code class="docutils literal notranslate"><span class="pre">'a'</span></code> suivis d'un <code class="docutils literal notranslate"><span class="pre">'b'</span></code>, mais pas à <code class="docutils literal notranslate"><span class="pre">'aaab'</span></code>. La virgule ne doit pas être omise, auquel cas le modificateur serait confondu avec la forme décrite précédemment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}?</span></code></dt><dd><p>Fait valider l'expression rationnelle résultante entre <em>m</em> et <em>n</em> répétitions de l'expression qui précède, cherchant à en valider le moins possible. Il s'agit de la version non gourmande du précédent quantificateur. Par exemple, dans la chaîne de 6 caractères <code class="docutils literal notranslate"><span class="pre">'aaaaaa'</span></code>, <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> trouvera 5 caractères <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, alors que <code class="docutils literal notranslate"><span class="pre">a{3,5}?</span></code> n'en trouvera que 3.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}+</span></code></dt><dd><p>Causes the resulting RE to match from <em>m</em> to <em>n</em> repetitions of the
preceding RE, attempting to match as many repetitions as possible
<em>without</em> establishing any backtracking points.
This is the possessive version of the quantifier above.
For example, on the 6-character string <code class="docutils literal notranslate"><span class="pre">'aaaaaa'</span></code>, <code class="docutils literal notranslate"><span class="pre">a{3,5}+aa</span></code>
attempt to match 5 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> characters, then, requiring 2 more <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s,
will need more characters than available and thus fail, while
<code class="docutils literal notranslate"><span class="pre">a{3,5}aa</span></code> will match with <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> capturing 5, then 4 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s
by backtracking and then the final 2 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s are matched by the final
<code class="docutils literal notranslate"><span class="pre">aa</span></code> in the pattern.
<code class="docutils literal notranslate"><span class="pre">x{m,n}+</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">(?&gt;x{m,n})</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.11.</span></p>
</div>
</dd>
</dl>
<dl id="index-9">
<dt><code class="docutils literal notranslate"><span class="pre">\</span></code></dt><dd><p>Échappe les caractères spéciaux (permettant d’identifier des caractères comme <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'?'</span></code> et autres) ou signale une séquence spéciale ; les séquences spéciales sont décrites ci-dessous.</p>
<p>Si vous n'utilisez pas de chaînes brutes pour exprimer le motif, souvenez-vous que Python utilise aussi le <em>backslash</em> comme une séquence d'échappement dans les chaînes littérales ; si la séquence d'échappement n'est pas reconnue par l'interpréteur Python, le <em>backslash</em> et les caractères qui le suivent sont inclus dans la chaîne renvoyée. Cependant, si Python reconnait la séquence, le <em>backslash</em> doit être doublé (pour ne plus être reconnu). C'est assez compliqué et difficile à comprendre, c'est pourquoi il est hautement recommandé d'utiliser des chaînes brutes pour tout sauf les expressions les plus simples.</p>
</dd>
</dl>
<dl id="index-10">
<dt><code class="docutils literal notranslate"><span class="pre">[]</span></code></dt><dd><p>Utilisé pour indiquer un ensemble de caractères. Dans un ensemble :</p>
<ul class="simple">
<li><p>Les caractères peuvent être listés individuellement, e.g. <code class="docutils literal notranslate"><span class="pre">[amk]</span></code> correspondra à <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'k'</span></code>.</p></li>
</ul>
<ul class="simple" id="index-11">
<li><p>Des intervalles de caractères peuvent être indiqués en donnant deux caractères et les séparant par un <code class="docutils literal notranslate"><span class="pre">'-'</span></code>, par exemple <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> correspondra à toute lettre minuscule <em>ASCII</em>, <code class="docutils literal notranslate"><span class="pre">[0-5][0-9]</span></code> à tous nombres de deux chiffres entre <code class="docutils literal notranslate"><span class="pre">00</span></code> et <code class="docutils literal notranslate"><span class="pre">59</span></code>, et <code class="docutils literal notranslate"><span class="pre">[0-9A-Fa-f]</span></code> correspondra à n'importe quel chiffre hexadécimal.  Si <code class="docutils literal notranslate"><span class="pre">'-'</span></code> est échappé (<code class="docutils literal notranslate"><span class="pre">[a\-z]</span></code>) ou s'il est placé comme premier ou dernier caractère (e.g. <code class="docutils literal notranslate"><span class="pre">[-a]</span></code> ou <code class="docutils literal notranslate"><span class="pre">[a-]</span></code>), il correspondra à un <code class="docutils literal notranslate"><span class="pre">'-'</span></code> littéral.</p></li>
<li><p>Les caractères spéciaux perdent leur sens à l'intérieur des ensembles. Par exemple, <code class="docutils literal notranslate"><span class="pre">[(+*)]</span></code> validera chacun des caractères littéraux <code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, <code class="docutils literal notranslate"><span class="pre">'*'</span></code> ou <code class="docutils literal notranslate"><span class="pre">')'</span></code>.</p></li>
</ul>
<ul class="simple" id="index-12">
<li><p>Les classes de caractères telles que <code class="docutils literal notranslate"><span class="pre">\w</span></code> ou <code class="docutils literal notranslate"><span class="pre">\S</span></code> (définies ci-dessous) sont aussi acceptées à l'intérieur d'un ensemble, bien que les caractères correspondant dépendent de quel mode est actif entre <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> et <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a>.</p></li>
</ul>
<ul class="simple" id="index-13">
<li><p>Les caractères qui ne sont pas dans un intervalle peuvent être trouvés avec l'ensemble complémentaire (<em class="dfn">complementing</em>). Si le premier caractère de l'ensemble est <code class="docutils literal notranslate"><span class="pre">'^'</span></code>, tous les caractères qui <em>ne sont pas</em> dans l'ensemble seront validés. Par exemple, <code class="docutils literal notranslate"><span class="pre">[^5]</span></code> correspondra à tout caractère autre que <code class="docutils literal notranslate"><span class="pre">'5'</span></code> et <code class="docutils literal notranslate"><span class="pre">[^^]</span></code> validera n'importe quel caractère excepté <code class="docutils literal notranslate"><span class="pre">'^'</span></code>. <code class="docutils literal notranslate"><span class="pre">^</span></code> n'a pas de sens particulier s'il n'est pas le premier caractère de l'ensemble.</p></li>
<li><p>To match a literal <code class="docutils literal notranslate"><span class="pre">']'</span></code> inside a set, precede it with a backslash, or
place it at the beginning of the set.  For example, both <code class="docutils literal notranslate"><span class="pre">[()[\]{}]</span></code> and
<code class="docutils literal notranslate"><span class="pre">[]()[{}]</span></code> will match a right bracket, as well as left bracket, braces,
and parentheses.</p></li>
</ul>
<ul class="simple">
<li><p>La gestion des ensembles inclus l'un dans l'autre et les opérations d'ensemble comme dans <a class="reference external" href="https://unicode.org/reports/tr18/">Unicode Technical Standard #18</a> pourrait être ajoutée par la suite. Ceci changerait la syntaxe, donc pour faciliter ce changement, une exception <a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> sera levée dans les cas ambigus pour le moment. Ceci inclut les ensembles commençant avec le caractère <code class="docutils literal notranslate"><span class="pre">'['</span></code> ou contenant les séquences de caractères <code class="docutils literal notranslate"><span class="pre">'--'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&amp;&amp;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'~~'</span></code> et <code class="docutils literal notranslate"><span class="pre">'||'</span></code>.  Pour éviter un message d'avertissement, échapper les séquences avec le caractère antislash (<code class="docutils literal notranslate"><span class="pre">&quot;\&quot;</span></code>).</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>L'exception <a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> est levée si un ensemble de caractères contient une construction dont la sémantique changera dans le futur.</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-14">
<dt><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">A|B</span></code>, où <em>A</em> et <em>B</em> peuvent être deux expressions rationnelles arbitraires, crée une expression rationnelle qui validera soit <em>A</em> soit <em>B</em>.  Un nombre arbitraire d'expressions peuvent être séparées de cette façon par des <code class="docutils literal notranslate"><span class="pre">'|'</span></code>.  Cela peut aussi être utilisé au sein de groupes (voir ci-dessous).  Quand une chaîne cible est analysée, les expressions séparées par <code class="docutils literal notranslate"><span class="pre">'|'</span></code> sont essayées de la gauche vers la droite. Quand un motif correspond complètement, cette branche est acceptée. Cela signifie qu'une fois que <em>A</em> correspond, <em>B</em> ne sera pas testée plus loin, même si elle pourrait provoquer une plus ample correspondance.  En d'autres termes, l'opérateur <code class="docutils literal notranslate"><span class="pre">'|'</span></code> n'est jamais gourmand.  Pour valider un <code class="docutils literal notranslate"><span class="pre">'|'</span></code> littéral, utilisez <code class="docutils literal notranslate"><span class="pre">\|</span></code>, ou enveloppez-le dans une classe de caractères, comme <code class="docutils literal notranslate"><span class="pre">[|]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-15">
<dt><code class="docutils literal notranslate"><span class="pre">(...)</span></code></dt><dd><p>Valide n'importe quelle expression rationnelle comprise entre les parenthèses, et indique le début et la fin d'un groupe ; le contenu d'un groupe peut être récupéré après qu'une analyse a été effectuée et peut être réutilisé plus loin dans la chaîne avec une séquence spéciale <code class="docutils literal notranslate"><span class="pre">\number</span></code>, décrite ci-dessous.  Pour écrire des <code class="docutils literal notranslate"><span class="pre">'('</span></code> ou <code class="docutils literal notranslate"><span class="pre">')'</span></code> littéraux, utilisez <code class="docutils literal notranslate"><span class="pre">\(</span></code> ou <code class="docutils literal notranslate"><span class="pre">\)</span></code>, ou enveloppez-les dans une classe de caractères : <code class="docutils literal notranslate"><span class="pre">[(]</span></code>, <code class="docutils literal notranslate"><span class="pre">[)]</span></code>.</p>
</dd>
</dl>
<dl id="index-16">
<dt><code class="docutils literal notranslate"><span class="pre">(?...)</span></code></dt><dd><p>Il s'agit d'une notation pour les extensions (un <code class="docutils literal notranslate"><span class="pre">'?'</span></code> suivant une <code class="docutils literal notranslate"><span class="pre">'('</span></code> n'a pas de sens autrement). Le premier caractère après le <code class="docutils literal notranslate"><span class="pre">'?'</span></code> détermine quel sens donner à l'expression. Les extensions ne créent généralement pas de nouveaux groupes ; <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code> est la seule exception à la règle. Retrouvez ci-dessous la liste des extensions actuellement supportées.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux)</span></code></dt><dd><p>(Une lettre ou plus de l'ensemble <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>.) Le groupe valide la chaîne vide ; les lettres activent les modes correspondants : <a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (validation ASCII seulement), <a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (ignorer la casse), <a class="reference internal" href="#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (dépendant de la locale), <a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (multi-ligne), <a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (les points correspondent à tous les caractères), <a class="reference internal" href="#re.U" title="re.U"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code></a> (support d'Unicode) et <a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (verbeux), pour l'ensemble de l'expression rationnelle. (Les options dans décrites dans la section <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">Contenu du module</span></a>.) C'est utile si vous souhaitez préciser l'option dans l'expression rationnelle, plutôt qu'en passant un argument <em>flag</em> à la fonction <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>.  Les options devraient être spécifiées en premier dans la chaîne de l'expression.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>Cette construction ne peut être utilisée qu'au début d'une chaîne de caractères.</p>
</div>
</dd>
</dl>
<dl id="index-17">
<dt><code class="docutils literal notranslate"><span class="pre">(?:...)</span></code></dt><dd><p>Une version sans capture des parenthèses habituelles. Valide n'importe quelle expression rationnelle à l'intérieur des parenthèses, mais la sous-chaîne correspondant au groupe <em>ne peut pas</em> être récupérée après l'analyse ou être référencée plus loin dans le motif.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux-imsx:...)</span></code></dt><dd><p>(Zéro lettres ou plus de l'ensemble <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>, optionnellement suivies par <code class="docutils literal notranslate"><span class="pre">'-'</span></code> puis <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>.)  Les lettres activent ou désactivent les options correspondantes : <a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (ASCII exclusivement), <a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (ignorer la casse), <a class="reference internal" href="#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (respecte les paramètres régionaux), <a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (multi-ligne), <a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (les points correspondent à tous les caractères), <a class="reference internal" href="#re.U" title="re.U"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code></a> (Unicode) et <a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (verbeux), pour cette partie de l'expression.  (Les options sont décrites dans la section <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">Contenu du module</span></a>.)</p>
<p>Les caractères <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> et <code class="docutils literal notranslate"><span class="pre">'u'</span></code> sont mutuellement exclusifs quand ils sont utilisés comme des options dans le motif, ils ne peuvent donc ni être combinés, ni suivre le caractère <code class="docutils literal notranslate"><span class="pre">'-'</span></code>. Quand l'un d'entre eux apparaît dans un groupe, il modifie le mode pour ce groupe. Dans les motifs Unicode l'option <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code> bascule en mode ASCII-uniquement, et <code class="docutils literal notranslate"><span class="pre">(?u:...)</span></code> bascule en mode Unicode (le comportement par défaut). Dans les motifs composés d'octets, <code class="docutils literal notranslate"><span class="pre">(?L:...)</span></code> fait en sorte de respecter les paramètres régionaux, et <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code> bascule en mode ASCII Uniquement (le comportement par défaut). Ces modifications ne concernent que les groupes dans lesquelles elles sont, le mode précédent est donc rétabli à la sortie du groupe.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.6.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>Les lettres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> et <code class="docutils literal notranslate"><span class="pre">'u'</span></code> peuvent aussi être utilisées dans un groupe.</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?&gt;...)</span></code></dt><dd><p>Attempts to match <code class="docutils literal notranslate"><span class="pre">...</span></code> as if it was a separate regular expression, and
if successful, continues to match the rest of the pattern following it.
If the subsequent pattern fails to match, the stack can only be unwound
to a point <em>before</em> the <code class="docutils literal notranslate"><span class="pre">(?&gt;...)</span></code> because once exited, the expression,
known as an <em class="dfn">atomic group</em>, has thrown away all stack points within
itself.
Thus, <code class="docutils literal notranslate"><span class="pre">(?&gt;.*).</span></code> would never match anything because first the <code class="docutils literal notranslate"><span class="pre">.*</span></code>
would match all characters possible, then, having nothing left to match,
the final <code class="docutils literal notranslate"><span class="pre">.</span></code> would fail to match.
Since there are no stack points saved in the Atomic Group, and there is
no stack point before it, the entire expression would thus fail to match.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.11.</span></p>
</div>
</dd>
</dl>
<dl id="index-18">
<dt><code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code></dt><dd><p>Similar to regular parentheses, but the substring matched by the group is
accessible via the symbolic group name <em>name</em>.  Group names must be valid
Python identifiers, and in <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> patterns they can only contain
bytes in the ASCII range.  Each group name must be defined only once within
a regular expression.  A symbolic group is also a numbered group, just as if
the group were not named.</p>
<p>Les groupes nommés peuvent être référencés dans trois contextes. Si le motif est <code class="docutils literal notranslate"><span class="pre">(?P&lt;quote&gt;['&quot;]).*?(?P=quote)</span></code> (c.-à-d. correspondant à une chaîne entourée de guillemets simples ou doubles) :</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 53%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Contexte de référence au groupe <em>quote</em></p></th>
<th class="head"><p>Manières de le référencer</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>lui-même dans le même motif</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(?P=quote)</span></code> (comme vu)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>en analysant l'objet résultat <em>m</em></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m.group('quote')</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m.end('quote')</span></code> (etc.)</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>dans une chaîne passée à l'argument <em>repl</em> de <code class="docutils literal notranslate"><span class="pre">re.sub()</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;quote&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.12: </span>In <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> patterns, group <em>name</em> can only contain bytes
in the ASCII range (<code class="docutils literal notranslate"><span class="pre">b'\x00'</span></code>-<code class="docutils literal notranslate"><span class="pre">b'\x7f'</span></code>).</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-19">
<dt><code class="docutils literal notranslate"><span class="pre">(?P=name)</span></code></dt><dd><p>Une référence arrière à un groupe nommé ; elle correspond à n'importe quel texte validé plus tôt par le groupe nommé <em>name</em>.</p>
</dd>
</dl>
<dl class="simple" id="index-20">
<dt><code class="docutils literal notranslate"><span class="pre">(?#...)</span></code></dt><dd><p>Un commentaire ; le contenu des parenthèses est simplement ignoré.</p>
</dd>
</dl>
<dl class="simple" id="index-21">
<dt><code class="docutils literal notranslate"><span class="pre">(?=...)</span></code></dt><dd><p>Valide si <code class="docutils literal notranslate"><span class="pre">...</span></code> valide la suite, mais ne consomme rien de la chaîne.  On appelle cela une assertion <em class="dfn">lookahead</em>.  Par exemple, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?=Asimov)</span></code> correspondra à la chaîne <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code> seulement si elle est suivie par <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-22">
<dt><code class="docutils literal notranslate"><span class="pre">(?!...)</span></code></dt><dd><p>Valide si <code class="docutils literal notranslate"><span class="pre">...</span></code> ne valide pas la suite.  C'est une assertion <em class="dfn">negative lookahead</em>. Par exemple, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?!Asimov)</span></code> correspondra à la chaîne <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code> seulement si elle <em>n'est pas</em> suivie par <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>.</p>
</dd>
</dl>
<dl id="index-23">
<dt><code class="docutils literal notranslate"><span class="pre">(?&lt;=...)</span></code></dt><dd><p>Valide si la position courante dans la chaîne est précédée par une correspondance sur <code class="docutils literal notranslate"><span class="pre">...</span></code> qui se termine à la position courante.  On appelle cela une <em class="dfn">positive lookbehind assertion</em>. <code class="docutils literal notranslate"><span class="pre">(?&lt;=abc)def</span></code> cherchera une correspondance dans <code class="docutils literal notranslate"><span class="pre">'abcdef'</span></code>, puisque le <em>lookbehind*</em> mettra de côté 3 caractères et vérifiera que le motif contenu correspond.  Le motif ne devra correspondre qu'à des chaînes de taille fixe, cela veut dire que <code class="docutils literal notranslate"><span class="pre">abc</span></code> ou <code class="docutils literal notranslate"><span class="pre">a|b</span></code> sont autorisées, mais pas <code class="docutils literal notranslate"><span class="pre">a*</span></code> ou <code class="docutils literal notranslate"><span class="pre">a{3,4}</span></code>.  Notez que les motifs qui commencent par des assertions <em>lookbehind</em> positives ne peuvent pas correspondre au début de la chaîne analysée ; vous préférerez sûrement utiliser la fonction <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> plutôt que la fonction <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> :</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(?&lt;=abc)def&#39;</span><span class="p">,</span> <span class="s1">&#39;abcdef&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
</pre></div>
</div>
<p>Cet exemple recherche un mot suivi d'un trait d'union :</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?&lt;=-)\w+&#39;</span><span class="p">,</span> <span class="s1">&#39;spam-egg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;egg&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>Ajout du support des références aux groupes de taille fixe.</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-24">
<dt><code class="docutils literal notranslate"><span class="pre">(?&lt;!...)</span></code></dt><dd><p>Valide si la position courante dans la chaîne n'est pas précédée par une correspondance sur <code class="docutils literal notranslate"><span class="pre">...</span></code>.  On appelle cela une <em class="dfn">negative lookbehind assertion</em>.  À la manière des assertions <em>lookbehind</em> positives, le motif contenu ne peut que correspondre à des chaînes de taille fixe.  Les motifs débutant par une assertion <em>lookbehind</em> négative peuvent correspondre au début de la chaîne analysée.</p>
</dd>
</dl>
<span class="target" id="re-conditional-expression"></span><dl id="index-25">
<dt><code class="docutils literal notranslate"><span class="pre">(?(id/name)yes-pattern|no-pattern)</span></code></dt><dd><p>Essaiera de faire la correspondance avec <code class="docutils literal notranslate"><span class="pre">yes-pattern</span></code> si le groupe indiqué par <em>id</em> ou <em>name</em> existe, et avec <code class="docutils literal notranslate"><span class="pre">no-pattern</span></code> s'il n'existe pas. <code class="docutils literal notranslate"><span class="pre">no-pattern</span></code> est optionnel et peut être omis. Par exemple, <code class="docutils literal notranslate"><span class="pre">(&lt;)?(\w+&#64;\w+(?:\.\w+)+)(?(1)&gt;|$)</span></code> est un motif simpliste pour identifier une adresse courriel, qui validera <code class="docutils literal notranslate"><span class="pre">'&lt;user&#64;host.com&gt;'</span></code> ainsi que <code class="docutils literal notranslate"><span class="pre">'user&#64;host.com'</span></code> mais pas <code class="docutils literal notranslate"><span class="pre">'&lt;user&#64;host.com'</span></code> ni <code class="docutils literal notranslate"><span class="pre">'user&#64;host.com&gt;'</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.12: </span>Group <em>id</em> can only contain ASCII digits.
In <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> patterns, group <em>name</em> can only contain bytes
in the ASCII range (<code class="docutils literal notranslate"><span class="pre">b'\x00'</span></code>-<code class="docutils literal notranslate"><span class="pre">b'\x7f'</span></code>).</p>
</div>
</dd>
</dl>
<p id="re-special-sequences">Les séquences spéciales sont composées de <code class="docutils literal notranslate"><span class="pre">'\'</span></code> et d'un caractère de la liste qui suit. Si le caractère ordinaire n'est pas un chiffre <em>ASCII</em> ou une lettre <em>ASCII</em>, alors l'expression rationnelle résultante validera le second caractère de la séquence.  Par exemple, <code class="docutils literal notranslate"><span class="pre">\$</span></code> correspond au caractère <code class="docutils literal notranslate"><span class="pre">'$'</span></code>.</p>
<dl class="simple" id="index-26">
<dt><code class="docutils literal notranslate"><span class="pre">\number</span></code></dt><dd><p>Correspond au contenu du groupe du même nombre. Les groupes sont numérotés à partir de 1.  Par exemple, <code class="docutils literal notranslate"><span class="pre">(.+)</span> <span class="pre">\1</span></code> correspond à <code class="docutils literal notranslate"><span class="pre">'the</span> <span class="pre">the'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'55</span> <span class="pre">55'</span></code>, mais pas à <code class="docutils literal notranslate"><span class="pre">'thethe'</span></code> (notez l'espace après le groupe).  Cette séquence spéciale ne peut être utilisée que pour faire référence aux 99 premiers groupes.  Si le premier chiffre de <em>number</em> est 0, ou si <em>number</em> est un nombre octal de 3 chiffres, il ne sera pas interprété comme une référence à un groupe, mais comme le caractère à la valeur octale <em>number</em>. À l'intérieur des <code class="docutils literal notranslate"><span class="pre">'['</span></code> et <code class="docutils literal notranslate"><span class="pre">']'</span></code> d'une classe de caractères, tous les échappements numériques sont traités comme des caractères.</p>
</dd>
</dl>
<dl class="simple" id="index-27">
<dt><code class="docutils literal notranslate"><span class="pre">\A</span></code></dt><dd><p>Correspond uniquement au début d'une chaîne de caractères.</p>
</dd>
</dl>
<dl id="index-28">
<dt><code class="docutils literal notranslate"><span class="pre">\b</span></code></dt><dd><p>Correspond à la chaîne vide, mais uniquement au début ou à la fin d'un mot. Un mot est défini comme une séquence de « caractères de mots ».  Notez que formellement, <code class="docutils literal notranslate"><span class="pre">\b</span></code> est défini comme la liaison entre <code class="docutils literal notranslate"><span class="pre">\w</span></code> et <code class="docutils literal notranslate"><span class="pre">\W</span></code> (et inversement), ou entre <code class="docutils literal notranslate"><span class="pre">\w</span></code> et le début/fin d'un mot. Cela signifie que <code class="docutils literal notranslate"><span class="pre">r'\bfoo\b'</span></code> validera <code class="docutils literal notranslate"><span class="pre">'foo'</span></code>, <code class="docutils literal notranslate"><span class="pre">'foo.'</span></code>, <code class="docutils literal notranslate"><span class="pre">'(foo)'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'bar</span> <span class="pre">foo</span> <span class="pre">baz'</span></code> mais pas <code class="docutils literal notranslate"><span class="pre">'foobar'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'foo3'</span></code>.</p>
<p>Les caractères alphanumériques Unicode sont utilisés par défaut dans les motifs Unicode, mais cela peut être changé en utilisant l'option <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a>. Les délimitations de mots sont déterminées par la locale si l'option <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> est utilisée. À l'intérieur d'un intervalle de caractères, <code class="docutils literal notranslate"><span class="pre">\b</span></code> représente le caractère <em>retour arrière</em>, par compatibilité avec les chaînes littérales Python.</p>
</dd>
</dl>
<dl class="simple" id="index-29">
<dt><code class="docutils literal notranslate"><span class="pre">\B</span></code></dt><dd><p>Correspond à la chaîne vide, mais uniquement quand elle <em>n'est pas</em> au début ou à la fin d'un mot.  Cela signifie que <code class="docutils literal notranslate"><span class="pre">r'py\B'</span></code> valide <code class="docutils literal notranslate"><span class="pre">'python'</span></code>, <code class="docutils literal notranslate"><span class="pre">'py3'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'py2'</span></code>, mais pas <code class="docutils literal notranslate"><span class="pre">'py'</span></code>, <code class="docutils literal notranslate"><span class="pre">'py.'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'py!'</span></code>. <code class="docutils literal notranslate"><span class="pre">\B</span></code> est simplement l'opposé de <code class="docutils literal notranslate"><span class="pre">\b</span></code>, donc les caractères de mots dans les motifs Unicode sont les alphanumériques et tirets bas Unicode, bien que cela puisse être changé avec l'option <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a>. Les délimitations de mots sont déterminées par la locale si l'option <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> est utilisée.</p>
</dd>
</dl>
<dl class="simple" id="index-30">
<dt><code class="docutils literal notranslate"><span class="pre">\d</span></code></dt><dd><dl class="simple">
<dt>Pour les motifs Unicode (<em>str</em>) :</dt><dd><p>Valide n'importe quel chiffre décimal Unicode (soit tout caractère Unicode de catégorie [Nd]).  Cela inclut <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>, mais aussi bien d'autres caractères de chiffres.  Si l'option <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> est utilisée, seuls les caractères de la classe <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code> correspondront.</p>
</dd>
<dt>Pour les motifs 8-bits (<em>bytes</em>) :</dt><dd><p>Valide n'importe quel chiffre décimal ; équivalent à <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="index-31">
<dt><code class="docutils literal notranslate"><span class="pre">\D</span></code></dt><dd><p>Valide tout caractère qui n'est pas un chiffre décimal. C'est l'opposé de <code class="docutils literal notranslate"><span class="pre">\d</span></code>. Si l'option <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> est utilisée, cela devient équivalent à <code class="docutils literal notranslate"><span class="pre">[^0-9]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-32">
<dt><code class="docutils literal notranslate"><span class="pre">\s</span></code></dt><dd><dl class="simple">
<dt>Pour les motifs Unicode (<em>str</em>) :</dt><dd><p>Valide les caractères d'espacement Unicode (qui incluent <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code> et bien d'autres, comme les espaces insécables requises par les règles typographiques de beaucoup de langues). Si l'option <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> est utilisée, seuls les caractères de la classe <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code> sont validés.</p>
</dd>
<dt>Pour les motifs 8-bits (<em>bytes</em>) :</dt><dd><p>Valide les caractères considérés comme des espacements dans la table ASCII ; équivalent à <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="index-33">
<dt><code class="docutils literal notranslate"><span class="pre">\S</span></code></dt><dd><p>Valide tout caractère qui n'est pas un caractère d'espacement. C'est l'opposé de <code class="docutils literal notranslate"><span class="pre">\s</span></code>. Si l'option <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> est utilisée, cela devient équivalent à <code class="docutils literal notranslate"><span class="pre">[^</span> <span class="pre">\t\n\r\f\v]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-34">
<dt><code class="docutils literal notranslate"><span class="pre">\w</span></code></dt><dd><dl class="simple">
<dt>Pour les motifs Unicode (<em>str</em>) :</dt><dd><p>Valide les caractères Unicode de mot ; cela inclut les caractères alphanumériques (tels que définis par <a class="reference internal" href="stdtypes.html#str.isalnum" title="str.isalnum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.isalnum()</span></code></a>), ainsi que les tirets bas(<code class="docutils literal notranslate"><span class="pre">_</span></code>). Si l'option <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> est utilisée, seuls les caractères de la classe <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code> sont validés.</p>
</dd>
<dt>Pour les motifs 8-bits (<em>bytes</em>) :</dt><dd><p>Valide les caractères alphanumériques de la table ASCII ; équivalent à <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>. Si l'option <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> est utilisée, les caractères considérés alphanumériques dans la locale et le tiret bas seront acceptés.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="index-35">
<dt><code class="docutils literal notranslate"><span class="pre">\W</span></code></dt><dd><p>Valide tout caractère qui n'est pas un caractère de mot. C'est l'opposé de <code class="docutils literal notranslate"><span class="pre">\w</span></code>. Si l'option <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> est utilisée, cela devient équivalent à <code class="docutils literal notranslate"><span class="pre">[^a-zA-Z0-9_]</span></code>. Si l'option <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> est utilisée, les caractères considérés alphanumériques dans la locale, et le tiret bas, ne correspondent pas.</p>
</dd>
</dl>
<dl class="simple" id="index-36">
<dt><code class="docutils literal notranslate"><span class="pre">\Z</span></code></dt><dd><p>Correspond uniquement à la fin d'une chaîne de caractères.</p>
</dd>
</dl>
<p id="index-37">Most of the <a class="reference internal" href="../reference/lexical_analysis.html#escape-sequences"><span class="std std-ref">escape sequences</span></a> supported by Python
string literals are also accepted by the regular expression parser:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>\<span class="n">a</span>      \<span class="n">b</span>      \<span class="n">f</span>      \<span class="n">n</span>
\<span class="n">N</span>      \<span class="n">r</span>      \<span class="n">t</span>      \<span class="n">u</span>
\<span class="n">U</span>      \<span class="n">v</span>      \<span class="n">x</span>      \\
</pre></div>
</div>
<p>(Notez que <code class="docutils literal notranslate"><span class="pre">\b</span></code> est utilisé pour représenter les bornes d'un mot, et signifie « <em>retour arrière</em> » uniquement à l'intérieur d'une classe de caractères)</p>
<p>Les séquences d'échappement <code class="docutils literal notranslate"><span class="pre">'\u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'\U'</span></code> et <code class="docutils literal notranslate"><span class="pre">'\N'</span></code> sont seulement reconnues dans les motifs Unicode. Dans les motifs d'octets (type <em>bytes</em>), ce sont des erreurs. Les échappements inconnus de lettres ASCII sont réservés pour une utilisation future et sont considérés comme des erreurs.</p>
<p>Les séquences octales d'échappement sont incluses dans une forme limitée.  Si le premier chiffre est un 0, ou s'il y a trois chiffres octaux, la séquence est considérée comme octale. Autrement, il s'agit d'une référence vers un groupe.  Comme pour les chaînes littérales, les séquences octales ne font jamais plus de 3 caractères de long.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.3: </span>Les séquences d'échappement <code class="docutils literal notranslate"><span class="pre">'\u'</span></code> et <code class="docutils literal notranslate"><span class="pre">'\U'</span></code> ont été ajoutées.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.6: </span>Les séquences inconnues composées de <code class="docutils literal notranslate"><span class="pre">'\'</span></code> et d'une lettre ASCII sont maintenant des erreurs.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.8: </span>The <code class="samp docutils literal notranslate"><span class="pre">'\N{</span><em><span class="pre">name</span></em><span class="pre">}'</span></code> escape sequence has been added. As in string literals,
it expands to the named Unicode character (e.g. <code class="docutils literal notranslate"><span class="pre">'\N{EM</span> <span class="pre">DASH}'</span></code>).</p>
</div>
</section>
<section id="module-contents">
<span id="contents-of-module-re"></span><h2>Contenu du module<a class="headerlink" href="#module-contents" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le module définit plusieurs fonctions, constantes, et une exception. Certaines fonctions sont des versions simplifiées des méthodes plus complètes des expressions rationnelles compilées.  La plupart des applications non triviales utilisent toujours la version compilée.</p>
<section id="flags">
<h3>Flags<a class="headerlink" href="#flags" title="Lien permanent vers ce titre">¶</a></h3>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.6: </span>Les constantes d'options sont maintenant des instances de <a class="reference internal" href="#re.RegexFlag" title="re.RegexFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegexFlag</span></code></a>, sous-classe de <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a>.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="re.RegexFlag">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">RegexFlag</span></span><a class="headerlink" href="#re.RegexFlag" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>An <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> class containing the regex options listed below.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.11: </span>- added to <code class="docutils literal notranslate"><span class="pre">__all__</span></code></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.A">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">A</span></span><a class="headerlink" href="#re.A" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="re.ASCII">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">ASCII</span></span><a class="headerlink" href="#re.ASCII" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Fait correspondre à <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code>, <code class="docutils literal notranslate"><span class="pre">\d</span></code>, <code class="docutils literal notranslate"><span class="pre">\D</span></code>, <code class="docutils literal notranslate"><span class="pre">\s</span></code> et <code class="docutils literal notranslate"><span class="pre">\s</span></code> des caractères ASCII seulement, plutôt qu'Unicode.  Cela n'a du sens que pour les motifs Unicode, et est ignoré pour les motifs 8-bits. Correspond à l'option de groupe <code class="docutils literal notranslate"><span class="pre">(?a)</span></code>.</p>
<p>Notez que par compatibilité envers les versions précédentes, l'option <a class="reference internal" href="#re.U" title="re.U"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code></a> existe toujours (ainsi que son synonyme <a class="reference internal" href="#re.UNICODE" title="re.UNICODE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.UNICODE</span></code></a> et sa version embarquée <code class="docutils literal notranslate"><span class="pre">(?u)</span></code>), mais elles sont redondantes en Python 3 depuis que l'analyse est faite en Unicode par défaut pour les chaînes de caractères (et que l'analyse Unicode n'est pas permise pour les chaînes 8-bit).</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.DEBUG">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">DEBUG</span></span><a class="headerlink" href="#re.DEBUG" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Affiche des informations de débogage à propos de l'expression compilée. N'a pas d'option de groupe équivalente.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.I">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">I</span></span><a class="headerlink" href="#re.I" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="re.IGNORECASE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">IGNORECASE</span></span><a class="headerlink" href="#re.IGNORECASE" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Effectue une analyse indépendante de la casse. Les motifs tels que <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> accepteront donc les caractères minuscules. L'analyse Unicode complète (tel que <code class="docutils literal notranslate"><span class="pre">Ü</span></code> correspondant à <code class="docutils literal notranslate"><span class="pre">ü</span></code>) fonctionne aussi, tant que l'option <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.ASCII</span></code></a> n'est pas utilisée. La locale n'affecte pas cette option, tant que l'option <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.LOCALE</span></code></a> n'est pas utilisée. Correspond au marqueur de groupe <code class="docutils literal notranslate"><span class="pre">(?i)</span></code>.</p>
<p>À noter : quand les motifs Unicode <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> ou <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> sont utilisés en combinaison avec la constante <a class="reference internal" href="#re.IGNORECASE" title="re.IGNORECASE"><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code></a>, ils correspondront aux 52 caractères ASCII et aux 4 caractères non ASCII : 'İ' (<em>U+0130</em>, Latin majuscule I avec un point au-dessus), 'ı' (<em>U+0131</em>, Latin minuscule sans point au-dessus), 'ſ' (<em>U+017F</em>, Latin minuscule <em>long s</em>) et 'K' (<em>U+212A</em>, <em>Kelvin sign</em>). Si la constante <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> est utilisée, seuls les caractères 'a' à 'z' et 'A' à 'Z' seront concernés.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.L">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#re.L" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="re.LOCALE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">LOCALE</span></span><a class="headerlink" href="#re.LOCALE" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Fait dépendre de la locale courante : <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code>, et l'analyse insensible à la casse. Cette option peut être utilisée avec les motifs en <em>bytes</em>. L'utilisation de cette option est déconseillée à cause du mécanisme de locale très peu fiable, et ne gérant qu'une « culture » à la fois, et ne fonctionnant que pour les locales 8-bits.  L'analyse Unicode est déjà activée par défaut dans Python 3 pour les motifs Unicode (<em>str</em>), et elle est capable de gérer plusieurs locales et langages. Correspond à l'option de groupe <code class="docutils literal notranslate"><span class="pre">(?L)</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.6: </span><a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.LOCALE</span></code></a> ne peut être utilisée qu'avec les motifs 8-bits et n'est pas compatible avec <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.ASCII</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>Les objets d'expressions régulières compilées avec l'indicateur <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.LOCALE</span></code></a> ne dépendent plus de la <em>locale</em> au moment de la compilation. Seulement la <em>locale</em> au moment de la correspondance affecte le résultat.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.M">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">M</span></span><a class="headerlink" href="#re.M" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="re.MULTILINE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">MULTILINE</span></span><a class="headerlink" href="#re.MULTILINE" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Quand spécifiée, le caractère <code class="docutils literal notranslate"><span class="pre">'^'</span></code> correspond au début d'une chaîne et au début d'une ligne (caractère suivant directement le saut de ligne) ; et le caractère <code class="docutils literal notranslate"><span class="pre">'$'</span></code> correspond à la fin d'une chaîne et à la fin d'une ligne (juste avant le saut de ligne).  Par défaut, <code class="docutils literal notranslate"><span class="pre">'^'</span></code> correspond uniquement au début de la chaîne, et <code class="docutils literal notranslate"><span class="pre">'$'</span></code> uniquement à la fin de la chaîne, ou immédiatement avant le saut de ligne (s'il y a) à la fin de la chaîne. Correspond à l'option de groupe <code class="docutils literal notranslate"><span class="pre">(?m)</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.NOFLAG">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">NOFLAG</span></span><a class="headerlink" href="#re.NOFLAG" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Indicates no flag being applied, the value is <code class="docutils literal notranslate"><span class="pre">0</span></code>.  This flag may be used
as a default value for a function keyword argument or as a base value that
will be conditionally ORed with other flags.  Example of use as a default
value:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">NOFLAG</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.S">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">S</span></span><a class="headerlink" href="#re.S" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="re.DOTALL">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">DOTALL</span></span><a class="headerlink" href="#re.DOTALL" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Fait correspondre tous les caractères possibles à <code class="docutils literal notranslate"><span class="pre">'.'</span></code>, incluant le saut de ligne ; sans cette option, <code class="docutils literal notranslate"><span class="pre">'.'</span></code> correspondrait à tout caractère à l'exception du saut de ligne. Correspond à l'option de groupe <code class="docutils literal notranslate"><span class="pre">(?s)</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.U">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">U</span></span><a class="headerlink" href="#re.U" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="re.UNICODE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">UNICODE</span></span><a class="headerlink" href="#re.UNICODE" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>In Python 2, this flag made <a class="reference internal" href="#re-special-sequences"><span class="std std-ref">special sequences</span></a>
include Unicode characters in matches. Since Python 3, Unicode characters
are matched by default.</p>
<p>See <a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">A</span></code></a> for restricting matching on ASCII characters instead.</p>
<p>This flag is only kept for backward compatibility.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.X">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">X</span></span><a class="headerlink" href="#re.X" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="re.VERBOSE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">VERBOSE</span></span><a class="headerlink" href="#re.VERBOSE" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p id="index-38">Cette option vous autorise à écrire des expressions rationnelles qui présentent mieux et sont plus lisibles en vous permettant de séparer visuellement les sections logiques du motif et d'ajouter des commentaires. Les caractères d'espacement à l'intérieur du motif sont ignorés, sauf à l'intérieur des classes de caractères ou quand ils sont précédés d'un <em>backslash</em> non échappé, ou dans des séquences comme <code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">(?:</span></code> ou <code class="docutils literal notranslate"><span class="pre">(?P&lt;...&gt;</span></code>.Par exemple, <code class="docutils literal notranslate"><span class="pre">(?</span> <span class="pre">:</span></code> et <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">?</span></code> ne sont pas autorisés. Quand une ligne contient un <code class="docutils literal notranslate"><span class="pre">#</span></code> qui n'est ni dans une classe de caractères, ni précédé d'un <em>backslash</em> non échappé, tous les caractères depuis le <code class="docutils literal notranslate"><span class="pre">#</span></code> le plus à gauche jusqu'à la fin de la ligne sont ignorés.</p>
<p>Cela signifie que les deux expressions rationnelles suivantes qui valident un nombre décimal sont fonctionnellement égales :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;\d +  # the integral part</span>
<span class="s2">                   \.    # the decimal point</span>
<span class="s2">                   \d *  # some fractional digits&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+\.\d*&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Correspond à l'option de groupe <code class="docutils literal notranslate"><span class="pre">(?x)</span></code>.</p>
</dd></dl>

</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="re.compile">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">compile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.compile" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Compile un motif vers une <a class="reference internal" href="#re-objects"><span class="std std-ref">expression rationnelle</span></a> compilée, dont les méthodes <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> et <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>, décrites ci-dessous, peuvent être utilisées pour analyser des textes.</p>
<p>Le comportement des expressions peut être modifié en spécifiant une valeur <em>flags</em>. Les valeurs sont comprises dans les variables suivantes, et peuvent être combinées avec un <em>ou</em> bit-à-bit (opérateur <code class="docutils literal notranslate"><span class="pre">|</span></code>).</p>
<p>La séquence</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>est équivalente à</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>mais utiliser <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> et sauvegarder l'expression rationnelle renvoyée pour la réutiliser est plus efficace quand l'expression est amenée à être utilisée plusieurs fois dans un même programme.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Les versions compilées des motifs les plus récents passés à <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> et autres fonctions d'analyse du module sont mises en cache, ainsi les programmes qui n'utilisent que quelques expressions rationnelles en même temps n'ont pas à s'inquiéter de la compilation de ces expressions.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.search">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.search" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Scan through <em>string</em> looking for the first location where the regular expression
<em>pattern</em> produces a match, and return a corresponding <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>. Return
<code class="docutils literal notranslate"><span class="pre">None</span></code> if no position in the string matches the pattern; note that this is
different from finding a zero-length match at some point in the string.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.match">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.match" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>If zero or more characters at the beginning of <em>string</em> match the regular
expression <em>pattern</em>, return a corresponding <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>.  Return
<code class="docutils literal notranslate"><span class="pre">None</span></code> if the string does not match the pattern; note that this is
different from a zero-length match.</p>
<p>Notez que même en mode <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a>, <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> ne validera qu'au début de la chaîne et non au début de chaque ligne.</p>
<p>Si vous voulez trouver une correspondance n'importe où dans <em>string</em>, utilisez plutôt <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> (voir aussi <a class="reference internal" href="#search-vs-match"><span class="std std-ref">Comparaison de search() et match()</span></a>).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.fullmatch">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">fullmatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.fullmatch" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>If the whole <em>string</em> matches the regular expression <em>pattern</em>, return a
corresponding <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>.  Return <code class="docutils literal notranslate"><span class="pre">None</span></code> if the string does not match
the pattern; note that this is different from a zero-length match.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.split">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.split" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Sépare <em>string</em> selon les occurrences de <em>pattern</em>.  Si des parenthèses de capture sont utilisées dans <em>pattern</em>, alors les textes des groupes du motif sont aussi renvoyés comme éléments de la liste résultante. Si <em>maxsplit</em> est différent de zéro, il ne pourra y avoir plus de <em>maxsplit</em> séparations, et le reste de la chaîne sera renvoyé comme le dernier élément de la liste.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words&#39;, &#39;words&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words, words.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[a-f]+&#39;</span><span class="p">,</span> <span class="s1">&#39;0a3B9&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">[&#39;0&#39;, &#39;3&#39;, &#39;9&#39;]</span>
</pre></div>
</div>
<p>S'il y a des groupes de capture dans le séparateur et qu'ils trouvent une correspondance au début de la chaîne, le résultat commencera par une chaîne vide.  La même chose se produit pour la fin de la chaîne :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words, words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;...&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p>De cette manière, les séparateurs sont toujours trouvés aux mêmes indices relatifs dans la liste résultante.</p>
<p>Les correspondances vides pour le motif scindent la chaîne de caractères seulement lorsqu'ils ne sont pas adjacents à une correspondance vide précédente.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W*&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;d&#39;, &#39;s&#39;, &#39;&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W*)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;&#39;, &#39;o&#39;, &#39;&#39;, &#39;r&#39;, &#39;&#39;, &#39;d&#39;, &#39;&#39;, &#39;s&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.1: </span>ajout de l'argument optionnel <em>flags</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>Gestion du découpage avec un motif qui pourrait correspondre à une chaine de caractère vide.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.findall">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">findall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.findall" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie toutes les correspondances, sans chevauchements, entre le motif <em>pattern</em> et la chaîne <em>string</em>, comme une liste de chaînes ou de <em>n</em>-uplets.  La chaîne <em>string</em> est examinée de gauche à droite, et les correspondances sont données dans cet ordre. Le résultat peut contenir des correspondances vides.</p>
<p>Le type du résultat dépend du nombre de groupes capturants dans le motif. S'il n'y en a pas, le résultat est une liste de sous-chaînes de caractères qui correspondent au motif.  S'il y a exactement un groupe, le résultat est une liste constituée des sous-chaînes qui correspondaient à ce groupe pour chaque correspondance entre le motif et la chaîne.  S'il y a plusieurs groupes, le résultat est formé de <em>n</em>-uplets avec les sous-chaînes correspondant aux différents groupes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\bf[a-z]*&#39;</span><span class="p">,</span> <span class="s1">&#39;which foot or hand fell fastest&#39;</span><span class="p">)</span>
<span class="go">[&#39;foot&#39;, &#39;fell&#39;, &#39;fastest&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+)=(\d+)&#39;</span><span class="p">,</span> <span class="s1">&#39;set width=20 and height=10&#39;</span><span class="p">)</span>
<span class="go">[(&#39;width&#39;, &#39;20&#39;), (&#39;height&#39;, &#39;10&#39;)]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>Les correspondances non vides peuvent maintenant démarrer juste après une correspondance vide précédente.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.finditer">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">finditer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.finditer" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Return an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> yielding <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> objects over
all non-overlapping matches for the RE <em>pattern</em> in <em>string</em>.  The <em>string</em>
is scanned left-to-right, and matches are returned in the order found.  Empty
matches are included in the result.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>Les correspondances non vides peuvent maintenant démarrer juste après une correspondance vide précédente.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.sub">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.sub" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie la chaîne obtenue en remplaçant les occurrences (sans chevauchement) les plus à gauche de <em>pattern</em> dans <em>string</em> par le remplacement <em>repl</em>.  Si le motif n'est pas trouvé, <em>string</em> est renvoyée inchangée.  <em>repl</em> peut être une chaîne de caractères ou une fonction ; si c'est une chaîne, toutes les séquences d'échappement qu'elle contient sont traduites.  Ainsi, <code class="docutils literal notranslate"><span class="pre">\n</span></code> est convertie en un simple saut de ligne, <code class="docutils literal notranslate"><span class="pre">\r</span></code> en un retour chariot, et ainsi de suite.  Les échappements inconnus de lettres ASCII sont réservés pour une utilisation future et sont considérés comme des erreurs. Les autres échappements tels que <code class="docutils literal notranslate"><span class="pre">\&amp;</span></code> sont laissés intacts. Les références arrières, telles que <code class="docutils literal notranslate"><span class="pre">\6</span></code>, sont remplacées par la sous-chaîne correspondant au groupe 6 dans le motif. Par exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="sa">r</span><span class="s1">&#39;static PyObject*\npy_\1(void)\n{&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s1">&#39;def myfunc():&#39;</span><span class="p">)</span>
<span class="go">&#39;static PyObject*\npy_myfunc(void)\n{&#39;</span>
</pre></div>
</div>
<p>If <em>repl</em> is a function, it is called for every non-overlapping occurrence of
<em>pattern</em>.  The function takes a single <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> argument, and returns
the replacement string.  For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">dashrepl</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39; &#39;</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;-&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;-{1,2}&#39;</span><span class="p">,</span> <span class="n">dashrepl</span><span class="p">,</span> <span class="s1">&#39;pro----gram-files&#39;</span><span class="p">)</span>
<span class="go">&#39;pro--gram files&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\sAND\s&#39;</span><span class="p">,</span> <span class="s1">&#39; &amp; &#39;</span><span class="p">,</span> <span class="s1">&#39;Baked Beans And Spam&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">&#39;Baked Beans &amp; Spam&#39;</span>
</pre></div>
</div>
<p>The pattern may be a string or a <a class="reference internal" href="#re.Pattern" title="re.Pattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pattern</span></code></a>.</p>
<p>L'argument optionnel <em>count</em> est le nombre maximum d'occurrences du motif à remplacer : <em>count</em> ne doit pas être un nombre négatif.  Si omis ou nul, toutes les occurrences seront remplacées. Les correspondances vides avec le motif sont remplacées uniquement quand elles ne sont pas adjacentes à une précédente correspondance, ainsi <code class="docutils literal notranslate"><span class="pre">sub('x*',</span> <span class="pre">'-',</span> <span class="pre">'abxd')</span></code> renvoie <code class="docutils literal notranslate"><span class="pre">'-a-b--d-'</span></code>.</p>
<p id="index-39">Dans les arguments <em>repl</em> de type <em>string</em>, en plus des séquences d'échappement et références arrières décrites au-dessus, <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code> utilisera la sous-chaîne correspondant au groupe nommé <code class="docutils literal notranslate"><span class="pre">name</span></code>, comme défini par la syntaxe <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>. <code class="docutils literal notranslate"><span class="pre">\g&lt;number&gt;</span></code> utilise le groupe numéroté associé ; <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;</span></code> est ainsi équivalent à <code class="docutils literal notranslate"><span class="pre">\2</span></code>, mais n'est pas ambigu dans un remplacement tel que <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;0</span></code>, <code class="docutils literal notranslate"><span class="pre">\20</span></code> serait interprété comme une référence au groupe 20, et non une référence au groupe 2 suivie par un caractère littéral <code class="docutils literal notranslate"><span class="pre">'0'</span></code>.  La référence arrière <code class="docutils literal notranslate"><span class="pre">\g&lt;0&gt;</span></code> est remplacée par la sous-chaîne entière validée par l'expression rationnelle.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.1: </span>ajout de l'argument optionnel <em>flags</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>Les groupes sans correspondance sont remplacés par une chaîne vide.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.6: </span>Les séquences d'échappement inconnues dans <em>pattern</em> formées par <code class="docutils literal notranslate"><span class="pre">'\'</span></code> et une lettre ASCII sont maintenant des erreurs.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>Les séquences d'échappement inconnues dans <em>repl</em> formées par <code class="docutils literal notranslate"><span class="pre">'\'</span></code> et une lettre ASCII sont maintenant des erreurs.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>Les correspondances vides pour le motif sont remplacées lorsqu'elles sont adjacentes à une correspondance non vide précédente.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.12: </span>Group <em>id</em> can only contain ASCII digits.
In <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> replacement strings, group <em>name</em> can only contain bytes
in the ASCII range (<code class="docutils literal notranslate"><span class="pre">b'\x00'</span></code>-<code class="docutils literal notranslate"><span class="pre">b'\x7f'</span></code>).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.subn">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">subn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.subn" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Réalise la même opération que <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>, mais renvoie une paire <code class="docutils literal notranslate"><span class="pre">(nouvelle_chaîne,</span> <span class="pre">nombre_de_substitutions_réalisées)</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.1: </span>ajout de l'argument optionnel <em>flags</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>Les groupes sans correspondance sont remplacés par une chaîne vide.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.escape">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">escape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.escape" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Échappe tous les caractères spéciaux de <em>pattern</em>. Cela est utile si vous voulez valider une quelconque chaîne littérale qui pourrait contenir des métacaractères d'expressions rationnelles.  Par exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;https://www.python.org&#39;</span><span class="p">))</span>
<span class="go">https://www\.python\.org</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">legal_chars</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="s2">&quot;!#$%&amp;&#39;*+-.^_`|~:&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]+&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">legal_chars</span><span class="p">))</span>
<span class="go">[abcdefghijklmnopqrstuvwxyz0123456789!\#\$%\&amp;&#39;\*\+\-\.\^_`\|\~:]+</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">operators</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;**&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))))</span>
<span class="go">/|\-|\+|\*\*|\*</span>
</pre></div>
</div>
<p>Cette fonction ne doit pas être utilisée pour la chaîne de remplacement dans <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> et <a class="reference internal" href="#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a>, seuls les antislashs devraient être échappés. Par exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">digits_re</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\d+&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span> <span class="o">=</span> <span class="s1">&#39;/usr/sbin/sendmail - 0 errors, 12 warnings&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">digits_re</span><span class="p">,</span> <span class="n">digits_re</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">sample</span><span class="p">))</span>
<span class="go">/usr/sbin/sendmail - \d+ errors, \d+ warnings</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.3: </span>Le caractère <code class="docutils literal notranslate"><span class="pre">'_'</span></code> n'est plus échappé.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>Seuls les caractères qui peuvent avoir une signification spéciale dans une expression rationnelle sont échappés. De ce fait, <code class="docutils literal notranslate"><span class="pre">'!'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&quot;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'%'</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;'&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">','</span></code>, <code class="docutils literal notranslate"><span class="pre">'/'</span></code>, <code class="docutils literal notranslate"><span class="pre">':'</span></code>, <code class="docutils literal notranslate"><span class="pre">';'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'='</span></code>, <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code>, et <code class="docutils literal notranslate"><span class="pre">&quot;`&quot;</span></code> ne sont plus échappés.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.purge">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">purge</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#re.purge" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vide le cache d'expressions rationnelles.</p>
</dd></dl>

</section>
<section id="exceptions">
<h3>Exceptions<a class="headerlink" href="#exceptions" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py exception">
<dt class="sig sig-object py" id="re.error">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pattern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.error" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Exception levée quand une chaîne passée à l'une des fonctions ici présentes n'est pas une expression rationnelle valide (contenant par exemple une parenthèse non fermée) ou quand d'autres erreurs se produisent durant la compilation ou l'analyse.  Il ne se produit jamais d'erreur si une chaîne ne contient aucune correspondance pour un motif.  Les instances de l'erreur ont les attributs additionnels suivants :</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.msg">
<span class="sig-name descname"><span class="pre">msg</span></span><a class="headerlink" href="#re.error.msg" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Le message d'erreur non formaté.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.pattern">
<span class="sig-name descname"><span class="pre">pattern</span></span><a class="headerlink" href="#re.error.pattern" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Le motif d'expression rationnelle.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.pos">
<span class="sig-name descname"><span class="pre">pos</span></span><a class="headerlink" href="#re.error.pos" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>L'index dans <em>pattern</em> où la compilation a échoué (peut valoir <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.lineno">
<span class="sig-name descname"><span class="pre">lineno</span></span><a class="headerlink" href="#re.error.lineno" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>La ligne correspondant à <em>pos</em> (peut valoir <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.colno">
<span class="sig-name descname"><span class="pre">colno</span></span><a class="headerlink" href="#re.error.colno" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>La colonne correspondant à <em>pos</em> (peut valoir <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>Ajout des attributs additionnels.</p>
</div>
</dd></dl>

</section>
</section>
<section id="regular-expression-objects">
<span id="re-objects"></span><h2>Objets d'expressions rationnelles<a class="headerlink" href="#regular-expression-objects" title="Lien permanent vers ce titre">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="re.Pattern">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">Pattern</span></span><a class="headerlink" href="#re.Pattern" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Compiled regular expression object returned by <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.9: </span><a class="reference internal" href="#re.Pattern" title="re.Pattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">re.Pattern</span></code></a> supports <code class="docutils literal notranslate"><span class="pre">[]</span></code> to indicate a Unicode (str) or bytes pattern.
See <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Type Alias générique</span></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.search">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.search" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Scan through <em>string</em> looking for the first location where this regular
expression produces a match, and return a corresponding <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>.
Return <code class="docutils literal notranslate"><span class="pre">None</span></code> if no position in the string matches the pattern; note that
this is different from finding a zero-length match at some point in the string.</p>
<p>Le second paramètre <em>pos</em> (optionnel) donne l'index dans la chaîne où la recherche doit débuter ; il vaut <code class="docutils literal notranslate"><span class="pre">0</span></code> par défaut.  Cela n'est pas complètement équivalent à un <em>slicing</em> sur la chaîne ; le caractère de motif <code class="docutils literal notranslate"><span class="pre">'^'</span></code> correspond au début réel de la chaîne et aux positions juste après un saut de ligne, mais pas nécessairement à l'index où la recherche commence.</p>
<p>Le paramètre optionnel <em>endpos</em> limite la longueur sur laquelle la chaîne sera analysée ; ce sera comme si la chaîne faisait <em>endpos</em> caractères de long, donc uniquement les caractères de <em>pos</em> à <code class="docutils literal notranslate"><span class="pre">endpos</span> <span class="pre">-</span> <span class="pre">1</span></code> seront analysés pour trouver une correspondance.  Si <em>endpos</em> est inférieur à <em>pos</em>, aucune correspondance ne sera trouvée ; dit autrement, avec <em>rx</em> une expression rationnelle compilée, <code class="docutils literal notranslate"><span class="pre">rx.search(string,</span> <span class="pre">0,</span> <span class="pre">50)</span></code> est équivalent à <code class="docutils literal notranslate"><span class="pre">rx.search(string[:50],</span> <span class="pre">0)</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>     <span class="c1"># Match at index 0</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;d&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># No match; search doesn&#39;t include the &quot;d&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.match">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.match" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>If zero or more characters at the <em>beginning</em> of <em>string</em> match this regular
expression, return a corresponding <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>. Return <code class="docutils literal notranslate"><span class="pre">None</span></code> if the
string does not match the pattern; note that this is different from a
zero-length match.</p>
<p>Les paramètres optionnels <em>pos</em> et <em>endpos</em> ont le même sens que pour la méthode <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># No match as &quot;o&quot; is not at the start of &quot;dog&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Match as &quot;o&quot; is the 2nd character of &quot;dog&quot;.</span>
<span class="go">&lt;re.Match object; span=(1, 2), match=&#39;o&#39;&gt;</span>
</pre></div>
</div>
<p>Si vous voulez une recherche n'importe où dans <em>string</em>, utilisez plutôt <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> (voir aussi <a class="reference internal" href="#search-vs-match"><span class="std std-ref">Comparaison de search() et match()</span></a>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.fullmatch">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">fullmatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.fullmatch" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>If the whole <em>string</em> matches this regular expression, return a corresponding
<a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>.  Return <code class="docutils literal notranslate"><span class="pre">None</span></code> if the string does not match the pattern;
note that this is different from a zero-length match.</p>
<p>Les paramètres optionnels <em>pos</em> et <em>endpos</em> ont le même sens que pour la méthode <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o[gh]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># No match as &quot;o&quot; is not at the start of &quot;dog&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;ogre&quot;</span><span class="p">)</span>     <span class="c1"># No match as not the full string matches.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;doggie&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1"># Matches within given limits.</span>
<span class="go">&lt;re.Match object; span=(1, 3), match=&#39;og&#39;&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.split">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.split" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Identique à la fonction <a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>, en utilisant le motif compilé.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.findall">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">findall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.findall" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Similaire à la fonction <a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a>, en utilisant le motif compilé, mais accepte aussi des paramètres <em>pos</em> et <em>endpos</em> optionnels qui limitent la région de recherche comme pour <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.finditer">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">finditer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.finditer" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Similaire à la fonction <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a>, en utilisant le motif compilé, mais accepte aussi des paramètres <em>pos</em> et <em>endpos</em> optionnels qui limitent la région de recherche comme pour <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.sub">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.sub" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Identique à la fonction <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>, en utilisant le motif compilé.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.subn">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">subn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.subn" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Identique à la fonction <a class="reference internal" href="#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a>, en utilisant le motif compilé.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.flags">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">flags</span></span><a class="headerlink" href="#re.Pattern.flags" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Les options de validation de l'expression rationnelle.  Il s'agit d'une combinaison des options données à <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>, des potentielles options <code class="docutils literal notranslate"><span class="pre">(?...)</span></code> dans le motif, et des options implicites comme <a class="reference internal" href="#re.UNICODE" title="re.UNICODE"><code class="xref py py-data docutils literal notranslate"><span class="pre">UNICODE</span></code></a> si le motif est une chaîne Unicode.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.groups">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">groups</span></span><a class="headerlink" href="#re.Pattern.groups" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Le nombre de groupes de capture dans le motif.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.groupindex">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">groupindex</span></span><a class="headerlink" href="#re.Pattern.groupindex" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Un dictionnaire associant les noms de groupes symboliques définis par <code class="docutils literal notranslate"><span class="pre">(?P&lt;id&gt;)</span></code> aux groupes numérotés.  Le dictionnaire est vide si aucun groupe symbolique n'est utilisé dans le motif.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.pattern">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">pattern</span></span><a class="headerlink" href="#re.Pattern.pattern" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>La chaîne de motif depuis laquelle l'objet motif a été compilé.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>Ajout du support des fonctions <a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a> et <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a>. Les expressions régulières compilées sont considérées atomiques.</p>
</div>
</section>
<section id="match-objects">
<span id="id2"></span><h2>Objets de correspondance<a class="headerlink" href="#match-objects" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les objets de correspondance ont toujours une valeur booléenne <code class="docutils literal notranslate"><span class="pre">True</span></code>. Puisque <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> et <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> renvoient <code class="docutils literal notranslate"><span class="pre">None</span></code> quand il n'y a pas de correspondance, vous pouvez tester s'il y a eu correspondance avec une simple instruction <code class="docutils literal notranslate"><span class="pre">if</span></code> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
<span class="k">if</span> <span class="n">match</span><span class="p">:</span>
    <span class="n">process</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="re.Match">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">Match</span></span><a class="headerlink" href="#re.Match" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Match object returned by successful <code class="docutils literal notranslate"><span class="pre">match</span></code>es and <code class="docutils literal notranslate"><span class="pre">search</span></code>es.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.9: </span><a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">re.Match</span></code></a> supports <code class="docutils literal notranslate"><span class="pre">[]</span></code> to indicate a Unicode (str) or bytes match.
See <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Type Alias générique</span></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.expand">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">template</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.expand" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie la chaîne obtenue en substituant les séquences d'échappement du gabarit <em>template</em>, comme réalisé par la méthode <a class="reference internal" href="#re.Pattern.sub" title="re.Pattern.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a>. Les séquences comme <code class="docutils literal notranslate"><span class="pre">\n</span></code> sont converties vers les caractères appropriés, et les références arrières numériques (<code class="docutils literal notranslate"><span class="pre">\1</span></code>, <code class="docutils literal notranslate"><span class="pre">\2</span></code>) et nommées (<code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code>) sont remplacées par les contenus des groupes correspondant.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>Les groupes sans correspondance sont remplacés par une chaîne vide.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.group">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">group</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.group" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un ou plus sous-groupes de la correspondance.  Si un seul argument est donné, le résultat est une chaîne simple ; s'il y a plusieurs arguments, le résultat est un <em>n</em>-uplet comprenant un élément par argument. Sans arguments, <em>group1</em> vaut par défaut zéro (la correspondance entière est renvoyée). Si un argument <em>groupN</em> vaut zéro, l'élément associé sera la chaîne de correspondance entière ; s'il est dans l'intervalle fermé [1..99], c'est la correspondance avec le groupe de parenthèses associé.  Si un numéro de groupe est négatif ou supérieur au nombre de groupes définis dans le motif, une exception <code class="xref py py-exc docutils literal notranslate"><span class="pre">indexError</span></code> est levée. Si un groupe est contenu dans une partie du motif qui n'a aucune correspondance, l'élément associé sera <code class="docutils literal notranslate"><span class="pre">None</span></code>. Si un groupe est contenu dans une partie du motif qui a plusieurs correspondances, seule la dernière correspondance est renvoyée.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>       <span class="c1"># The entire match</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># The first parenthesized subgroup.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>       <span class="c1"># The second parenthesized subgroup.</span>
<span class="go">&#39;Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># Multiple arguments give us a tuple.</span>
<span class="go">(&#39;Isaac&#39;, &#39;Newton&#39;)</span>
</pre></div>
</div>
<p>Si l'expression rationnelle utilise la syntaxe <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>, les arguments <em>groupN</em> peuvent alors aussi être des chaînes identifiant les groupes par leurs noms.  Si une chaîne donnée en argument n'est pas utilisée comme nom de groupe dans le motif, une exception <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> est levée.</p>
<p>Un exemple modérément compliqué :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;first_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;last_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p>Les groupes nommés peuvent aussi être référencés par leur index :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p>Si un groupe a plusieurs correspondances, seule la dernière est accessible :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(..)+&quot;</span><span class="p">,</span> <span class="s2">&quot;a1b2c3&quot;</span><span class="p">)</span>  <span class="c1"># Matches 3 times.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                        <span class="c1"># Returns only the last match.</span>
<span class="go">&#39;c3&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.__getitem__">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.__getitem__" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cela est identique à <code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>.  Cela permet un accès plus facile à un groupe individuel depuis une correspondance :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>       <span class="c1"># The entire match</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>       <span class="c1"># The first parenthesized subgroup.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>       <span class="c1"># The second parenthesized subgroup.</span>
<span class="go">&#39;Newton&#39;</span>
</pre></div>
</div>
<p>Named groups are supported as well:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;first_name&#39;</span><span class="p">]</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;last_name&#39;</span><span class="p">]</span>
<span class="go">&#39;Newton&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.groups">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">groups</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.groups" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un <em>n</em>-uplet contenant tous les sous-groupes de la correspondance, de 1 jusqu'au nombre de groupes dans le motif.  L'argument <em>default</em> est utilisé pour les groupes sans correspondance ; il vaut <code class="docutils literal notranslate"><span class="pre">None</span></code> par défaut.</p>
<p>Par exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.(\d+)&quot;</span><span class="p">,</span> <span class="s2">&quot;24.1632&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;24&#39;, &#39;1632&#39;)</span>
</pre></div>
</div>
<p>Si on rend la partie décimale et tout ce qui la suit optionnels, tous les groupes ne figureront pas dans la correspondance.  Ces groupes sans correspondance vaudront <code class="docutils literal notranslate"><span class="pre">None</span></code> sauf si une autre valeur est donnée à l'argument <em>default</em> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.?(\d+)?&quot;</span><span class="p">,</span> <span class="s2">&quot;24&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>      <span class="c1"># Second group defaults to None.</span>
<span class="go">(&#39;24&#39;, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>   <span class="c1"># Now, the second group defaults to &#39;0&#39;.</span>
<span class="go">(&#39;24&#39;, &#39;0&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.groupdict">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">groupdict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.groupdict" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un dictionnaire contenant tous les sous-groupes <em>nommés</em> de la correspondance, accessibles par leurs noms.  L'argument <em>default</em> est utilisé pour les groupes qui ne figurent pas dans la correspondance ; il vaut <code class="docutils literal notranslate"><span class="pre">None</span></code> par défaut.  Par exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
<span class="go">{&#39;first_name&#39;: &#39;Malcolm&#39;, &#39;last_name&#39;: &#39;Reynolds&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.start">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.start" title="Lien permanent vers cette définition">¶</a></dt>
<dt class="sig sig-object py" id="re.Match.end">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">end</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.end" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie les indices de début et de fin de la sous-chaîne correspondant au groupe <em>group</em> ; <em>group</em> vaut par défaut zéro (pour récupérer les indices de la correspondance complète). Renvoie <code class="docutils literal notranslate"><span class="pre">-1</span></code> si <em>group</em> existe mais ne figure pas dans la correspondance.  Pour un objet de correspondance <em>m</em>, et un groupe <em>g</em> qui y figure, la sous-chaîne correspondant au groupe <em>g</em> (équivalente à <code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>) est</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">string</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">g</span><span class="p">):</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">g</span><span class="p">)]</span>
</pre></div>
</div>
<p>Notez que <code class="docutils literal notranslate"><span class="pre">m.start(group)</span></code> sera égal à <code class="docutils literal notranslate"><span class="pre">m.end(group)</span></code> si <em>group</em> correspond à une chaîne vide.  Par exemple, après <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">re.search('b(c?)',</span> <span class="pre">'cba')</span></code>, <code class="docutils literal notranslate"><span class="pre">m.start(0)</span></code> vaut 1, <code class="docutils literal notranslate"><span class="pre">m.end(0)</span></code> vaut 2, <code class="docutils literal notranslate"><span class="pre">m.start(1)</span></code> et <code class="docutils literal notranslate"><span class="pre">m.end(1)</span></code> valent tous deux 2, et <code class="docutils literal notranslate"><span class="pre">m.start(2)</span></code> lève une exception <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>.</p>
<p>Un exemple qui supprimera <em>remove_this</em> d'une adresse mail :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot;tony@tiremove_thisger.net&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;remove_this&quot;</span><span class="p">,</span> <span class="n">email</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="p">[:</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span> <span class="o">+</span> <span class="n">email</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">():]</span>
<span class="go">&#39;tony@tiger.net&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.span">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">span</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.span" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Pour un objet de correspondance <em>m</em>, renvoie la paire <code class="docutils literal notranslate"><span class="pre">(m.start(group),</span> <span class="pre">m.end(group))</span></code>. Notez que si <em>group</em> ne figure pas dans la correspondance, <code class="docutils literal notranslate"><span class="pre">(-1,</span> <span class="pre">-1)</span></code> est renvoyé. <em>group</em> vaut par défaut zéro, pour la correspondance entière.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.pos">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">pos</span></span><a class="headerlink" href="#re.Match.pos" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>La valeur de <em>pos</em> qui a été passée à la méthode <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> ou <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> d'un <a class="reference internal" href="#re-objects"><span class="std std-ref">objet expression rationnelle</span></a>.  C'est l'index dans la chaîne à partir duquel le moteur d'expressions rationnelles recherche une correspondance.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.endpos">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">endpos</span></span><a class="headerlink" href="#re.Match.endpos" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>La valeur de <em>endpos</em> qui a été passée à la méthode <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> ou <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> d'un <a class="reference internal" href="#re-objects"><span class="std std-ref">objet expression rationnelle</span></a>.  C'est l'index dans la chaîne que le moteur d'expressions rationnelles ne dépassera pas.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.lastindex">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">lastindex</span></span><a class="headerlink" href="#re.Match.lastindex" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>L'index entier du dernier groupe de capture validé, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> si aucun groupe ne correspondait. Par exemple, les expressions <code class="docutils literal notranslate"><span class="pre">(a)b</span></code>, <code class="docutils literal notranslate"><span class="pre">((a)(b))</span></code> et <code class="docutils literal notranslate"><span class="pre">((ab))</span></code> auront un <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">1</span></code> si appliquées à la chaîne <code class="docutils literal notranslate"><span class="pre">'ab'</span></code>, alors que l'expression <code class="docutils literal notranslate"><span class="pre">(a)(b)</span></code> aura un <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">2</span></code> si appliquée à la même chaîne.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.lastgroup">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">lastgroup</span></span><a class="headerlink" href="#re.Match.lastgroup" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Le nom du dernier groupe capturant validé, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> si le groupe n'a pas de nom, ou si aucun groupe ne correspondait.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.re">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">re</span></span><a class="headerlink" href="#re.Match.re" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p><a class="reference internal" href="#re-objects"><span class="std std-ref">L'expression rationnelle</span></a> dont la méthode <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> ou <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> a produit cet objet de correspondance.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.string">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">string</span></span><a class="headerlink" href="#re.Match.string" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>La chaîne passée à <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> ou <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>Ajout du support des fonctions <a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a> et <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a>. Les objets correspondants sont considérés atomiques.</p>
</div>
</section>
<section id="regular-expression-examples">
<span id="re-examples"></span><h2>Exemples d'expressions rationnelles<a class="headerlink" href="#regular-expression-examples" title="Lien permanent vers ce titre">¶</a></h2>
<section id="checking-for-a-pair">
<h3>Rechercher une paire<a class="headerlink" href="#checking-for-a-pair" title="Lien permanent vers ce titre">¶</a></h3>
<p>Dans cet exemple, nous nous aidons de la fonction suivante pour afficher de manière plus jolie les objets qui correspondent :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">displaymatch</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="s1">&#39;&lt;Match: </span><span class="si">%r</span><span class="s1">, groups=</span><span class="si">%r</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
</pre></div>
</div>
<p>Supposez que vous écriviez un jeu de poker où la main d'un joueur est représentée par une chaîne de 5 caractères avec chaque caractère représentant une carte, « a » pour l'as, « k » pour le roi (<em>king</em>), « q » pour la reine (<em>queen</em>), « j » pour le valet (<em>jack</em>), « t » pour 10 (<em>ten</em>), et les caractères de « 2 » à « 9 » représentant les cartes avec ces valeurs.</p>
<p>Pour vérifier qu'une chaîne donnée est une main valide, on pourrait faire comme suit :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">valid</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[a2-9tjqk]</span><span class="si">{5}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5q&quot;</span><span class="p">))</span>  <span class="c1"># Valid.</span>
<span class="go">&quot;&lt;Match: &#39;akt5q&#39;, groups=()&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5e&quot;</span><span class="p">))</span>  <span class="c1"># Invalid.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt&quot;</span><span class="p">))</span>    <span class="c1"># Invalid.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;727ak&quot;</span><span class="p">))</span>  <span class="c1"># Valid.</span>
<span class="go">&quot;&lt;Match: &#39;727ak&#39;, groups=()&gt;&quot;</span>
</pre></div>
</div>
<p>La dernière main, <code class="docutils literal notranslate"><span class="pre">&quot;727ak&quot;</span></code>, contenait une paire, deux cartes de la même valeur. Pour valider cela avec une expression rationnelle, on pourrait utiliser des références arrière comme :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">))</span>     <span class="c1"># Pair of 7s.</span>
<span class="go">&quot;&lt;Match: &#39;717&#39;, groups=(&#39;7&#39;,)&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">))</span>     <span class="c1"># No pairs.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">))</span>     <span class="c1"># Pair of aces.</span>
<span class="go">&quot;&lt;Match: &#39;354aa&#39;, groups=(&#39;a&#39;,)&gt;&quot;</span>
</pre></div>
</div>
<p>Pour trouver de quelle carte est composée la paire, on pourrait utiliser la méthode <a class="reference internal" href="#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a> de l'objet de correspondance de la manière suivante :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;7&#39;</span>

<span class="go"># Error because re.match() returns None, which doesn&#39;t have a group() method:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#23&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">,</span> <span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;NoneType&#39; object has no attribute &#39;group&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
</pre></div>
</div>
</section>
<section id="simulating-scanf">
<h3>Simuler <em>scanf()</em><a class="headerlink" href="#simulating-scanf" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-40">Python does not currently have an equivalent to <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code>.  Regular
expressions are generally more powerful, though also more verbose, than
<code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> format strings.  The table below offers some more-or-less
equivalent mappings between <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> format tokens and regular
expressions.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 42%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> Token</p></th>
<th class="head"><p>Expression rationnelle</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%5c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.{5}</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%d</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?\d+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%e</span></code>, <code class="docutils literal notranslate"><span class="pre">%E</span></code>, <code class="docutils literal notranslate"><span class="pre">%f</span></code>, <code class="docutils literal notranslate"><span class="pre">%g</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%i</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX][\dA-Fa-f]+|0[0-7]*|\d+)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%o</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?[0-7]+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%s</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\S+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%u</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\d+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%x</span></code>, <code class="docutils literal notranslate"><span class="pre">%X</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX])?[\dA-Fa-f]+</span></code></p></td>
</tr>
</tbody>
</table>
<p>Pour extraire le nom de fichier et les nombres depuis une chaîne comme</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">sendmail</span> <span class="o">-</span> <span class="mi">0</span> <span class="n">errors</span><span class="p">,</span> <span class="mi">4</span> <span class="n">warnings</span>
</pre></div>
</div>
<p>you would use a <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> format like</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">s</span> <span class="o">-</span> <span class="o">%</span><span class="n">d</span> <span class="n">errors</span><span class="p">,</span> <span class="o">%</span><span class="n">d</span> <span class="n">warnings</span>
</pre></div>
</div>
<p>L'expression rationnelle équivalente serait</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span>\<span class="n">S</span><span class="o">+</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">errors</span><span class="p">,</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">warnings</span>
</pre></div>
</div>
</section>
<section id="search-vs-match">
<span id="id3"></span><h3>Comparaison de <em>search()</em> et <em>match()</em><a class="headerlink" href="#search-vs-match" title="Lien permanent vers ce titre">¶</a></h3>
<p>Python offre différentes opérations primitives basées sur des expressions régulières :</p>
<ul class="simple">
<li><p><a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> cherche une correspondance uniquement au début de la chaîne de caractères</p></li>
<li><p><a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a> cherche une correspondance n'importe où dans la chaîne de caractères (ce que fait Perl par défaut)</p></li>
<li><p><a class="reference internal" href="#re.fullmatch" title="re.fullmatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.fullmatch()</span></code></a> cherche une correspondance avec l'intégralité de la chaîne de caractères.</p></li>
</ul>
<p>Par exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>   <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(2, 3), match=&#39;c&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;p.*n&quot;</span><span class="p">,</span> <span class="s2">&quot;python&quot;</span><span class="p">)</span> <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(0, 6), match=&#39;python&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;r.*n&quot;</span><span class="p">,</span> <span class="s2">&quot;python&quot;</span><span class="p">)</span> <span class="c1"># No match</span>
</pre></div>
</div>
<p>Les expressions rationnelles commençant par <code class="docutils literal notranslate"><span class="pre">'^'</span></code> peuvent être utilisées avec <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> pour restreindre la recherche au début de la chaîne :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^a&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;a&#39;&gt;</span>
</pre></div>
</div>
<p>Notez cependant qu'en mode <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a>, <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> ne recherche qu'au début de la chaîne, alors que <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> avec une expression rationnelle commençant par <code class="docutils literal notranslate"><span class="pre">'^'</span></code> recherchera au début de chaque ligne.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;A</span><span class="se">\n</span><span class="s2">B</span><span class="se">\n</span><span class="s2">X&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^X&quot;</span><span class="p">,</span> <span class="s2">&quot;A</span><span class="se">\n</span><span class="s2">B</span><span class="se">\n</span><span class="s2">X&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(4, 5), match=&#39;X&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="making-a-phonebook">
<h3>Construire un répertoire téléphonique<a class="headerlink" href="#making-a-phonebook" title="Lien permanent vers ce titre">¶</a></h3>
<p><a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> découpe une chaîne en une liste délimitée par le motif donné.  La méthode est inestimable pour convertir des données textuelles vers des structures de données qui peuvent être lues et modifiées par Python comme démontré dans l'exemple suivant qui crée un répertoire téléphonique.</p>
<p>Tout d'abord, voici l'entrée. Elle provient normalement d'un fichier, nous utilisons ici une chaîne à guillemets triples</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Ross McFluff: 834.345.1254 155 Elm Street</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="s2">Ronald Heathmore: 892.345.3428 436 Finley Avenue</span>
<span class="gp">... </span><span class="s2">Frank Burger: 925.541.7625 662 South Dogwood Way</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="s2">Heather Albrecht: 548.326.4584 919 Park Place&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Les entrées sont séparées par un saut de ligne ou plus. Nous convertissons maintenant la chaîne en une liste où chaque ligne non vide aura sa propre entrée :</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">+&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span>
<span class="go">[&#39;Ross McFluff: 834.345.1254 155 Elm Street&#39;,</span>
<span class="go">&#39;Ronald Heathmore: 892.345.3428 436 Finley Avenue&#39;,</span>
<span class="go">&#39;Frank Burger: 925.541.7625 662 South Dogwood Way&#39;,</span>
<span class="go">&#39;Heather Albrecht: 548.326.4584 919 Park Place&#39;]</span>
</pre></div>
</div>
<p>Finalement, on sépare chaque entrée en une liste avec prénom, nom, numéro de téléphone et adresse.  Nous utilisons le paramètre <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> de <a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> parce que l'adresse contient des espaces, qui sont notre motif de séparation :</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155 Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436 Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662 South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919 Park Place&#39;]]</span>
</pre></div>
</div>
<p>Le motif <code class="docutils literal notranslate"><span class="pre">:?</span></code> trouve les deux points derrière le nom de famille, pour qu'ils n'apparaissent pas dans la liste résultante. Avec un <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> de <code class="docutils literal notranslate"><span class="pre">4</span></code>, nous pourrions séparer le numéro du nom de la rue :</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155&#39;, &#39;Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436&#39;, &#39;Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662&#39;, &#39;South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919&#39;, &#39;Park Place&#39;]]</span>
</pre></div>
</div>
</section>
<section id="text-munging">
<h3>Mélanger les lettres des mots<a class="headerlink" href="#text-munging" title="Lien permanent vers ce titre">¶</a></h3>
<p><a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> remplace toutes les occurrences d'un motif par une chaîne ou le résultat d'une fonction.  Cet exemple le montre, en utilisant <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> avec une fonction qui mélange aléatoirement les caractères de chaque mot dans une phrase (à l'exception des premiers et derniers caractères) :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">inner_word</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Professor Abdolmalek, please report your absences promptly.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.&#39;</span>
</pre></div>
</div>
</section>
<section id="finding-all-adverbs">
<h3>Trouver tous les adverbes<a class="headerlink" href="#finding-all-adverbs" title="Lien permanent vers ce titre">¶</a></h3>
<p><a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a> trouve <em>toutes</em> les occurrences d'un motif, pas juste la première comme le fait <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>.  Par exemple, si un écrivain voulait trouver tous les adverbes dans un texte, il devrait utiliser <a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a> de la manière suivante :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly\b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">[&#39;carefully&#39;, &#39;quickly&#39;]</span>
</pre></div>
</div>
</section>
<section id="finding-all-adverbs-and-their-positions">
<h3>Trouver tous les adverbes et leurs positions<a class="headerlink" href="#finding-all-adverbs-and-their-positions" title="Lien permanent vers ce titre">¶</a></h3>
<p>If one wants more information about all matches of a pattern than the matched
text, <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> is useful as it provides <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> objects
instead of strings.  Continuing with the previous example, if a writer wanted
to find all of the adverbs <em>and their positions</em> in some text, they would use
<a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> in the following manner:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly\b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
<span class="go">07-16: carefully</span>
<span class="go">40-47: quickly</span>
</pre></div>
</div>
</section>
<section id="raw-string-notation">
<h3>Notation brute de chaînes<a class="headerlink" href="#raw-string-notation" title="Lien permanent vers ce titre">¶</a></h3>
<p>La notation brute de chaînes (<code class="docutils literal notranslate"><span class="pre">r&quot;text&quot;</span></code>) garde saines les expressions rationnelles.  Sans elle, chaque <em>backslash</em> (<code class="docutils literal notranslate"><span class="pre">'\'</span></code>) dans une expression rationnelle devrait être préfixé d'un autre <em>backslash</em> pour l'échapper.  Par exemple, les deux lignes de code suivantes sont fonctionnellement identiques :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W(.)\1\W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">W(.)</span><span class="se">\\</span><span class="s2">1</span><span class="se">\\</span><span class="s2">W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
</pre></div>
</div>
<p>Pour rechercher un <em>backslash</em> littéral, il faut l'échapper dans l'expression rationnelle.  Avec la notation brute, cela signifie <code class="docutils literal notranslate"><span class="pre">r&quot;\\&quot;</span></code>.  Sans elle, il faudrait utiliser <code class="docutils literal notranslate"><span class="pre">&quot;\\\\&quot;</span></code>, faisant que les deux lignes de code suivantes sont fonctionnellement identiques :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="writing-a-tokenizer">
<h3>Écrire un analyseur lexical<a class="headerlink" href="#writing-a-tokenizer" title="Lien permanent vers ce titre">¶</a></h3>
<p>Un <a class="reference external" href="https://en.wikipedia.org/wiki/Lexical_analysis">analyseur lexical ou scanner</a> analyse une chaîne pour catégoriser les groupes de caractères.  C'est une première étape utile dans l'écriture d'un compilateur ou d'un interpréteur.</p>
<p>Les catégories de texte sont spécifiées par des expressions rationnelles.  La technique est de les combiner dans une unique expression rationnelle maîtresse, et de boucler sur les correspondances successives :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="k">class</span> <span class="nc">Token</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">line</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">column</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
    <span class="n">keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="s1">&#39;FOR&#39;</span><span class="p">,</span> <span class="s1">&#39;NEXT&#39;</span><span class="p">,</span> <span class="s1">&#39;GOSUB&#39;</span><span class="p">,</span> <span class="s1">&#39;RETURN&#39;</span><span class="p">}</span>
    <span class="n">token_specification</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;\d+(\.\d*)?&#39;</span><span class="p">),</span>  <span class="c1"># Integer or decimal number</span>
        <span class="p">(</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;:=&#39;</span><span class="p">),</span>           <span class="c1"># Assignment operator</span>
        <span class="p">(</span><span class="s1">&#39;END&#39;</span><span class="p">,</span>      <span class="sa">r</span><span class="s1">&#39;;&#39;</span><span class="p">),</span>            <span class="c1"># Statement terminator</span>
        <span class="p">(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[A-Za-z]+&#39;</span><span class="p">),</span>    <span class="c1"># Identifiers</span>
        <span class="p">(</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[+\-*/]&#39;</span><span class="p">),</span>      <span class="c1"># Arithmetic operators</span>
        <span class="p">(</span><span class="s1">&#39;NEWLINE&#39;</span><span class="p">,</span>  <span class="sa">r</span><span class="s1">&#39;\n&#39;</span><span class="p">),</span>           <span class="c1"># Line endings</span>
        <span class="p">(</span><span class="s1">&#39;SKIP&#39;</span><span class="p">,</span>     <span class="sa">r</span><span class="s1">&#39;[ \t]+&#39;</span><span class="p">),</span>       <span class="c1"># Skip over spaces and tabs</span>
        <span class="p">(</span><span class="s1">&#39;MISMATCH&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;.&#39;</span><span class="p">),</span>            <span class="c1"># Any other character</span>
    <span class="p">]</span>
    <span class="n">tok_regex</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;(?P&lt;</span><span class="si">%s</span><span class="s1">&gt;</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">token_specification</span><span class="p">)</span>
    <span class="n">line_num</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">line_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">mo</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">tok_regex</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">lastgroup</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">-</span> <span class="n">line_start</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NUMBER&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;ID&#39;</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span><span class="p">:</span>
            <span class="n">line_start</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">line_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;SKIP&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;MISMATCH&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s1"> unexpected on line </span><span class="si">{</span><span class="n">line_num</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">line_num</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>

<span class="n">statements</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    IF quantity THEN</span>
<span class="s1">        total := total + price * quantity;</span>
<span class="s1">        tax := price * 0.05;</span>
<span class="s1">    ENDIF;</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">statements</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
</pre></div>
</div>
<p>L'analyseur produit la sortie suivante :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">17</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">33</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">41</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;tax&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">27</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<dl class="citation">
<dt class="label" id="frie09"><span class="brackets"><a class="fn-backref" href="#id1">Frie09</a></span></dt>
<dd><p><em>Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, 2009</em>. La troisième édition de ce livre ne couvre plus du tout Python, mais la première version explique en détails comment écrire de bonnes expressions rationnelles.</p>
</dd>
</dl>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Opérations à base d'expressions rationnelles</a><ul>
<li><a class="reference internal" href="#regular-expression-syntax">Syntaxe des expressions rationnelles</a></li>
<li><a class="reference internal" href="#module-contents">Contenu du module</a><ul>
<li><a class="reference internal" href="#flags">Flags</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#exceptions">Exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regular-expression-objects">Objets d'expressions rationnelles</a></li>
<li><a class="reference internal" href="#match-objects">Objets de correspondance</a></li>
<li><a class="reference internal" href="#regular-expression-examples">Exemples d'expressions rationnelles</a><ul>
<li><a class="reference internal" href="#checking-for-a-pair">Rechercher une paire</a></li>
<li><a class="reference internal" href="#simulating-scanf">Simuler <em>scanf()</em></a></li>
<li><a class="reference internal" href="#search-vs-match">Comparaison de <em>search()</em> et <em>match()</em></a></li>
<li><a class="reference internal" href="#making-a-phonebook">Construire un répertoire téléphonique</a></li>
<li><a class="reference internal" href="#text-munging">Mélanger les lettres des mots</a></li>
<li><a class="reference internal" href="#finding-all-adverbs">Trouver tous les adverbes</a></li>
<li><a class="reference internal" href="#finding-all-adverbs-and-their-positions">Trouver tous les adverbes et leurs positions</a></li>
<li><a class="reference internal" href="#raw-string-notation">Notation brute de chaînes</a></li>
<li><a class="reference internal" href="#writing-a-tokenizer">Écrire un analyseur lexical</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="string.html"
                          title="Chapitre précédent"><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code> — Opérations usuelles sur des chaînes</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="difflib.html"
                          title="Chapitre suivant"><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code> — Utilitaires pour le calcul des deltas</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/re.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="difflib.html" title="difflib — Utilitaires pour le calcul des deltas"
             >suivant</a> |</li>
        <li class="right" >
          <a href="string.html" title="string — Opérations usuelles sur des chaînes"
             >précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La bibliothèque standard</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" >Services de Manipulation de Texte</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Opérations à base d'expressions rationnelles</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Mis à jour le oct. 26, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Créé en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>