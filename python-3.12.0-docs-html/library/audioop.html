
<!DOCTYPE html>

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="audioop — Manipulation de données audio brutes" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/audioop.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Le module audioop permet d'effectuer des opérations utiles sur des fragments sonores. Ceux-ci sont constitués d'échantillons audio, suite d'entiers signés de taille 8, 16, 24 ou 32 bits. Ils sont s..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Le module audioop permet d'effectuer des opérations utiles sur des fragments sonores. Ceux-ci sont constitués d'échantillons audio, suite d'entiers signés de taille 8, 16, 24 ou 32 bits. Ils sont s..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>audioop — Manipulation de données audio brutes &#8212; Documentation Python 3.12.0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=b37c26da2f7529d09fe70b41c4b2133fe4931a90" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Recherchez dans Documentation Python 3.12.0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="À propos de ces documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="cgi --- Common Gateway Interface support" href="cgi.html" />
    <link rel="prev" title="aifc — Lis et écrit dans les fichiers AIFF et AIFC" href="aifc.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/audioop.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" />
                <input type="submit" value="Go"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="aifc.html"
                          title="Chapitre précédent"><code class="xref py py-mod docutils literal notranslate"><span class="pre">aifc</span></code> — Lis et écrit dans les fichiers AIFF et AIFC</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="cgi.html"
                          title="Chapitre suivant"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code> --- Common Gateway Interface support</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/audioop.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="cgi.html" title="cgi --- Common Gateway Interface support"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="aifc.html" title="aifc — Lis et écrit dans les fichiers AIFF et AIFC"
             accesskey="P">précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La bibliothèque standard</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="superseded.html" accesskey="U">Modules remplacés</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code> — Manipulation de données audio brutes</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-audioop">
<span id="audioop-manipulate-raw-audio-data"></span><h1><a class="reference internal" href="#module-audioop" title="audioop: Manipulate raw audio data. (obsolète)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code></a> — Manipulation de données audio brutes<a class="headerlink" href="#module-audioop" title="Lien permanent vers ce titre">¶</a></h1>
<div class="deprecated-removed">
<p><span class="versionmodified">Obsolète depuis la version 3.11, sera supprimé dans la version 3.13: </span>The <a class="reference internal" href="#module-audioop" title="audioop: Manipulate raw audio data. (obsolète)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code></a> module is deprecated
(see <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0594/#audioop"><strong>PEP 594</strong></a> for details).</p>
</div>
<hr class="docutils" />
<p>Le module <a class="reference internal" href="#module-audioop" title="audioop: Manipulate raw audio data. (obsolète)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code></a> permet d'effectuer des opérations utiles sur des fragments sonores. Ceux-ci sont constitués d'échantillons audio, suite d'entiers signés de taille 8, 16, 24 ou 32 bits. Ils sont sauvegardés dans des <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objets octet-compatibles</span></a>. Tous les nombres sont des entiers, sauf mention particulière.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.4: </span>Ajout de la prise en charge d'échantillons 24 bits. Toutes les fonctions acceptent maintenant les <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objets octet-compatibles</span></a>. Une chaîne de caractères reçue en entrée lève immédiatement une erreur.</p>
</div>
<p id="index-1">Ce module prend en charge les encodages de la loi A, de la loi u et les encodages Intel/DVI ADPCM.</p>
<p>Mis à part quelques opérations plus complexes ne prenant que des échantillons de 16 bits, la taille de l'échantillon (en octets) est toujours un paramètre de l'opération.</p>
<p>Le module définit les fonctions et variables suivantes :</p>
<dl class="py exception">
<dt class="sig sig-object py" id="audioop.error">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">error</span></span><a class="headerlink" href="#audioop.error" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cette exception est levée pour toutes les erreurs, comme un nombre inconnu d'octets par échantillon, etc.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.add">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.add" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un fragment constitué de l'addition des deux échantillons fournis comme paramètres. <em>width</em> est la largeur de l'échantillon en octets, soit <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code> ou <code class="docutils literal notranslate"><span class="pre">4</span></code>. Les deux fragments doivent avoir la même longueur. Les échantillons sont tronqués en cas de débordement.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.adpcm2lin">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">adpcm2lin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adpcmfragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.adpcm2lin" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Decode an Intel/DVI ADPCM coded fragment to a linear fragment.  See the
description of <a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><code class="xref py py-func docutils literal notranslate"><span class="pre">lin2adpcm()</span></code></a> for details on ADPCM coding. Return a tuple
<code class="docutils literal notranslate"><span class="pre">(sample,</span> <span class="pre">newstate)</span></code> where the sample has the width specified in <em>width</em>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.alaw2lin">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">alaw2lin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.alaw2lin" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Convert sound fragments in a-LAW encoding to linearly encoded sound fragments.
a-LAW encoding always uses 8 bits samples, so <em>width</em> refers only to the sample
width of the output fragment here.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.avg">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">avg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.avg" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie la moyenne prise sur l'ensemble des échantillons du fragment.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.avgpp">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">avgpp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.avgpp" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Return the average peak-peak value over all samples in the fragment. No
filtering is done, so the usefulness of this routine is questionable.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.bias">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">bias</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.bias" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Return a fragment that is the original fragment with a bias added to each
sample.  Samples wrap around in case of overflow.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.byteswap">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">byteswap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.byteswap" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>&quot;Byteswap&quot; all samples in a fragment and returns the modified fragment.
Converts big-endian samples to little-endian and vice versa.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.cross">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">cross</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.cross" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Return the number of zero crossings in the fragment passed as an argument.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.findfactor">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">findfactor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.findfactor" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Return a factor <em>F</em> such that <code class="docutils literal notranslate"><span class="pre">rms(add(fragment,</span> <span class="pre">mul(reference,</span> <span class="pre">-F)))</span></code> is
minimal, i.e., return the factor with which you should multiply <em>reference</em> to
make it match as well as possible to <em>fragment</em>.  The fragments should both
contain 2-byte samples.</p>
<p>Le temps pris par cette routine est proportionnel à <code class="docutils literal notranslate"><span class="pre">len(fragment)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.findfit">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">findfit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.findfit" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Try to match <em>reference</em> as well as possible to a portion of <em>fragment</em> (which
should be the longer fragment).  This is (conceptually) done by taking slices
out of <em>fragment</em>, using <a class="reference internal" href="#audioop.findfactor" title="audioop.findfactor"><code class="xref py py-func docutils literal notranslate"><span class="pre">findfactor()</span></code></a> to compute the best match, and
minimizing the result.  The fragments should both contain 2-byte samples.
Return a tuple <code class="docutils literal notranslate"><span class="pre">(offset,</span> <span class="pre">factor)</span></code> where <em>offset</em> is the (integer) offset into
<em>fragment</em> where the optimal match started and <em>factor</em> is the (floating-point)
factor as per <a class="reference internal" href="#audioop.findfactor" title="audioop.findfactor"><code class="xref py py-func docutils literal notranslate"><span class="pre">findfactor()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.findmax">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">findmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.findmax" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Search <em>fragment</em> for a slice of length <em>length</em> samples (not bytes!) with
maximum energy, i.e., return <em>i</em> for which <code class="docutils literal notranslate"><span class="pre">rms(fragment[i*2:(i+length)*2])</span></code>
is maximal.  The fragments should both contain 2-byte samples.</p>
<p>La routine s'exécute en un temps proportionnel à <code class="docutils literal notranslate"><span class="pre">len(fragment)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.getsample">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">getsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.getsample" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie la valeur de l'échantillon à l'indice <em>index</em> dans le fragment.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.lin2adpcm">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">lin2adpcm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.lin2adpcm" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Convert samples to 4 bit Intel/DVI ADPCM encoding.  ADPCM coding is an adaptive
coding scheme, whereby each 4 bit number is the difference between one sample
and the next, divided by a (varying) step.  The Intel/DVI ADPCM algorithm has
been selected for use by the IMA, so it may well become a standard.</p>
<p><em>state</em> is a tuple containing the state of the coder.  The coder returns a tuple
<code class="docutils literal notranslate"><span class="pre">(adpcmfrag,</span> <span class="pre">newstate)</span></code>, and the <em>newstate</em> should be passed to the next call
of <a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><code class="xref py py-func docutils literal notranslate"><span class="pre">lin2adpcm()</span></code></a>.  In the initial call, <code class="docutils literal notranslate"><span class="pre">None</span></code> can be passed as the state.
<em>adpcmfrag</em> is the ADPCM coded fragment packed 2 4-bit values per byte.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.lin2alaw">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">lin2alaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.lin2alaw" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Convert samples in the audio fragment to a-LAW encoding and return this as a
bytes object.  a-LAW is an audio encoding format whereby you get a dynamic
range of about 13 bits using only 8 bit samples.  It is used by the Sun audio
hardware, among others.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.lin2lin">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">lin2lin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newwidth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.lin2lin" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Convertit des échantillons pour les formats à 1, 2, 3, et 4 octets.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In some audio formats, such as .WAV files, 16, 24 and 32 bit samples are
signed, but 8 bit samples are unsigned.  So when converting to 8 bit wide
samples for these formats, you need to also add 128 to the result:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">new_frames</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">lin2lin</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">old_width</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">new_frames</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">bias</span><span class="p">(</span><span class="n">new_frames</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
<p>Le même procédé, mais inversé, doit être suivi lorsqu'on exécute une conversion d'échantillons de 8 bits à 16, 24 ou 32 bits.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.lin2ulaw">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">lin2ulaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.lin2ulaw" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Convert samples in the audio fragment to u-LAW encoding and return this as a
bytes object.  u-LAW is an audio encoding format whereby you get a dynamic
range of about 14 bits using only 8 bit samples.  It is used by the Sun audio
hardware, among others.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.max">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.max" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie la <em>valeur absolue</em> maximale de tous les échantillons du fragment.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.maxpp">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">maxpp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.maxpp" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Return the maximum peak-peak value in the sound fragment.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.minmax">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">minmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.minmax" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un <em>n</em>-uplet contenant les valeurs maximale et minimale de tous les échantillons du fragment sonore.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.mul">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">mul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.mul" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un fragment contenant tous les échantillons du fragment original multipliés par la valeur à décimale <em>factor</em>. Les échantillons sont tronqués en cas de débordement.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.ratecv">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">ratecv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nchannels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inrate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outrate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">weightA</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">weightB</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#audioop.ratecv" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Transforme la fréquence d'échantillonnage du fragment d'entrée.</p>
<p><em>state</em> is a tuple containing the state of the converter.  The converter returns
a tuple <code class="docutils literal notranslate"><span class="pre">(newfragment,</span> <span class="pre">newstate)</span></code>, and <em>newstate</em> should be passed to the next
call of <a class="reference internal" href="#audioop.ratecv" title="audioop.ratecv"><code class="xref py py-func docutils literal notranslate"><span class="pre">ratecv()</span></code></a>.  The initial call should pass <code class="docutils literal notranslate"><span class="pre">None</span></code> as the state.</p>
<p>Les arguments <em>weightA</em> et <em>weightB</em> sont les paramètres d'un filtre numérique simple et ont comme valeur par défaut <code class="docutils literal notranslate"><span class="pre">1</span></code> et <code class="docutils literal notranslate"><span class="pre">0</span></code>, respectivement.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.reverse">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">reverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.reverse" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Inverse les échantillons dans un fragment et renvoie le fragment modifié.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.rms">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">rms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.rms" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie la moyenne quadratique du fragment, c'est-à-dire <code class="docutils literal notranslate"><span class="pre">sqrt(sum(S_i^2)/n)</span></code>.</p>
<p>C'est une mesure de la puissance dans un signal audio.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.tomono">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">tomono</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lfactor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rfactor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.tomono" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Transforme un fragment stéréo en fragment mono. Le canal de gauche est multiplié par <em>lfactor</em> et le canal de droite par <em>rfactor</em> avant d'additionner les deux canaux afin d'obtenir un signal mono.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.tostereo">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">tostereo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lfactor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rfactor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.tostereo" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Génère un fragment stéréo à partir d'un fragment mono. Chaque paire d'échantillons dans le fragment stéréo est obtenue à partir de l'échantillon mono de la façon suivante : les échantillons du canal de gauche sont multipliés par <em>lfactor</em> et les échantillons du canal de droite, par <em>rfactor</em>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.ulaw2lin">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">ulaw2lin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.ulaw2lin" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Convert sound fragments in u-LAW encoding to linearly encoded sound fragments.
u-LAW encoding always uses 8 bits samples, so <em>width</em> refers only to the sample
width of the output fragment here.</p>
</dd></dl>

<p>Note that operations such as <a class="reference internal" href="#audioop.mul" title="audioop.mul"><code class="xref py py-func docutils literal notranslate"><span class="pre">mul()</span></code></a> or <a class="reference internal" href="#audioop.max" title="audioop.max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> make no distinction
between mono and stereo fragments, i.e. all samples are treated equal.  If this
is a problem the stereo fragment should be split into two mono fragments first
and recombined later.  Here is an example of how to do that:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mul_stereo</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">lfactor</span><span class="p">,</span> <span class="n">rfactor</span><span class="p">):</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tomono</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tomono</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">lfactor</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">rfactor</span><span class="p">)</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tostereo</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tostereo</span><span class="p">(</span><span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">audioop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
</pre></div>
</div>
<p>If you use the ADPCM coder to build network packets and you want your protocol
to be stateless (i.e. to be able to tolerate packet loss) you should not only
transmit the data but also the state.  Note that you should send the <em>initial</em>
state (the one you passed to <a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><code class="xref py py-func docutils literal notranslate"><span class="pre">lin2adpcm()</span></code></a>) along to the decoder, not the
final state (as returned by the coder).  If you want to use
<a class="reference internal" href="struct.html#struct.Struct" title="struct.Struct"><code class="xref py py-class docutils literal notranslate"><span class="pre">struct.Struct</span></code></a> to store the state in binary you can code the first
element (the predicted value) in 16 bits and the second (the delta index) in 8.</p>
<p>The ADPCM coders have never been tried against other ADPCM coders, only against
themselves.  It could well be that I misinterpreted the standards in which case
they will not be interoperable with the respective standards.</p>
<p>The <code class="xref py py-func docutils literal notranslate"><span class="pre">find*()</span></code> routines might look a bit funny at first sight. They are
primarily meant to do echo cancellation.  A reasonably fast way to do this is to
pick the most energetic piece of the output sample, locate that in the input
sample and subtract the whole output sample from the input sample:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">echocancel</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="n">inputdata</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">findmax</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="mi">800</span><span class="p">)</span>    <span class="c1"># one tenth second</span>
    <span class="n">out_test</span> <span class="o">=</span> <span class="n">outputdata</span><span class="p">[</span><span class="n">pos</span><span class="o">*</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">in_test</span> <span class="o">=</span> <span class="n">inputdata</span><span class="p">[</span><span class="n">pos</span><span class="o">*</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">ipos</span><span class="p">,</span> <span class="n">factor</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">findfit</span><span class="p">(</span><span class="n">in_test</span><span class="p">,</span> <span class="n">out_test</span><span class="p">)</span>
    <span class="c1"># Optional (for better cancellation):</span>
    <span class="c1"># factor = audioop.findfactor(in_test[ipos*2:ipos*2+len(out_test)],</span>
    <span class="c1">#              out_test)</span>
    <span class="n">prefill</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="n">ipos</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">postfill</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputdata</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">prefill</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">outputdata</span><span class="p">))</span>
    <span class="n">outputdata</span> <span class="o">=</span> <span class="n">prefill</span> <span class="o">+</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">factor</span><span class="p">)</span> <span class="o">+</span> <span class="n">postfill</span>
    <span class="k">return</span> <span class="n">audioop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">inputdata</span><span class="p">,</span> <span class="n">outputdata</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="aifc.html"
                          title="Chapitre précédent"><code class="xref py py-mod docutils literal notranslate"><span class="pre">aifc</span></code> — Lis et écrit dans les fichiers AIFF et AIFC</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="cgi.html"
                          title="Chapitre suivant"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code> --- Common Gateway Interface support</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/audioop.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="cgi.html" title="cgi --- Common Gateway Interface support"
             >suivant</a> |</li>
        <li class="right" >
          <a href="aifc.html" title="aifc — Lis et écrit dans les fichiers AIFF et AIFC"
             >précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La bibliothèque standard</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="superseded.html" >Modules remplacés</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code> — Manipulation de données audio brutes</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Mis à jour le oct. 26, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Créé en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>