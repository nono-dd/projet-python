
<!DOCTYPE html>

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="Boucle d'évènements" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/asyncio-eventloop.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Code source : Lib/asyncio/events.py, Lib/asyncio/base_events.py Préface La boucle d'événements est au cœur de chaque application asyncio. Les boucles d'événements exécutent des tâches et des rappel..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Code source : Lib/asyncio/events.py, Lib/asyncio/base_events.py Préface La boucle d'événements est au cœur de chaque application asyncio. Les boucles d'événements exécutent des tâches et des rappel..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Boucle d&#39;évènements &#8212; Documentation Python 3.12.0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=b37c26da2f7529d09fe70b41c4b2133fe4931a90" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Recherchez dans Documentation Python 3.12.0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="À propos de ces documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Futures" href="asyncio-future.html" />
    <link rel="prev" title="Exceptions" href="asyncio-exceptions.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/asyncio-eventloop.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" />
                <input type="submit" value="Go"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#">Boucle d'évènements</a><ul>
<li><a class="reference internal" href="#event-loop-methods">Méthodes de la boucle d'évènements</a><ul>
<li><a class="reference internal" href="#running-and-stopping-the-loop">Démarrer et arrêter une boucle d'évènements</a></li>
<li><a class="reference internal" href="#scheduling-callbacks">Planification des fonctions de rappel</a></li>
<li><a class="reference internal" href="#scheduling-delayed-callbacks">Planification des rappels différés</a></li>
<li><a class="reference internal" href="#creating-futures-and-tasks">Création de <em>Futures</em> et des tâches</a></li>
<li><a class="reference internal" href="#opening-network-connections">Création de connexions</a></li>
<li><a class="reference internal" href="#creating-network-servers">Création de serveurs</a></li>
<li><a class="reference internal" href="#transferring-files">Transfert de fichiers</a></li>
<li><a class="reference internal" href="#tls-upgrade">Passage du flux en TLS</a></li>
<li><a class="reference internal" href="#watching-file-descriptors">Surveillance de descripteur de fichier</a></li>
<li><a class="reference internal" href="#working-with-socket-objects-directly">Travail direct avec des objets <em>socket</em></a></li>
<li><a class="reference internal" href="#dns">DNS</a></li>
<li><a class="reference internal" href="#working-with-pipes">Travail avec des tubes (<em>pipes</em>)</a></li>
<li><a class="reference internal" href="#unix-signals">Signaux Unix</a></li>
<li><a class="reference internal" href="#executing-code-in-thread-or-process-pools">Exécution de code dans des pools de threads ou de processus</a></li>
<li><a class="reference internal" href="#error-handling-api">API de gestion d'erreur</a></li>
<li><a class="reference internal" href="#enabling-debug-mode">Activation du mode débogage</a></li>
<li><a class="reference internal" href="#running-subprocesses">Exécution de sous-processus</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callback-handles">Fonctions de rappel sur des descripteurs</a></li>
<li><a class="reference internal" href="#server-objects">Objets Serveur</a></li>
<li><a class="reference internal" href="#event-loop-implementations">Implémentations de boucle d'évènements</a></li>
<li><a class="reference internal" href="#examples">Exemples</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">&quot;Hello World&quot; avec <code class="docutils literal notranslate"><span class="pre">call_soon()</span></code></a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">Affichage de la date actuelle avec <code class="docutils literal notranslate"><span class="pre">call_later()</span></code></a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">Surveillance des événements de lecture pour un descripteur de fichier</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">Gestion des signaux <em>SIGINT</em> et <em>SIGTERM</em></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="asyncio-exceptions.html"
                          title="Chapitre précédent">Exceptions</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="asyncio-future.html"
                          title="Chapitre suivant">Futures</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/asyncio-eventloop.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="Futures"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="asyncio-exceptions.html" title="Exceptions"
             accesskey="P">précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La bibliothèque standard</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Réseau et communication entre processus</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — Entrées/Sorties asynchrones</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Boucle d'évènements</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="event-loop">
<span id="asyncio-event-loop"></span><h1>Boucle d'évènements<a class="headerlink" href="#event-loop" title="Lien permanent vers ce titre">¶</a></h1>
<p><strong>Code source :</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/asyncio/events.py">Lib/asyncio/events.py</a>, <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a></p>
<hr class="docutils" />
<p class="rubric">Préface</p>
<p>La boucle d'événements est au cœur de chaque application <em>asyncio</em>. Les boucles d'événements exécutent des tâches et des rappels asynchrones, effectuent des opérations d'entrée-sorite réseau et exécutent des sous-processus.</p>
<p>Les développeurs d'applications doivent généralement utiliser les fonctions <em>asyncio</em> de haut niveau, telles que <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>, et ne doivent que rarement référencer l'objet boucle ou appeler ses méthodes. Cette section est principalement destinée aux auteurs de code, de bibliothèques et de cadriciels de bas niveau, qui ont besoin d'un contrôle plus précis sur le comportement de la boucle d'événements.</p>
<p class="rubric">Obtention d'une boucle d'évènements</p>
<p>Les fonctions de bas niveau suivantes peuvent être utilisées pour obtenir, définir ou créer une boucle d'événements :</p>
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.get_running_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">get_running_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_running_loop" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie la boucle d'événements en cours d'exécution dans le fil actuel du système d'exploitation.</p>
<p>Lève une <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> s'il n'y a pas de boucle d'événements en cours d'exécution.</p>
<p>Cette fonction ne peut être appelée qu'à partir d'une coroutine ou d'une fonction de rappel.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.get_event_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">get_event_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_event_loop" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Arrête l'exécution de la boucle d'évènements.</p>
<p>Lorsqu'elle est appelée depuis une coroutine ou une fonction de rappel (par exemple planifiée avec <em>call_soon</em> ou une API similaire), cette fonction renvoie toujours la boucle d'événement en cours.</p>
<p>S'il n'y a pas de boucle d'événement en cours d'exécution, la fonction renvoie le résultat de l'appel <code class="docutils literal notranslate"><span class="pre">get_event_loop_policy().get_event_loop()</span></code>.</p>
<p>Étant donné que cette fonction a un comportement plutôt complexe (en particulier lorsque des politiques de boucle d'événements personnalisées sont utilisées), l'utilisation de la fonction <a class="reference internal" href="#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a> est préférable à <a class="reference internal" href="#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a> dans les coroutines et les fonctions de rappel.</p>
<p>Comme indiqué ci-dessus, envisagez d'utiliser la fonction de haut niveau <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>, au lieu d'utiliser ces fonctions de bas niveau pour créer et fermer manuellement une boucle d'événements.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsolète depuis la version 3.12: </span>Deprecation warning is emitted if there is no current event loop.
In some future Python release this will become an error.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.set_event_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">set_event_loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loop</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.set_event_loop" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Définit <em>loop</em> comme boucle d'événements actuelle pour le fil d'exécution actuel du système d'exploitation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.new_event_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">new_event_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.new_event_loop" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Crée et renvoie un nouvel objet de boucle d'événements.</p>
</dd></dl>

<p>Notez que le comportement des fonctions <a class="reference internal" href="#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a>, <a class="reference internal" href="#asyncio.set_event_loop" title="asyncio.set_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_event_loop()</span></code></a> et <a class="reference internal" href="#asyncio.new_event_loop" title="asyncio.new_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">new_event_loop()</span></code></a> peut être modifié en <a class="reference internal" href="asyncio-policy.html#asyncio-policies"><span class="std std-ref">définissant une politique de boucle d'événement personnalisée</span></a>.</p>
<p class="rubric">Sommaire</p>
<p>Cette page de documentation contient les sections suivantes :</p>
<ul class="simple">
<li><p>la section <a class="reference internal" href="#event-loop-methods">Event Loop Methods</a> est la documentation de référence des API de boucle d'événements ;</p></li>
<li><p>la section <a class="reference internal" href="#callback-handles">Callback Handles</a> documente les instances <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a> et <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimerHandle</span></code></a> qui sont renvoyées par les méthodes de planification telles que <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> et <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a> ;</p></li>
<li><p>la section <a class="reference internal" href="#server-objects">Server Objects</a> documente les types renvoyés par les méthodes de boucle d'événements comme <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> ;</p></li>
<li><p>la section <a class="reference internal" href="#event-loop-implementations">Event Loop Implementations</a> documente les classes <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> et <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> ;</p></li>
<li><p>la section <a class="reference internal" href="#examples">Exemples</a> montre comment travailler avec certaines API de boucle d'événements.</p></li>
</ul>
<section id="event-loop-methods">
<span id="asyncio-event-loop-methods"></span><h2>Méthodes de la boucle d'évènements<a class="headerlink" href="#event-loop-methods" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les boucles d'événements ont des API <strong>de bas niveau</strong> pour les éléments suivants :</p>
<div class="contents local topic" id="sommaire">
<ul class="simple">
<li><p><a class="reference internal" href="#running-and-stopping-the-loop" id="id1">Démarrer et arrêter une boucle d'évènements</a></p></li>
<li><p><a class="reference internal" href="#scheduling-callbacks" id="id2">Planification des fonctions de rappel</a></p></li>
<li><p><a class="reference internal" href="#scheduling-delayed-callbacks" id="id3">Planification des rappels différés</a></p></li>
<li><p><a class="reference internal" href="#creating-futures-and-tasks" id="id4">Création de <em>Futures</em> et des tâches</a></p></li>
<li><p><a class="reference internal" href="#opening-network-connections" id="id5">Création de connexions</a></p></li>
<li><p><a class="reference internal" href="#creating-network-servers" id="id6">Création de serveurs</a></p></li>
<li><p><a class="reference internal" href="#transferring-files" id="id7">Transfert de fichiers</a></p></li>
<li><p><a class="reference internal" href="#tls-upgrade" id="id8">Passage du flux en TLS</a></p></li>
<li><p><a class="reference internal" href="#watching-file-descriptors" id="id9">Surveillance de descripteur de fichier</a></p></li>
<li><p><a class="reference internal" href="#working-with-socket-objects-directly" id="id10">Travail direct avec des objets <em>socket</em></a></p></li>
<li><p><a class="reference internal" href="#dns" id="id11">DNS</a></p></li>
<li><p><a class="reference internal" href="#working-with-pipes" id="id12">Travail avec des tubes (<em>pipes</em>)</a></p></li>
<li><p><a class="reference internal" href="#unix-signals" id="id13">Signaux Unix</a></p></li>
<li><p><a class="reference internal" href="#executing-code-in-thread-or-process-pools" id="id14">Exécution de code dans des pools de threads ou de processus</a></p></li>
<li><p><a class="reference internal" href="#error-handling-api" id="id15">API de gestion d'erreur</a></p></li>
<li><p><a class="reference internal" href="#enabling-debug-mode" id="id16">Activation du mode débogage</a></p></li>
<li><p><a class="reference internal" href="#running-subprocesses" id="id17">Exécution de sous-processus</a></p></li>
</ul>
</div>
<section id="running-and-stopping-the-loop">
<h3><a class="toc-backref" href="#id1">Démarrer et arrêter une boucle d'évènements</a><a class="headerlink" href="#running-and-stopping-the-loop" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.run_until_complete">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">run_until_complete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">future</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_until_complete" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Lance la boucle jusqu'à ce que <em>future</em> (une instance de <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>) soit terminée.</p>
<p>Si l'argument est un objet <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">coroutine</span></a>, il est implicitement programmé pour s'exécuter en tant que <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>.</p>
<p>Renvoie le résultat du <em>Future</em> ou lève son exception.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.run_forever">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">run_forever</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_forever" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Exécute la boucle d'événement jusqu'à ce que <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> soit appelée.</p>
<p>Si <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> est appelée avant que <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> ne soit appelée, la boucle interroge le sélecteur d'entrée-sortie une fois avec un délai d'attente de zéro, exécute tous les rappels programmés en réponse aux événements d'entrée-sortie (et ceux qui étaient déjà programmés), puis quitte.</p>
<p>Si <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> est appelée pendant que <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> est en cours d'exécution, la boucle exécute le lot actuel de rappels puis se termine. Notez que les nouveaux rappels programmés par fonctions de rappel ne s'exécuteront pas dans ce cas ; à la place, ils s'exécuteront la prochaine fois que <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> ou <a class="reference internal" href="#asyncio.loop.run_until_complete" title="asyncio.loop.run_until_complete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_until_complete()</span></code></a> sera appelée.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.stop">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.stop" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Arrête l'exécution de la boucle d'évènements.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.is_running">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">is_running</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.is_running" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie <code class="docutils literal notranslate"><span class="pre">True</span></code> si la boucle d'évènements est démarrée.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.is_closed">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">is_closed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.is_closed" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie <code class="docutils literal notranslate"><span class="pre">True</span></code> si la boucle d'évènements est arrêtée.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.close">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.close" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Arrête la boucle d'évènements.</p>
<p>La boucle ne doit pas être en cours d'exécution lorsque cette fonction est appelée. Tous les rappels en attente seront ignorés.</p>
<p>Cette méthode efface toutes les files d'attente et arrête l'exécuteur, mais n'attend pas que l'exécuteur se termine.</p>
<p>Cette méthode est idempotente et irréversible. Aucune autre méthode ne doit être appelée après la fermeture de la boucle d'événements.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.shutdown_asyncgens">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">shutdown_asyncgens</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.shutdown_asyncgens" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Planifie la fermeture de tous les objets <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">générateurs asynchrones</span></a> actuellement ouverts avec un appel <a class="reference internal" href="../reference/expressions.html#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a>. Après avoir appelé cette méthode, la boucle d'événements émet un avertissement si un nouveau générateur asynchrone est itéré. Elle doit être utilisée pour finaliser de manière fiable tous les générateurs asynchrones planifiés.</p>
<p>Notez qu'il n'est pas nécessaire d'appeler cette fonction lorsque <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> est utilisée.</p>
<p>Exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">shutdown_asyncgens</span><span class="p">())</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.shutdown_default_executor">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">shutdown_default_executor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.shutdown_default_executor" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Planifie la fermeture de l'exécuteur par défaut et attend que tous les fils se rejoignent dans le <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>. Une fois cette méthode appelée, l'utilisation de l'exécuteur par défaut avec <a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a> lève une <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>.</p>
<p>The <em>timeout</em> parameter specifies the amount of time
(in <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> seconds) the executor will be given to finish joining.
With the default, <code class="docutils literal notranslate"><span class="pre">None</span></code>,
the executor is allowed an unlimited amount of time.</p>
<p>If the <em>timeout</em> is reached, a <a class="reference internal" href="exceptions.html#RuntimeWarning" title="RuntimeWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeWarning</span></code></a> is emitted
and the default executor is terminated
without waiting for its threads to finish joining.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>n'appelez pas cette méthode lorsque vous utilisez <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>, car cette dernière gère automatiquement l'arrêt de l'exécuteur par défaut.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.9.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.12: </span>Added the <em>timeout</em> parameter.</p>
</div>
</dd></dl>

</section>
<section id="scheduling-callbacks">
<h3><a class="toc-backref" href="#id2">Planification des fonctions de rappel</a><a class="headerlink" href="#scheduling-callbacks" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_soon">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_soon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_soon" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Définit la <a class="reference internal" href="../glossary.html#term-callback"><span class="xref std std-term">fonction de rappel</span></a> <em>callback</em> à appeler avec les arguments <em>args</em> à la prochaine itération de la boucle d'événements.</p>
<p>Renvoie une instance de <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a>, qui pourra être utilisée ultérieurement pour annuler le rappel.</p>
<p>Les fonctions de rappels sont appelées dans l'ordre dans lequel elles sont enregistrées. Chaque fonction de rappel sera appelée exactement une fois.</p>
<p>L'argument facultatif nommé uniquement <em>context</em> spécifie un <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> personnalisé pour le <em>callback</em> à exécuter. Les rappels utilisent le contexte actuel lorsqu'aucun <em>context</em> n'est fourni.</p>
<p>Contrairement à <a class="reference internal" href="#asyncio.loop.call_soon_threadsafe" title="asyncio.loop.call_soon_threadsafe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon_threadsafe()</span></code></a>, cette méthode n'est pas compatible avec les programmes à fils d'exécution multiples.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_soon_threadsafe">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_soon_threadsafe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_soon_threadsafe" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Une variante compatible avec les programmes à fils d'exécution multiples de <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon()</span></code></a>. Lors de la planification de rappels à partir d'un autre fil d'exécution, cette fonction <em>doit</em> être utilisée, puisque <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon()</span></code></a> n'est pas thread-safe.</p>
<p>Lève <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> si elle est appelée sur une boucle qui a été fermée. Cela peut se produire sur un fil secondaire lorsque l'application principale se ferme.</p>
<p>Voir la section <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">exécution concurrente et multi-fils d'exécution</span></a> de la documentation.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>le paramètre nommé uniquement <em>context</em> a été ajouté. Voir <span class="target" id="index-12"></span><a class="pep reference external" href="https://peps.python.org/pep-0567/"><strong>PEP 567</strong></a> pour plus de détails.</p>
</div>
</dd></dl>

<div class="admonition note" id="asyncio-pass-keywords">
<p class="admonition-title">Note</p>
<p>la plupart des fonctions d'ordonnancement <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> n'autorisent pas le passage d'arguments nommés. Pour le faire, utilisez <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># will schedule &quot;print(&quot;Hello&quot;, flush=True)&quot;</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span>
    <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<p>L'utilisation d'objets partiels est généralement plus pratique que l'utilisation de lambdas, car <em>asyncio</em> peut mieux rendre les objets partiels dans les messages de débogage et d'erreur.</p>
</div>
</section>
<section id="scheduling-delayed-callbacks">
<span id="asyncio-delayed-calls"></span><h3><a class="toc-backref" href="#id3">Planification des rappels différés</a><a class="headerlink" href="#scheduling-delayed-callbacks" title="Lien permanent vers ce titre">¶</a></h3>
<p>La boucle d'événements fournit des mécanismes pour programmer les fonctions de rappel à appeler à un moment donné dans le futur. La boucle d'événements utilise des horloges monotones pour suivre le temps.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_later">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_later</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delay</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_later" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Planifie le rappel <em>callback</em> à appeler après <em>delay</em> secondes (peut être un entier ou un flottant).</p>
<p>Une instance de <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> est renvoyée et peut être utilisée pour annuler le rappel.</p>
<p><em>callback</em> sera appelé exactement une fois. Si deux rappels sont programmés exactement à la même heure, l'ordre dans lequel ils sont appelés n'est pas défini.</p>
<p>L'argument positionnel facultatif <em>args</em> sera transmis au rappel lorsqu'il sera appelé. Si vous voulez que le rappel soit appelé avec des arguments nommés, utilisez <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>.</p>
<p>Un argument facultatif <em>context</em> nommé uniquement permet de spécifier un <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> personnalisé pour le <em>callback</em> à exécuter. Le contexte actuel est utilisé lorsqu'aucun <em>context</em> n'est fourni.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>le paramètre nommé uniquement <em>context</em> a été ajouté. Voir <span class="target" id="index-13"></span><a class="pep reference external" href="https://peps.python.org/pep-0567/"><strong>PEP 567</strong></a> pour plus de détails.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.8: </span>dans Python 3.7 et versions antérieures avec l'implémentation de la boucle d'événements par défaut, le <em>delay</em> ne pouvait pas dépasser un jour. Cela a été corrigé dans Python 3.8.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_at">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">when</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_at" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Planifie l'appel de <em>callback</em> à l'horodatage absolu donné <em>when</em> (un <em>int</em> ou un <em>float</em>), en utilisant la même référence de temps que <a class="reference internal" href="#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a>.</p>
<p>Le comportement de cette méthode est le même que <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_later()</span></code></a>.</p>
<p>Une instance de <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> est renvoyée et peut être utilisée pour annuler le rappel.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>le paramètre nommé uniquement <em>context</em> a été ajouté. Voir <span class="target" id="index-14"></span><a class="pep reference external" href="https://peps.python.org/pep-0567/"><strong>PEP 567</strong></a> pour plus de détails.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.8: </span>dans Python 3.7 et versions antérieures avec l'implémentation de la boucle d'événements par défaut, la différence entre <em>when</em> et l'heure actuelle ne pouvait pas dépasser un jour. Cela a été corrigé dans Python 3.8.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.time">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">time</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.time" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie l'heure actuelle, sous la forme d'une valeur <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, selon l'horloge monotone interne de la boucle d'événements.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.8: </span>dans Python 3.7 et les versions antérieures, les délais d'expiration (relatif <em>delay</em> ou absolu <em>when</em>) ne doivent pas dépasser un jour. Cela a été corrigé dans Python 3.8.</p>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p>la fonction <a class="reference internal" href="asyncio-task.html#asyncio.sleep" title="asyncio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.sleep()</span></code></a>.</p>
</div>
</section>
<section id="creating-futures-and-tasks">
<h3><a class="toc-backref" href="#id4">Création de <em>Futures</em> et des tâches</a><a class="headerlink" href="#creating-futures-and-tasks" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_future">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_future</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_future" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Crée un objet <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> attaché à la boucle d'événements.</p>
<p>C'est la méthode préférée pour créer des <em>Futures</em> avec <em>asyncio</em>. Cela permet aux boucles d'événements tierces de fournir des implémentations alternatives de l'objet <em>Future</em> (avec de meilleures performances ou instrumentation).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.5.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_task">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coro</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_task" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Planifie l'exécution de <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">coroutine</span></a> <em>coro</em>. Renvoie un objet <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>.</p>
<p>Les boucles d'événements tierces peuvent utiliser leur propre sous-classe de <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> pour l'interopérabilité. Dans ce cas, le type de résultat est une sous-classe de <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>.</p>
<p>Si l'argument <em>name</em> est fourni et non <code class="docutils literal notranslate"><span class="pre">None</span></code>, il est défini comme le nom de la tâche en utilisant <a class="reference internal" href="asyncio-task.html#asyncio.Task.set_name" title="asyncio.Task.set_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.set_name()</span></code></a>.</p>
<p>Argument facultatif <em>context</em> nommé uniquement qui permet de spécifier un <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> personnalisé pour la <em>coro</em> à exécuter. La copie de contexte actuel est créée lorsqu'aucun <em>context</em> n'est fourni.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.8: </span>ajout du paramètre <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>ajout du paramètre <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_task_factory">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_task_factory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factory</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_task_factory" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Définit une fabrique de tâches qui sera utilisée par <a class="reference internal" href="#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_task()</span></code></a>.</p>
<p>Si <em>factory</em> est <code class="docutils literal notranslate"><span class="pre">None</span></code>, la fabrique de tâches par défaut sera définie. Sinon, <em>factory</em> doit être un <em>appelable</em> avec la signature correspondant à <code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">coro,</span> <span class="pre">context=None)</span></code>, où <em>loop</em> est une référence à la boucle d'événements active et <em>coro</em> est un objet coroutine . L'appelable doit renvoyer un objet compatible avec <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.get_task_factory">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">get_task_factory</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_task_factory" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie une fabrique de tâches ou <code class="docutils literal notranslate"><span class="pre">None</span></code> si celle par défaut est utilisée.</p>
</dd></dl>

</section>
<section id="opening-network-connections">
<h3><a class="toc-backref" href="#id5">Création de connexions</a><a class="headerlink" href="#opening-network-connections" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_connection">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_connection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">happy_eyeballs_delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interleave</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_connection" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ouvre un flux de transport connecté à l'adresse spécifiée par <em>host</em> et <em>port</em>.</p>
<p>The socket family can be either <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a> or
<a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> depending on <em>host</em> (or the <em>family</em>
argument, if provided).</p>
<p>The socket type will be <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>.</p>
<p><em>protocol_factory</em> doit être un appelable renvoyant un protocole gérant le <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocole asyncio</span></a>.</p>
<p>Cette méthode tente d'établir la connexion en arrière-plan. En cas de succès, elle renvoie une paire <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>.</p>
<p>Le synopsis chronologique de l'opération sous-jacente est le suivant :</p>
<ol class="arabic simple">
<li><p>La connexion est établie et un <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">transport asyncio</span></a> est créé pour cela.</p></li>
<li><p><em>protocol_factory</em> est appelée sans arguments et doit renvoyer une instance de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocol asyncio</span></a>.</p></li>
<li><p>L'instance de protocole est couplée au transport en appelant sa méthode <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseProtocol.connection_made" title="asyncio.BaseProtocol.connection_made"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connection_made()</span></code></a>.</p></li>
<li><p>Un <em>n</em>-uplet <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> est renvoyé en cas de succès.</p></li>
</ol>
<p>Le transport créé est un flux bidirectionnel dépendant de l'implémentation.</p>
<p>Autres arguments :</p>
<ul>
<li><p><em>ssl</em> : s'il est donné et non faux, un transport SSL/TLS est créé (par défaut un transport TCP simple est créé). Si <em>ssl</em> est un objet <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a>, ce contexte est utilisé pour créer le transport ; si <em>ssl</em> est <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>, un contexte par défaut renvoyé par <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> est utilisé.</p>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p><a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">Considérations sur la sécurité SSL/TLS</span></a></p>
</div>
</li>
<li><p><em>server_hostname</em> définit ou remplace le nom d'hôte auquel le certificat du serveur cible sera comparé. Ne doit être passé que si <em>ssl</em> n'est pas <code class="docutils literal notranslate"><span class="pre">None</span></code>. Par défaut, la valeur de l'argument <em>host</em> est utilisée. Si <em>host</em> est vide, il n'y a pas de valeur par défaut et vous devez transmettre une valeur pour <em>server_hostname</em>. Si <em>server_hostname</em> est une chaîne vide, la correspondance du nom d'hôte est désactivée (ce qui constitue un risque de sécurité sérieux, permettant des attaques potentielles de type « homme du milieu »).</p></li>
<li><p><em>family</em>, <em>proto</em>, <em>flags</em> sont facultatifs et sont la famille d'adresse, le protocole et les drapeaux à transmettre à <em>getaddrinfo()</em> pour la résolution de <em>host</em>. S'ils sont fournis, ils doivent tous être des entiers provenant des constantes du module <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>.</p></li>
<li><p><em>happy_eyeballs_delay</em>, s'il est fourni, active Happy Eyeballs pour cette connexion. Il doit s'agir d'un nombre à virgule flottante représentant le temps d'attente en secondes pour qu'une tentative de connexion se termine, avant de démarrer la prochaine tentative en parallèle. Il s'agit du « délai de tentative de connexion » tel que défini dans la <span class="target" id="index-15"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8305.html"><strong>RFC 8305</strong></a>. Une valeur par défaut raisonnable recommandée par la RFC est <code class="docutils literal notranslate"><span class="pre">0.25</span></code> (250 millisecondes).</p></li>
<li><p><em>interleave</em> contrôle la réorganisation des adresses lorsqu'un nom d'hôte se résout en plusieurs adresses IP. S'il vaut <code class="docutils literal notranslate"><span class="pre">0</span></code> ou n'est pas spécifié, aucune réorganisation n'est effectuée et les adresses sont essayées dans l'ordre renvoyé par <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>. Si un entier positif est spécifié, les adresses sont entrelacées par famille d'adresses et l'entier donné est interprété comme &quot;First Address Family Count&quot; tel que défini dans la <span class="target" id="index-16"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8305.html"><strong>RFC 8305</strong></a>. La valeur par défaut est <code class="docutils literal notranslate"><span class="pre">0</span></code> si <em>happy_eyeballs_delay</em> n'est pas spécifié, et <code class="docutils literal notranslate"><span class="pre">1</span></code> si c'est le cas.</p></li>
<li><p><em>sock</em>, s'il est fourni, doit être un objet <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> existant et déjà connecté à utiliser par le transport. Si <em>sock</em> est donné, aucun des <em>host</em>, <em>port</em>, <em>family</em>, <em>proto</em>, <em>flags</em>, <em>happy_eyeballs_delay</em>, <em>interleave</em> et <em>local_addr</em> ne doit être spécifié.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>l'argument <em>sock</em> transfère la propriété du connecteur au transport créé. Pour fermer le connecteur, appelez la méthode <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> du transport.</p>
</div>
</li>
<li><p><em>local_addr</em>, s'il est fourni, est un <em>n</em>-uplet <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> utilisé pour lier le connecteur localement. <em>local_host</em> et <em>local_port</em> sont recherchés en utilisant <code class="docutils literal notranslate"><span class="pre">getaddrinfo()</span></code>, de la même manière que <em>host</em> et <em>port</em>.</p></li>
<li><p><em>ssl_handshake_timeout</em> est (pour une connexion TLS) le temps en secondes à attendre que la poignée de main TLS se termine avant d'abandonner la connexion. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> secondes si <code class="docutils literal notranslate"><span class="pre">None</span></code> (par défaut).</p></li>
<li><p><em>ssl_shutdown_timeout</em> est le temps en secondes à attendre que l'arrêt SSL se termine avant d'abandonner la connexion. <code class="docutils literal notranslate"><span class="pre">30.0</span></code> secondes si <code class="docutils literal notranslate"><span class="pre">None</span></code> (par défaut).</p></li>
<li><p><em>all_errors</em> determines what exceptions are raised when a connection cannot
be created. By default, only a single <code class="docutils literal notranslate"><span class="pre">Exception</span></code> is raised: the first
exception if there is only one or all errors have same message, or a single
<code class="docutils literal notranslate"><span class="pre">OSError</span></code> with the error messages combined. When <code class="docutils literal notranslate"><span class="pre">all_errors</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>,
an <code class="docutils literal notranslate"><span class="pre">ExceptionGroup</span></code> will be raised containing all exceptions (even if there
is only one).</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>ajout de la prise en charge de SSL/TLS dans <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.6: </span>The socket option <code class="xref py py-const docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code> is set by default
for all TCP connections.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>ajout du paramètre <em>ssl handshake timeout</em></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.8: </span>ajout des paramètres <em>happy_eyeballs_delay</em> et <em>interleave</em>.</p>
<p>Algorithme Happy Eyeballs : « succès avec les hôtes à double pile ». Lorsque le chemin et le protocole IPv4 d'un serveur fonctionnent, mais que le chemin et le protocole IPv6 du serveur ne fonctionnent pas, une application cliente à double pile subit un retard de connexion important par rapport à un client IPv4 uniquement. Ceci n'est pas souhaitable car cela entraîne une moins bonne expérience utilisateur pour le client à double pile. Ce document spécifie les exigences pour les algorithmes qui réduisent ce délai visible par l'utilisateur et fournit un algorithme correspondant.</p>
<p>For more information: <a class="reference external" href="https://datatracker.ietf.org/doc/html/rfc6555">https://datatracker.ietf.org/doc/html/rfc6555</a></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>ajout du paramètre <em>ssl shutdown timeout</em></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.12: </span><em>all_errors</em> was added.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p>la fonction <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_connection()</span></code></a> est une API alternative de haut niveau. Elle renvoie une paire de (<a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>) qui peut être utilisée directement dans le code <em>async/wait</em>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_datagram_endpoint">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_datagram_endpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remote_addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_broadcast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_datagram_endpoint" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Création d'une connexion par datagramme</p>
<p>The socket family can be either <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a>,
<a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>, or <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>,
depending on <em>host</em> (or the <em>family</em> argument, if provided).</p>
<p>The socket type will be <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></a>.</p>
<p><em>protocol_factory</em> doit être un appelable gérant le <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocole asyncio</span></a>.</p>
<p>Un <em>n</em>-uplet <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> est renvoyé en cas de succès.</p>
<p>Autres arguments :</p>
<ul>
<li><p><em>local_addr</em>, s'il est fourni, est un <em>n</em>-uplet <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> utilisé pour lier le connecteur localement. Le <em>local_host</em> et le <em>local_port</em> sont recherchés en utilisant <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p></li>
<li><p><em>remote_addr</em>, s'il est fourni, est un <em>n</em>-uplet <code class="docutils literal notranslate"><span class="pre">(remote_host,</span> <span class="pre">remote_port)</span></code> utilisé pour se connecter à une adresse distante. Le <em>remote_host</em> et le <em>remote_port</em> sont recherchés en utilisant <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p></li>
<li><p><em>family</em>, <em>proto</em>, <em>flags</em> sont facultatifs et représentent la famille d'adresse, le protocole et les drapeaux à transmettre à <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> pour la résolution <em>host</em>. S'ils sont fournis, ils doivent tous être des entiers provenant des constantes du module <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>.</p></li>
<li><p><em>reuse_port</em> tells the kernel to allow this endpoint to be bound to the
same port as other existing endpoints are bound to, so long as they all
set this flag when being created. This option is not supported on Windows
and some Unixes. If the <code class="xref py py-const docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code> constant is not
defined then this capability is unsupported.</p></li>
<li><p><em>allow_broadcast</em> indique au noyau d'autoriser ce point de terminaison à envoyer des messages à l'adresse de <em>broadcast</em>.</p></li>
<li><p><em>sock</em> peut éventuellement être spécifié afin d'utiliser un objet <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> préexistant, déjà connecté, à utiliser par le transport. Si spécifié, <em>local_addr</em> et <em>remote_addr</em> doivent être omis (doit être <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>l'argument <em>sock</em> transfère la propriété du connecteur au transport créé. Pour fermer le connecteur, appelez la méthode <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> du transport.</p>
</div>
</li>
</ul>
<p>Voir les exemples <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-client-protocol"><span class="std std-ref">Client écho en UDP</span></a> et <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-server-protocol"><span class="std std-ref">Serveur écho en UDP</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.4.4: </span>les paramètres <em>family</em>, <em>proto</em>, <em>flags</em>, <em>reuse_address</em>, <em>reuse_port</em>, <em>allow_broadcast</em> et <em>sock</em> ont été ajoutés.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.8.1: </span>The <em>reuse_address</em> parameter is no longer supported, as using
<code class="xref py py-const docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> poses a significant security concern for
UDP. Explicitly passing <code class="docutils literal notranslate"><span class="pre">reuse_address=True</span></code> will raise an exception.</p>
<p>Lorsque plusieurs processus avec des UID différents attribuent des connecteurs à une adresse de connecteur UDP identique avec <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code>, les paquets entrants peuvent être distribués de manière aléatoire entre les connecteurs.</p>
<p>For supported platforms, <em>reuse_port</em> can be used as a replacement for
similar functionality. With <em>reuse_port</em>,
<code class="xref py py-const docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code> is used instead, which specifically
prevents processes with differing UIDs from assigning sockets to the same
socket address.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.8: </span>prise en charge sur Windows.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>le paramètre <em>reuse_address</em>, désactivé depuis Python 3.9.0, 3.8.1, 3.7.6 et 3.6.10, a été entièrement supprimé.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_unix_connection">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_unix_connection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_unix_connection" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Crée une connexion Unix</p>
<p>The socket family will be <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>; socket
type will be <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>.</p>
<p>Un <em>n</em>-uplet <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> est renvoyé en cas de succès.</p>
<p><em>path</em> est le nom d'un connecteur de domaine Unix et est obligatoire, sauf si un paramètre <em>sock</em> est spécifié. Les connecteurs Unix abstraits, les chemins <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> et <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> sont pris en charge.</p>
<p>Voir la documentation de la méthode <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> pour plus d'informations sur les arguments de cette méthode.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilité</span></a> : Unix.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>ajout du paramètre <em>ssl_handshake_timeout</em>. Le paramètre <em>chemin</em> peut désormais être un <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">objet simili-chemin</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>ajout du paramètre <em>ssl shutdown timeout</em></p>
</div>
</dd></dl>

</section>
<section id="creating-network-servers">
<h3><a class="toc-backref" href="#id6">Création de serveurs</a><a class="headerlink" href="#creating-network-servers" title="Lien permanent vers ce titre">¶</a></h3>
<span class="target" id="loop-create-server"></span><dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_server">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_server</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">socket.AF_UNSPEC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">socket.AI_PASSIVE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_address</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_serving</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_server" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Create a TCP server (socket type <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>) listening
on <em>port</em> of the <em>host</em> address.</p>
<p>Renvoie un objet <a class="reference internal" href="#asyncio.Server" title="asyncio.Server"><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code></a>.</p>
<p>Arguments :</p>
<ul>
<li><p><em>protocol_factory</em> doit être un appelable gérant le <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocole asyncio</span></a>.</p></li>
<li><p>Le paramètre <em>host</em> peut être défini sur plusieurs types qui déterminent où le serveur écoute :</p>
<ul class="simple">
<li><p>Si <em>host</em> est une chaîne, le serveur TCP est lié à une seule interface réseau spécifiée par <em>host</em>.</p></li>
<li><p>Si <em>host</em> est une séquence de chaînes, le serveur TCP est lié à toutes les interfaces réseau spécifiées par la séquence.</p></li>
<li><p>Si <em>host</em> est une chaîne vide ou <code class="docutils literal notranslate"><span class="pre">None</span></code>, toutes les interfaces sont prises en compte et une liste de plusieurs connecteurs est renvoyée (probablement une pour IPv4 et une autre pour IPv6).</p></li>
</ul>
</li>
<li><p>Le paramètre <em>port</em> peut être défini pour spécifier sur quel port le serveur doit écouter. Si <code class="docutils literal notranslate"><span class="pre">0</span></code> ou <code class="docutils literal notranslate"><span class="pre">None</span></code> (la valeur par défaut), un port inutilisé aléatoire est sélectionné (notez que si <em>host</em> se résout en plusieurs interfaces réseau, un port aléatoire différent est sélectionné pour chaque interface).</p></li>
<li><p><em>family</em> can be set to either <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.AF_INET</span></code></a> or
<a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> to force the socket to use IPv4 or IPv6.
If not set, the <em>family</em> will be determined from host name
(defaults to <code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNSPEC</span></code>).</p></li>
<li><p><em>flags</em> est un masque de bits pour <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p></li>
<li><p><em>sock</em> peut éventuellement être spécifié afin d'utiliser un objet connecteur préexistant. S'il est spécifié, <em>host</em> et <em>port</em> ne doivent pas être spécifiés.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>l'argument <em>sock</em> transfère la propriété du connecteur au serveur créé. Pour fermer le connecteur, appelez la méthode <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> du serveur.</p>
</div>
</li>
<li><p><em>backlog</em> est le nombre maximum de connexions en file d'attente passées à <a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a> (par défaut à 100).</p></li>
<li><p><em>ssl</em> peut être défini sur une instance <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> pour activer TLS sur les connexions acceptées.</p></li>
<li><p><em>reuse_address</em> indique au noyau de réutiliser un connecteur local dans l'état <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code>, sans attendre l'expiration de son délai d'attente naturel. S'il n'est pas spécifié, il est automatiquement défini sur <code class="docutils literal notranslate"><span class="pre">True</span></code> sous Unix.</p></li>
<li><p><em>reuse_port</em> indique au noyau d'autoriser ce point de terminaison à être lié au même port que les autres points de terminaison existants, tant qu'ils définissent tous cet indicateur lors de leur création. Cette option n'est pas prise en charge sous Windows.</p></li>
<li><p><em>ssl_handshake_timeout</em> est (pour un serveur TLS) le temps en secondes à attendre que la poignée de main TLS se termine avant d'abandonner la connexion. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> secondes si <code class="docutils literal notranslate"><span class="pre">None</span></code> (par défaut).</p></li>
<li><p><em>ssl_shutdown_timeout</em> est le temps en secondes à attendre que l'arrêt SSL se termine avant d'abandonner la connexion. <code class="docutils literal notranslate"><span class="pre">30.0</span></code> secondes si <code class="docutils literal notranslate"><span class="pre">None</span></code> (par défaut).</p></li>
<li><p><em>start_serving</em> défini à <code class="docutils literal notranslate"><span class="pre">True</span></code> (valeur par défaut) fait que le serveur créé commence immédiatement à accepter les connexions. Lorsqu'il est défini sur <code class="docutils literal notranslate"><span class="pre">False</span></code>, l'utilisateur doit attendre sur <a class="reference internal" href="#asyncio.Server.start_serving" title="asyncio.Server.start_serving"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.start_serving()</span></code></a> ou <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a> pour que le serveur commence à accepter les connexions.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5: </span>ajout de la prise en charge de SSL/TLS dans <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5.1: </span>le paramètre <em>host</em> peut être une séquence de chaînes.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.6: </span>Added <em>ssl_handshake_timeout</em> and <em>start_serving</em> parameters.
The socket option <code class="xref py py-const docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code> is set by default
for all TCP connections.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>ajout du paramètre <em>ssl shutdown timeout</em></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p>la fonction <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a> est une API alternative de niveau supérieur qui renvoie une paire de <a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> et <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> qui peut être utilisée dans un code <em>async/wait</em>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_unix_server">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_unix_server</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_serving</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_unix_server" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> but works with the
<a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> socket family.</p>
<p><em>path</em> est le nom d'un connecteur de domaine Unix et est obligatoire, sauf si un argument <em>sock</em> est fourni. Les connecteurs Unix abstraits, les chemins <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> et <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> sont pris en charge.</p>
<p>Voir la documentation de la méthode <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> pour plus d'informations sur les arguments de cette méthode.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilité</span></a> : Unix.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>ajout des paramètres <em>ssl_handshake_timeout</em> et <em>start_serving</em>. Le paramètre <em>path</em> peut maintenant être un objet <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>ajout du paramètre <em>ssl shutdown timeout</em></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.connect_accepted_socket">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">connect_accepted_socket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_accepted_socket" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Enveloppe une connexion déjà acceptée dans une paire transport/protocole.</p>
<p>Cette méthode peut être utilisée par les serveurs qui acceptent les connexions en dehors d'<em>asyncio</em> mais qui utilisent <em>asyncio</em> pour les gérer.</p>
<p>Paramètres :</p>
<ul>
<li><p><em>protocol_factory</em> doit être un appelable gérant le <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocole asyncio</span></a>.</p></li>
<li><p><em>sock</em> est un objet connecteur préexistant renvoyé par <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>l'argument <em>sock</em> transfère la propriété du connecteur au transport créé. Pour fermer le connecteur, appelez la méthode <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> du transport.</p>
</div>
</li>
<li><p><em>ssl</em> peut être défini sur une <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> pour activer SSL sur les connexions acceptées.</p></li>
<li><p><em>ssl_handshake_timeout</em> est (pour une connexion SSL) le temps en secondes à attendre que la poignée de main SSL se termine avant d'abandonner la connexion. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> secondes si <code class="docutils literal notranslate"><span class="pre">None</span></code> (par défaut).</p></li>
<li><p><em>ssl_shutdown_timeout</em> est le temps en secondes à attendre que l'arrêt SSL se termine avant d'abandonner la connexion. <code class="docutils literal notranslate"><span class="pre">30.0</span></code> secondes si <code class="docutils literal notranslate"><span class="pre">None</span></code> (par défaut).</p></li>
</ul>
<p>Renvoie une paire <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocole)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.5.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>ajout du paramètre <em>ssl handshake timeout</em></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>ajout du paramètre <em>ssl shutdown timeout</em></p>
</div>
</dd></dl>

</section>
<section id="transferring-files">
<h3><a class="toc-backref" href="#id7">Transfert de fichiers</a><a class="headerlink" href="#transferring-files" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sendfile">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sendfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transport</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fallback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sendfile" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Envoie <em>file</em> via <em>transport</em>. Renvoie le nombre total d'octets envoyés.</p>
<p>La méthode utilise <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">os.sendfile()</span></code></a> (hautes performances) si elle est disponible.</p>
<p><em>file</em> doit être un objet fichier normal ouvert en mode binaire.</p>
<p><em>offset</em> indique où commencer la lecture du fichier. Si spécifié, <em>count</em> est le nombre total d'octets à transmettre, par opposition à l'envoi du fichier jusqu'à ce que EOF soit atteint. La position du fichier est toujours mise à jour, même lorsque cette méthode génère une erreur. <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> peut être utilisée pour obtenir le nombre d'octets réellement envoyés.</p>
<p><em>fallback</em> défini sur <code class="docutils literal notranslate"><span class="pre">True</span></code> permet à <em>asyncio</em> de lire et d'envoyer manuellement le fichier lorsque la plateforme ne prend pas en charge l'appel système <em>sendfile</em> (par exemple, Windows ou connecteur SSL sous Unix).</p>
<p>Lève <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a> si le système ne prend pas en charge l'appel système <em>sendfile</em> et que <em>fallback</em> est <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7.</span></p>
</div>
</dd></dl>

</section>
<section id="tls-upgrade">
<h3><a class="toc-backref" href="#id8">Passage du flux en TLS</a><a class="headerlink" href="#tls-upgrade" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.start_tls">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">start_tls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transport</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sslcontext</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.start_tls" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Convertit une connexion existante en connexion TLS.</p>
<p>Crée une instance de codeur-décodeur TLS et l'insère entre le <em>transport</em> et le <em>protocol</em>. Le codeur-décodeur implémente à la fois le protocole vers le <em>transport</em> et le transport vers le <em>protocol</em>.</p>
<p>Renvoie l'instance à deux interfaces créée. Après <em>await</em>, le <em>protocol</em> doit cesser d'utiliser le <em>transport</em> d'origine et communiquer avec l'objet renvoyé uniquement parce que le codeur met en cache les données côté <em>protocol</em> et échange sporadiquement des paquets de session TLS supplémentaires avec <em>transport</em>.</p>
<p>In some situations (e.g. when the passed transport is already closing) this
may return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Paramètres :</p>
<ul class="simple">
<li><p><em>transport</em> et <em>protocol</em> que des méthodes comme <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a> et <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_connection()</span></code></a> renvoient.</p></li>
<li><p><em>sslcontext</em> : une instance configurée de <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>.</p></li>
<li><p><em>server_side</em> passe à <code class="docutils literal notranslate"><span class="pre">True</span></code> lorsqu'une connexion côté serveur est mise à jour (comme celle créée par <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a>).</p></li>
<li><p><em>server_hostname</em> : définit ou remplace le nom d'hôte auquel le certificat du serveur cible est comparé.</p></li>
<li><p><em>ssl_handshake_timeout</em> est (pour une connexion TLS) le temps en secondes à attendre que la poignée de main TLS se termine avant d'abandonner la connexion. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> secondes si <code class="docutils literal notranslate"><span class="pre">None</span></code> (par défaut).</p></li>
<li><p><em>ssl_shutdown_timeout</em> est le temps en secondes à attendre que l'arrêt SSL se termine avant d'abandonner la connexion. <code class="docutils literal notranslate"><span class="pre">30.0</span></code> secondes si <code class="docutils literal notranslate"><span class="pre">None</span></code> (par défaut).</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>ajout du paramètre <em>ssl shutdown timeout</em></p>
</div>
</dd></dl>

</section>
<section id="watching-file-descriptors">
<h3><a class="toc-backref" href="#id9">Surveillance de descripteur de fichier</a><a class="headerlink" href="#watching-file-descriptors" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.add_reader">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">add_reader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_reader" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Commence à surveiller la disponibilité en lecture du descripteur de fichier <em>fd</em> et appelle <em>callback</em> avec les arguments spécifiés une fois que <em>fd</em> est disponible en lecture.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.remove_reader">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">remove_reader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_reader" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Arrête de surveiller le descripteur de fichier <em>fd</em> pour la disponibilité en lecture. Renvoie <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>fd</em> était précédemment surveillé pour les lectures.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.add_writer">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">add_writer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_writer" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Commence à surveiller le descripteur de fichier <em>fd</em> pour la disponibilité en écriture et appelle <em>callback</em> avec les arguments spécifiés une fois que <em>fd</em> est disponible en écriture.</p>
<p>Utilisez <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> pour <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">passer des arguments nommés</span></a> à <em>callback</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.remove_writer">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">remove_writer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_writer" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Arrête de surveiller le descripteur de fichier <em>fd</em> pour la disponibilité en écriture. Renvoie <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>fd</em> était précédemment surveillé pour les écritures.</p>
</dd></dl>

<p>Voir aussi la section <a class="reference internal" href="asyncio-platforms.html#asyncio-platform-support"><span class="std std-ref">Prise en charge de la plate-forme</span></a> pour certaines limitations de ces méthodes.</p>
</section>
<section id="working-with-socket-objects-directly">
<h3><a class="toc-backref" href="#id10">Travail direct avec des objets <em>socket</em></a><a class="headerlink" href="#working-with-socket-objects-directly" title="Lien permanent vers ce titre">¶</a></h3>
<p>En général, les implémentations de protocole qui utilisent des API basées sur le transport telles que <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> et <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> sont plus rapides que les implémentations qui fonctionnent directement avec les <em>sockets</em>. Cependant, il existe des cas d'utilisation où les performances ne sont pas critiques, et travailler directement avec les objets <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> est plus pratique.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recv">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbytes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recv" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Reçoit jusqu'à <em>nbytes</em> de <em>sock</em>. Version asynchrone de <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv()</span></code></a>.</p>
<p>Renvoie les données reçues sous la forme d'un objet bytes.</p>
<p>Le connecteur <em>sock</em> ne doit pas être bloquant.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>même si cette méthode a toujours été documentée en tant que méthode coroutine, les versions antérieures à Python 3.7 renvoyaient un <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. Depuis Python 3.7, il s'agit d'une méthode <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recv_into">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recv_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recv_into" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Reçoit les données de <em>sock</em> dans le tampon <em>buf</em>. Basée sur le modèle de la méthode bloquante <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv_into()</span></code></a>.</p>
<p>Renvoie le nombre d'octets écrits dans le tampon.</p>
<p>Le connecteur <em>sock</em> ne doit pas être bloquant.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recvfrom">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recvfrom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bufsize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recvfrom" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Reçoit un datagramme jusqu'à <em>bufsize</em> de <em>sock</em>. Version asynchrone de <a class="reference internal" href="socket.html#socket.socket.recvfrom" title="socket.socket.recvfrom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recvfrom()</span></code></a>.</p>
<p>Renvoie un <em>n</em>-uplet (données reçues, adresse distante).</p>
<p>Le connecteur <em>sock</em> ne doit pas être bloquant.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recvfrom_into">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recvfrom_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbytes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recvfrom_into" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Reçoit un datagramme jusqu'à <em>nbytes</em> de <em>sock</em> vers <em>buf</em>. Version asynchrone de <a class="reference internal" href="socket.html#socket.socket.recvfrom_into" title="socket.socket.recvfrom_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recvfrom_into()</span></code></a>.</p>
<p>Renvoie un <em>n</em>-uplet (nombre d'octets reçus, adresse distante).</p>
<p>Le connecteur <em>sock</em> ne doit pas être bloquant.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_sendall">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_sendall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendall" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Envoie les données <em>data</em> au connecteur <em>sock</em>. Version asynchrone de <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendall()</span></code></a>.</p>
<p>Cette méthode continue d'envoyer des données au connecteur jusqu'à ce que toutes les <em>data</em> aient été envoyées ou qu'une erreur se produise. <code class="docutils literal notranslate"><span class="pre">None</span></code> est renvoyé en cas de succès. En cas d'erreur, une exception est levée. De plus, il n'existe aucun moyen de déterminer la quantité de données, le cas échéant, qui a été traitée avec succès par l'extrémité réceptrice de la connexion.</p>
<p>Le connecteur <em>sock</em> ne doit pas être bloquant.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>même si la méthode a toujours été documentée en tant que méthode coroutine, avant Python 3.7, elle renvoyait un <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. Depuis Python 3.7, il s'agit d'une méthode <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_sendto">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_sendto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendto" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Envoie un datagramme de <em>sock</em> à <em>address</em>. Version asynchrone de <a class="reference internal" href="socket.html#socket.socket.sendto" title="socket.socket.sendto"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendto()</span></code></a>.</p>
<p>Renvoie le nombre d'octets envoyés.</p>
<p>Le connecteur <em>sock</em> ne doit pas être bloquant.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_connect">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_connect" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Connecte <em>sock</em> à un connecteur distant situé à <em>address</em>.</p>
<p>Version asynchrone de <a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code></a>.</p>
<p>Le connecteur <em>sock</em> ne doit pas être bloquant.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5.2: </span><code class="docutils literal notranslate"><span class="pre">address</span></code> n'a plus besoin d'être résolu. <code class="docutils literal notranslate"><span class="pre">sock_connect</span></code> essaie de vérifier si <em>address</em> est déjà résolue en appelant <a class="reference internal" href="socket.html#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.inet_pton()</span></code></a>. Sinon, <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.getaddrinfo()</span></code></a> est utilisé pour résoudre <em>address</em>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p><a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> et <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_accept">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_accept</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_accept" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Accepte une connexion. Basée sur le modèle de la méthode bloquante <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept()</span></code></a>.</p>
<p>Le connecteur doit être lié à une adresse et écouter les connexions. La valeur de retour est une paire <code class="docutils literal notranslate"><span class="pre">(conn,</span> <span class="pre">adresse)</span></code> où <em>conn</em> est un <em>nouvel</em> objet socket utilisable pour envoyer et recevoir des données sur la connexion, et <em>adresse</em> est l'adresse liée au connecteur de l'autre côté de la connexion.</p>
<p>Le connecteur <em>sock</em> ne doit pas être bloquant.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>même si la méthode a toujours été documentée en tant que méthode coroutine, avant Python 3.7, elle renvoyait un <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. Depuis Python 3.7, il s'agit d'une méthode <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p><a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> et <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_sendfile">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_sendfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fallback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendfile" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Envoie le fichier en utilisant <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a> (haute performance) si possible. Renvoie le nombre total d'octets envoyés.</p>
<p>Version asynchrone de <a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendfile()</span></code></a>.</p>
<p><em>sock</em> doit être un <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code></a> <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> non bloquant.</p>
<p><em>file</em> doit être un objet fichier normal ouvert en mode binaire.</p>
<p><em>offset</em> indique où commencer la lecture du fichier. Si spécifié, <em>count</em> est le nombre total d'octets à transmettre, par opposition à l'envoi du fichier jusqu'à ce que EOF soit atteint. La position du fichier est toujours mise à jour, même lorsque cette méthode génère une erreur. <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> peut être utilisée pour obtenir le nombre d'octets réellement envoyés.</p>
<p><em>fallback</em>, lorsqu'il est défini à <code class="docutils literal notranslate"><span class="pre">True</span></code>, permet à <em>asyncio</em> de lire et d'envoyer manuellement le fichier lorsque la plateforme ne prend pas en charge l'appel système <em>sendfile</em> (par exemple, Windows ou connecteur SSL sous Unix).</p>
<p>Lève une <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a> si le système ne prend pas en charge l'appel système <em>sendfile</em> et que <em>fallback</em> est <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Le connecteur <em>sock</em> ne doit pas être bloquant.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7.</span></p>
</div>
</dd></dl>

</section>
<section id="dns">
<h3><a class="toc-backref" href="#id11">DNS</a><a class="headerlink" href="#dns" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.getaddrinfo">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">getaddrinfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.getaddrinfo" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Version asynchrone de <a class="reference internal" href="socket.html#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getaddrinfo()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.getnameinfo">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">getnameinfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sockaddr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.getnameinfo" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Version asynchrone de <a class="reference internal" href="socket.html#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getnameinfo()</span></code></a>.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>les méthodes <em>getaddrinfo</em> et <em>getnameinfo</em> ont toujours été documentées pour renvoyer une coroutine, mais avant Python 3.7, elles renvoyaient en fait des objets <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a>. À partir de Python 3.7, les deux méthodes sont des coroutines.</p>
</div>
</section>
<section id="working-with-pipes">
<h3><a class="toc-backref" href="#id12">Travail avec des tubes (<em>pipes</em>)</a><a class="headerlink" href="#working-with-pipes" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.connect_read_pipe">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">connect_read_pipe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipe</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_read_pipe" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Branche l'extrémité en lecture du tube <em>pipe</em> à la boucle d'évènements.</p>
<p><em>protocol_factory</em> doit être un appelable renvoyant un protocole gérant le <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocole asyncio</span></a>.</p>
<p><em>pipe</em> est un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">simili-fichier</span></a>.</p>
<p>Renvoie la paire <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, où <em>transport</em> prend en charge l'interface <a class="reference internal" href="asyncio-protocol.html#asyncio.ReadTransport" title="asyncio.ReadTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReadTransport</span></code></a> et <em>protocol</em> est un objet instancié par <em>protocol_factory</em>.</p>
<p>Avec la boucle d'événements <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a>, le <em>pipe</em> est mis en mode non bloquant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.connect_write_pipe">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">connect_write_pipe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipe</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_write_pipe" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Branche l'extrémité en écriture de <em>pipe</em> à la boucle d'évènements.</p>
<p><em>protocol_factory</em> doit être un appelable renvoyant un protocole gérant le <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocole asyncio</span></a>.</p>
<p><em>pipe</em> est un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">simili-fichier</span></a>.</p>
<p>Renvoie la paire <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, où <em>transport</em> prend en charge l'interface <a class="reference internal" href="asyncio-protocol.html#asyncio.WriteTransport" title="asyncio.WriteTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">WriteTransport</span></code></a> et <em>protocol</em> est un objet instancié par <em>protocol_factory</em>.</p>
<p>Avec la boucle d'événements <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a>, le <em>pipe</em> est mis en mode non bloquant.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> ne prend pas en charge les méthodes ci-dessus sous Windows. Utilisez <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> à la place pour Windows.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p>les méthodes <a class="reference internal" href="#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a> et <a class="reference internal" href="#asyncio.loop.subprocess_shell" title="asyncio.loop.subprocess_shell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_shell()</span></code></a>.</p>
</div>
</section>
<section id="unix-signals">
<h3><a class="toc-backref" href="#id13">Signaux Unix</a><a class="headerlink" href="#unix-signals" title="Lien permanent vers ce titre">¶</a></h3>
<span class="target" id="loop-add-signal-handler"></span><dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.add_signal_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">add_signal_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_signal_handler" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Définit <em>callback</em> comme gestionnaire du signal <em>signum</em>.</p>
<p>La fonction de rappel sera appelée par <em>loop</em>, avec d'autres rappels en file d'attente et des coroutines exécutables de cette boucle d'événements. Contrairement aux gestionnaires de signaux enregistrés à l'aide de <a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a>, un rappel enregistré avec cette fonction est autorisé à interagir avec la boucle d'événements.</p>
<p>Lève une <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si le numéro de signal est invalide ou non attrapable. Lève une <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> s'il y a un problème lors de la configuration du gestionnaire.</p>
<p>Utilisez <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> pour <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">passer des arguments nommés</span></a> à <em>callback</em>.</p>
<p>Comme <a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a>, cette fonction doit être invoquée dans le fil d'exécution principal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.remove_signal_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">remove_signal_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_signal_handler" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Supprime le gestionnaire du signal <em>sig</em>.</p>
<p>Renvoie <code class="docutils literal notranslate"><span class="pre">True</span></code> si le gestionnaire de signal a été supprimé, ou <code class="docutils literal notranslate"><span class="pre">False</span></code> si aucun gestionnaire n'a été défini pour le signal donné.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilité</span></a> : Unix.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p>le module <a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a>.</p>
</div>
</section>
<section id="executing-code-in-thread-or-process-pools">
<h3><a class="toc-backref" href="#id14">Exécution de code dans des pools de threads ou de processus</a><a class="headerlink" href="#executing-code-in-thread-or-process-pools" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.run_in_executor">
<em class="property"><span class="pre">awaitable</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">run_in_executor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">executor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_in_executor" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Fait en sorte que <em>func</em> soit appelée dans l'exécuteur spécifié.</p>
<p>L'argument <em>executor</em> doit être une instance <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Executor" title="concurrent.futures.Executor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.Executor</span></code></a>. L'exécuteur par défaut est utilisé si <em>executor</em> vaut <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>

<span class="k">def</span> <span class="nf">blocking_io</span><span class="p">():</span>
    <span class="c1"># File operations (such as logging) can block the</span>
    <span class="c1"># event loop: run them in a thread pool.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/dev/urandom&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cpu_bound</span><span class="p">():</span>
    <span class="c1"># CPU-bound operations will block the event loop:</span>
    <span class="c1"># in general it is preferable to run them in a</span>
    <span class="c1"># process pool.</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">7</span><span class="p">))</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="c1">## Options:</span>

    <span class="c1"># 1. Run in the default loop&#39;s executor:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;default thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 2. Run in a custom thread pool:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 3. Run in a custom process pool:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">cpu_bound</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom process pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p>Notez que la garde du point d'entrée (<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code>) est requis pour l'option 3 en raison des particularités de <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>, qui est utilisé par <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessPoolExecutor</span></code></a>. Voir <a class="reference internal" href="multiprocessing.html#multiprocessing-safe-main-import"><span class="std std-ref">Importation sécurisée du module principal</span></a>.</p>
<p>Cette méthode renvoie un objet <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a>.</p>
<p>Utilisez <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> pour <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">passer des arguments nommés</span></a> à <em>func</em>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.5.3: </span><a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a> ne configure plus le <code class="docutils literal notranslate"><span class="pre">max_workers</span></code> de l'exécuteur de pool de threads qu'il crée, laissant à la place à l'exécuteur de pool de threads (<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>) le soin de définir le défaut.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_default_executor">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_default_executor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">executor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_default_executor" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Définit <em>executor</em> comme exécuteur par défaut utilisé par <a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_in_executor()</span></code></a>. <em>executor</em> doit être une instance de <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span><em>executor</em> doit être une instance de <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="error-handling-api">
<h3><a class="toc-backref" href="#id15">API de gestion d'erreur</a><a class="headerlink" href="#error-handling-api" title="Lien permanent vers ce titre">¶</a></h3>
<p>Permet de personnaliser la façon dont les exceptions sont gérées dans la boucle d'événements.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_exception_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_exception_handler" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Définit <em>handler</em> comme nouveau gestionnaire d'exceptions de boucle d'événements.</p>
<p>Si <em>handler</em> est <code class="docutils literal notranslate"><span class="pre">None</span></code>, le gestionnaire d'exceptions par défaut est activé. Sinon, <em>handler</em> doit être un appelable avec la signature correspondant à <code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">context)</span></code>, où <code class="docutils literal notranslate"><span class="pre">loop</span></code> est une référence à la boucle d'événements active et <code class="docutils literal notranslate"><span class="pre">context</span></code> est un <code class="docutils literal notranslate"><span class="pre">dict</span></code> contenant les détails de l'exception (voir la documentation <a class="reference internal" href="#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a> pour plus de détails sur le contexte).</p>
<p>If the handler is called on behalf of a <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> or
<a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a>, it is run in the
<a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> of that task or callback handle.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.12: </span>The handler may be called in the <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>
of the task or handle where the exception originated.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.get_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">get_exception_handler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_exception_handler" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie le gestionnaire d'exceptions actuel ou <code class="docutils literal notranslate"><span class="pre">None</span></code> si aucun gestionnaire d'exceptions personnalisé n'a été défini.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.5.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.default_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">default_exception_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.default_exception_handler" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Gestionnaire d'exception par défaut.</p>
<p>Appelée lorsqu'une exception se produit et qu'aucun gestionnaire d'exception n'est défini. Elle peut être appelée par un gestionnaire d'exceptions personnalisé qui souhaite s'en remettre au comportement du gestionnaire par défaut.</p>
<p>Le paramètre <em>context</em> a la même signification que dans <a class="reference internal" href="#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_exception_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_exception_handler" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Appelle le gestionnaire d'exception de la boucle d'évènements actuelle.</p>
<p><em>context</em> est un objet <code class="docutils literal notranslate"><span class="pre">dict</span></code> contenant les clés suivantes (de nouvelles clés pourront être introduites dans les futures versions de Python) :</p>
<ul class="simple">
<li><p>'message' : message d'erreur ;</p></li>
<li><p>'exception' (facultatif) : objet exception ;</p></li>
<li><p>'future' (facultatif) : instance de <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> ;</p></li>
<li><p>'task' (facultatif) : instance de <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a> ;</p></li>
<li><p><em>'handle'</em> (facultatif) : instance de <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a> ;</p></li>
<li><p><em>'protocol'</em> (facultatif) : instance de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocole asyncio</span></a> ;</p></li>
<li><p>'transport' (facultatif) : instance de <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">transport asyncio</span></a> ;</p></li>
<li><p>'socket' (facultatif) : instance de <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> ;</p></li>
<li><dl class="simple">
<dt><em>'asyncgen'</em> (facultatif) : générateur asynchrone qui a causé</dt><dd><p>l'exception</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>cette méthode ne doit pas être surchargée dans les boucles d'événements sous-classées. Pour la gestion personnalisée des exceptions, utilisez la méthode <a class="reference internal" href="#asyncio.loop.set_exception_handler" title="asyncio.loop.set_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_exception_handler()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="enabling-debug-mode">
<h3><a class="toc-backref" href="#id16">Activation du mode débogage</a><a class="headerlink" href="#enabling-debug-mode" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.get_debug">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">get_debug</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_debug" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Obtient le mode de débogage (<a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>) de la boucle d'événements.</p>
<p>La valeur par défaut est <code class="docutils literal notranslate"><span class="pre">True</span></code> si la variable d'environnement <span class="target" id="index-17"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONASYNCIODEBUG"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONASYNCIODEBUG</span></code></a> est définie sur une chaîne non vide, <code class="docutils literal notranslate"><span class="pre">False</span></code> sinon.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_debug">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_debug</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enabled</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="functions.html#bool" title="bool"><span class="pre">bool</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_debug" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Active le mode débogage pour la boucle d'évènements.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>le nouveau <a class="reference internal" href="devmode.html#devmode"><span class="std std-ref">mode de développement Python</span></a> peut désormais également être utilisé pour activer le mode de débogage.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="asyncio.loop.slow_callback_duration">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">slow_callback_duration</span></span><a class="headerlink" href="#asyncio.loop.slow_callback_duration" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>This attribute can be used to set the
minimum execution duration in seconds that is considered &quot;slow&quot;.
When debug mode is enabled, &quot;slow&quot; callbacks are logged.</p>
<p>Default value is 100 milliseconds.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p>le <a class="reference internal" href="asyncio-dev.html#asyncio-debug-mode"><span class="std std-ref">mode debogage d'asyncio</span></a>.</p>
</div>
</section>
<section id="running-subprocesses">
<h3><a class="toc-backref" href="#id17">Exécution de sous-processus</a><a class="headerlink" href="#running-subprocesses" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les méthodes décrites dans ces sous-sections sont de bas niveau. Dans le code <em>async/await</em> normal, pensez à utiliser les fonctions de commodité de haut niveau <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_shell" title="asyncio.create_subprocess_shell"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_shell()</span></code></a> et <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_exec" title="asyncio.create_subprocess_exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_exec()</span></code></a> à la place.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>sous Windows, la boucle d'événements par défaut <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> prend en charge les sous-processus, contrairement à <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a>. Voir <a class="reference internal" href="asyncio-platforms.html#asyncio-windows-subprocess"><span class="std std-ref">Prise en charge des sous-processus sous Windows</span></a> pour plus de détails.</p>
</div>
<span class="target" id="loop-subprocess-exec"></span><dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.subprocess_exec">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">subprocess_exec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stderr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.subprocess_exec" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Crée un sous-processus à partir d'un ou plusieurs arguments de chaîne spécifiés par <em>args</em>.</p>
<p><em>args</em> doit être une liste de chaînes représentée par :</p>
<ul class="simple">
<li><p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ;</p></li>
<li><p>ou <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, encodés selon l'<a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">encodage du système de fichiers</span></a>.</p></li>
</ul>
<p>La première chaîne spécifie l'exécutable du programme et les chaînes restantes spécifient les arguments. Ensemble, les arguments de chaîne forment le <code class="docutils literal notranslate"><span class="pre">argv</span></code> du programme.</p>
<p>C'est similaire à la classe standard de la bibliothèque <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> appelée avec <code class="docutils literal notranslate"><span class="pre">shell=False</span></code> et la liste des chaînes passées en premier argument ; cependant, où <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">Popen</span></code></a> prend un seul argument qui est une liste de chaînes, <em>subprocess_exec</em> prend plusieurs arguments de chaînes.</p>
<p>Le <em>protocol_factory</em> doit être un appelable renvoyant une sous-classe de la classe <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessProtocol</span></code></a>.</p>
<p>Autres paramètres :</p>
<ul>
<li><p><em>stdin</em> peut être l'un de ces éléments :</p>
<ul class="simple">
<li><p>a file-like object</p></li>
<li><p>an existing file descriptor (a positive integer), for example those created with <a class="reference internal" href="os.html#os.pipe" title="os.pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">os.pipe()</span></code></a></p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> (par défaut) qui va créer un nouveau tube et le connecter,</p></li>
<li><p>la valeur <code class="docutils literal notranslate"><span class="pre">None</span></code> qui fera que le sous-processus héritera du descripteur de fichier de ce processus,</p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> qui indique que le fichier spécial <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> sera utilisé.</p></li>
</ul>
</li>
<li><p><em>stdout</em> peut être l'un de ces éléments :</p>
<ul class="simple">
<li><p>a file-like object</p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> (par défaut) qui va créer un nouveau tube et le connecter,</p></li>
<li><p>la valeur <code class="docutils literal notranslate"><span class="pre">None</span></code> qui fera que le sous-processus héritera du descripteur de fichier de ce processus,</p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> qui indique que le fichier spécial <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> sera utilisé.</p></li>
</ul>
</li>
<li><p><em>stderr</em> peut être l'un de ces éléments :</p>
<ul class="simple">
<li><p>a file-like object</p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> (par défaut) qui va créer un nouveau tube et le connecter,</p></li>
<li><p>la valeur <code class="docutils literal notranslate"><span class="pre">None</span></code> qui fera que le sous-processus héritera du descripteur de fichier de ce processus,</p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> qui indique que le fichier spécial <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> sera utilisé.</p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.STDOUT" title="subprocess.STDOUT"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.STDOUT</span></code></a> qui connectera le flux d'erreur standard au flux de sortie standard du processus.</p></li>
</ul>
</li>
<li><p>Tous les autres arguments nommés sont passés à <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> sans interprétation, à l'exception de <em>bufsize</em>, <em>universal_newlines</em>, <em>shell</em>, <em>text</em>, <em>encoding</em> et <em>errors</em>, qui ne doivent pas être spécifiés du tout.</p>
<p>L'API de sous-processus <code class="docutils literal notranslate"><span class="pre">asyncio</span></code> ne prend pas en charge le décodage des flux sous forme de texte. <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> peut être utilisée pour convertir les octets renvoyés par le flux en texte.</p>
</li>
</ul>
<p>If a file-like object passed as <em>stdin</em>, <em>stdout</em> or <em>stderr</em> represents a
pipe, then the other side of this pipe should be registered with
<a class="reference internal" href="#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_write_pipe()</span></code></a> or <a class="reference internal" href="#asyncio.loop.connect_read_pipe" title="asyncio.loop.connect_read_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_read_pipe()</span></code></a> for use
with the event loop.</p>
<p>Voir le constructeur de la classe <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> pour la documentation sur les autres arguments.</p>
<p>Renvoie une paire <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, où <em>transport</em> est conforme à la classe de base <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessTransport</span></code></a> et <em>protocol</em> est un objet instancié par <em>protocol_factory</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.subprocess_shell">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">subprocess_shell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmd</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stderr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.subprocess_shell" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Crée un sous-processus à partir de <em>cmd</em>, qui peut être une chaîne <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou une chaîne <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> encodée avec l'<a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">encodage du système de fichiers</span></a>, en utilisant la syntaxe &quot;shell&quot; de la plate-forme.</p>
<p>C'est similaire à la classe standard de la bibliothèque <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> appelée avec <code class="docutils literal notranslate"><span class="pre">shell=True</span></code>.</p>
<p>Le <em>protocol_factory</em> doit être un appelable renvoyant une sous-classe de la classe <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessProtocol</span></code></a>.</p>
<p>Voir <a class="reference internal" href="#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess_exec()</span></code></a> pour plus de détails sur les arguments restants.</p>
<p>Renvoie une paire <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, où <em>transport</em> est conforme à la classe de base <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessTransport</span></code></a> et <em>protocol</em> est un objet instancié par <em>protocol_factory</em>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>il est de la responsabilité de l'application de s'assurer que tous les espaces blancs et les caractères spéciaux sont correctement échappés pour éviter les vulnérabilités d'<a class="reference external" href="https://en.wikipedia.org/wiki/Shell_injection#Shell_injection">injection de shell</a>. La fonction <a class="reference internal" href="shlex.html#shlex.quote" title="shlex.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">shlex.quote()</span></code></a> peut être utilisée pour échapper correctement les espaces blancs et les caractères spéciaux dans les chaînes qui seront utilisées pour construire des commandes shell.</p>
</div>
</section>
</section>
<section id="callback-handles">
<h2>Fonctions de rappel sur des descripteurs<a class="headerlink" href="#callback-handles" title="Lien permanent vers ce titre">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Handle">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Handle</span></span><a class="headerlink" href="#asyncio.Handle" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Objet encapsulant une fonction de rappel renvoyé par <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a>, <a class="reference internal" href="#asyncio.loop.call_soon_threadsafe" title="asyncio.loop.call_soon_threadsafe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon_threadsafe()</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Handle.get_context">
<span class="sig-name descname"><span class="pre">get_context</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.get_context" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Return the <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> object
associated with the handle.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Handle.cancel">
<span class="sig-name descname"><span class="pre">cancel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancel" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Annule le rappel. Si le rappel a déjà été annulé ou exécuté, cette méthode n'a aucun effet.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Handle.cancelled">
<span class="sig-name descname"><span class="pre">cancelled</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancelled" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie <code class="docutils literal notranslate"><span class="pre">True</span></code> si la fonction de rappel a été annulée.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncio.TimerHandle">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">TimerHandle</span></span><a class="headerlink" href="#asyncio.TimerHandle" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Objet encapsulant la fonction de rappel renvoyé par <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a> et <a class="reference internal" href="#asyncio.loop.call_at" title="asyncio.loop.call_at"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_at()</span></code></a>.</p>
<p>Cette classe est une sous-classe de <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.TimerHandle.when">
<span class="sig-name descname"><span class="pre">when</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.TimerHandle.when" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie une heure de rappel planifiée sous forme de <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> secondes.</p>
<p>L'heure est un horodatage absolu, utilisant la même référence de temps que <a class="reference internal" href="#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7.</span></p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="server-objects">
<h2>Objets Serveur<a class="headerlink" href="#server-objects" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les objets serveur sont créés par les fonctions <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>, <a class="reference internal" href="#asyncio.loop.create_unix_server" title="asyncio.loop.create_unix_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_server()</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a> et <a class="reference internal" href="asyncio-stream.html#asyncio.start_unix_server" title="asyncio.start_unix_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_unix_server()</span></code></a>.</p>
<p>Do not instantiate the <a class="reference internal" href="#asyncio.Server" title="asyncio.Server"><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code></a> class directly.</p>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Server">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Server</span></span><a class="headerlink" href="#asyncio.Server" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Les objets <em>Server</em> sont des gestionnaires de contexte asynchrones. Lorsqu'il est utilisé dans une instruction <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>, il est garanti que l'objet Serveur est fermé et n'accepte pas de nouvelle connexion lorsque l'instruction <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> est terminée :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">srv</span><span class="p">:</span>
    <span class="c1"># some code</span>

<span class="c1"># At this point, srv is closed and no longer accepts new connections.</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>l'objet serveur est un gestionnaire de contexte asynchrone depuis Python 3.7.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.11: </span>This class was exposed publicly as <code class="docutils literal notranslate"><span class="pre">asyncio.Server</span></code> in Python 3.9.11, 3.10.3 and 3.11.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.close" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Arrête le serveur : ferme les connecteurs d'écoute et définit l'attribut <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sockets</span></code></a> à <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Les connecteurs qui représentent les connexions client entrantes existantes restent ouvertes.</p>
<p>Le serveur est fermé de manière asynchrone, utilisez la coroutine <a class="reference internal" href="#asyncio.Server.wait_closed" title="asyncio.Server.wait_closed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_closed()</span></code></a> pour attendre que le serveur soit fermé.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.get_loop">
<span class="sig-name descname"><span class="pre">get_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.get_loop" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie la boucle d'événement associée à l'objet serveur.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.start_serving">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">start_serving</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.start_serving" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Commence à accepter les connexions.</p>
<p>Cette méthode est idempotente, elle peut donc être appelée lorsque le serveur est déjà en service.</p>
<p>Le paramètre nommé <em>start_serving</em> de <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> et <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.start_server()</span></code></a> permet de créer un objet <em>Server</em> qui n'accepte pas les connexions initialement. Dans ce cas, <code class="docutils literal notranslate"><span class="pre">Server.start_serving()</span></code> ou <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a> peut être utilisée pour que le serveur commence à accepter les connexions.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.serve_forever">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">serve_forever</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.serve_forever" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Commence à accepter les connexions jusqu'à ce que la coroutine soit annulée. L'annulation de la tâche <code class="docutils literal notranslate"><span class="pre">serve_forever</span></code> provoque la fermeture du serveur.</p>
<p>Cette méthode peut être appelée si le serveur accepte déjà les connexions. Une seule tâche <code class="docutils literal notranslate"><span class="pre">serve_forever</span></code> peut exister par objet <em>Server</em>.</p>
<p>Exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">client_connected</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
    <span class="c1"># Communicate with the client with</span>
    <span class="c1"># reader/writer streams.  For example:</span>
    <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span>
        <span class="n">client_connected</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">srv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.is_serving">
<span class="sig-name descname"><span class="pre">is_serving</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.is_serving" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie <code class="docutils literal notranslate"><span class="pre">True</span></code> si le serveur accepte de nouvelles connexions.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nouveau dans la version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.wait_closed">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">wait_closed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.wait_closed" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Attend que la méthode <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> se termine.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="asyncio.Server.sockets">
<span class="sig-name descname"><span class="pre">sockets</span></span><a class="headerlink" href="#asyncio.Server.sockets" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>List of socket-like objects, <code class="docutils literal notranslate"><span class="pre">asyncio.trsock.TransportSocket</span></code>, which
the server is listening on.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Modifié dans la version 3.7: </span>avant Python 3.7, <code class="docutils literal notranslate"><span class="pre">Server.sockets</span></code> renvoyait directement une liste interne de sockets de serveur. En 3.7, une copie de cette liste est renvoyée.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="event-loop-implementations">
<span id="asyncio-event-loop-implementations"></span><span id="asyncio-event-loops"></span><h2>Implémentations de boucle d'évènements<a class="headerlink" href="#event-loop-implementations" title="Lien permanent vers ce titre">¶</a></h2>
<p><em>asyncio</em> est livré avec deux implémentations de boucles d'événements différentes : <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> et <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
<p>Par défaut, <em>asyncio</em> est configuré pour utiliser <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> sous Unix et <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> sous Windows.</p>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.SelectorEventLoop">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">SelectorEventLoop</span></span><a class="headerlink" href="#asyncio.SelectorEventLoop" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Boucle d'événements basée sur le module <a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a>.</p>
<p>Utilise le <em>sélecteur</em> le plus efficace disponible pour la plate-forme donnée. Il est également possible de configurer manuellement l'implémentation exacte du sélecteur à utiliser :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">selectors</span>

<span class="k">class</span> <span class="nc">MyPolicy</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">DefaultEventLoopPolicy</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">new_event_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">selector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">SelectSelector</span><span class="p">()</span>
      <span class="k">return</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">SelectorEventLoop</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop_policy</span><span class="p">(</span><span class="n">MyPolicy</span><span class="p">())</span>
</pre></div>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilité</span></a> : Unix, Windows.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncio.ProactorEventLoop">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">ProactorEventLoop</span></span><a class="headerlink" href="#asyncio.ProactorEventLoop" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Boucle d'événements pour Windows qui utilise des &quot;I/O Completion Ports&quot; (IOCP).</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilité</span></a> : Windows.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p><a class="reference external" href="https://docs.microsoft.com/fr-fr/windows/desktop/FileIO/i-o-completion-ports">Documentation MSDN sur les ports de saisie semi-automatique d’E/S</a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncio.AbstractEventLoop">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">AbstractEventLoop</span></span><a class="headerlink" href="#asyncio.AbstractEventLoop" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Classe mère abstraite pour les boucles d'événements conforme à <em>asyncio</em>.</p>
<p>La section <a class="reference internal" href="#asyncio-event-loop-methods"><span class="std std-ref">Méthodes de la boucle d'évènements</span></a> liste toutes les méthodes qu'une implémentation alternative de <code class="docutils literal notranslate"><span class="pre">AbstractEventLoop</span></code> doit définir.</p>
</dd></dl>

</section>
<section id="examples">
<h2>Exemples<a class="headerlink" href="#examples" title="Lien permanent vers ce titre">¶</a></h2>
<p>Notez que tous les exemples de cette section montrent <strong>à dessein</strong> comment utiliser les API de boucle d'événement de bas niveau, telles que <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_forever()</span></code></a> et <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a>. Les applications <em>asyncio</em> modernes ont rarement besoin d'être écrites de cette façon ; pensez à utiliser les fonctions de haut niveau comme <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>.</p>
<section id="hello-world-with-call-soon">
<span id="asyncio-example-lowlevel-helloworld"></span><h3>&quot;Hello World&quot; avec <code class="docutils literal notranslate"><span class="pre">call_soon()</span></code><a class="headerlink" href="#hello-world-with-call-soon" title="Lien permanent vers ce titre">¶</a></h3>
<p>Un exemple utilisant la méthode <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> pour programmer un rappel. Le rappel affiche <code class="docutils literal notranslate"><span class="pre">&quot;Hello</span> <span class="pre">World&quot;</span></code> puis arrête la boucle d'événements :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A callback to print &#39;Hello World&#39; and stop the event loop&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule a call to hello_world()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">hello_world</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p>un exemple similaire de <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">Hello World</span></a> créé avec une coroutine et la fonction <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>.</p>
</div>
</section>
<section id="display-the-current-date-with-call-later">
<span id="asyncio-example-call-later"></span><h3>Affichage de la date actuelle avec <code class="docutils literal notranslate"><span class="pre">call_later()</span></code><a class="headerlink" href="#display-the-current-date-with-call-later" title="Lien permanent vers ce titre">¶</a></h3>
<p>Un exemple de rappel affichant la date actuelle toutes les secondes. Le rappel utilise la méthode <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a> pour se re-planifier après 5 secondes, puis arrête la boucle d'événements :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">def</span> <span class="nf">display_date</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule the first call to display_date()</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<p>un exemple similaire de <a class="reference internal" href="asyncio-task.html#asyncio-example-sleep"><span class="std std-ref">date actuelle</span></a> créé avec une coroutine et la fonction <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>.</p>
</div>
</section>
<section id="watch-a-file-descriptor-for-read-events">
<span id="asyncio-example-watch-fd"></span><h3>Surveillance des événements de lecture pour un descripteur de fichier<a class="headerlink" href="#watch-a-file-descriptor-for-read-events" title="Lien permanent vers ce titre">¶</a></h3>
<p>Attend qu'un descripteur de fichier reçoive des données en utilisant la méthode <a class="reference internal" href="#asyncio.loop.add_reader" title="asyncio.loop.add_reader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_reader()</span></code></a> puis ferme la boucle d'événements :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socketpair</span>

<span class="c1"># Create a pair of connected file descriptors</span>
<span class="n">rsock</span><span class="p">,</span> <span class="n">wsock</span> <span class="o">=</span> <span class="n">socketpair</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">reader</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">rsock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

    <span class="c1"># We are done: unregister the file descriptor</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">remove_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">)</span>

    <span class="c1"># Stop the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="c1"># Register the file descriptor for read event</span>
<span class="n">loop</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">,</span> <span class="n">reader</span><span class="p">)</span>

<span class="c1"># Simulate the reception of data from the network</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">wsock</span><span class="o">.</span><span class="n">send</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Run the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="c1"># We are done. Close sockets and the event loop.</span>
    <span class="n">rsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">wsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Voir aussi</p>
<ul class="simple">
<li><p>un <a class="reference internal" href="asyncio-protocol.html#asyncio-example-create-connection"><span class="std std-ref">exemple</span></a> similaire utilisant les transports, les protocoles et la méthode <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>,</p></li>
<li><p>un autre <a class="reference internal" href="asyncio-stream.html#asyncio-example-create-connection-streams"><span class="std std-ref">exemple</span></a> utilisant la fonction et les flux de haut niveau <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a>.</p></li>
</ul>
</div>
</section>
<section id="set-signal-handlers-for-sigint-and-sigterm">
<span id="asyncio-example-unix-signals"></span><h3>Gestion des signaux <em>SIGINT</em> et <em>SIGTERM</em><a class="headerlink" href="#set-signal-handlers-for-sigint-and-sigterm" title="Lien permanent vers ce titre">¶</a></h3>
<p>(Cet exemple ne fonctionne que sur Unix.)</p>
<p>Enregistre des gestionnaires pour les signaux <code class="xref py py-data docutils literal notranslate"><span class="pre">SIGINT</span></code> et <code class="xref py py-data docutils literal notranslate"><span class="pre">SIGTERM</span></code> en utilisant la méthode <a class="reference internal" href="#asyncio.loop.add_signal_handler" title="asyncio.loop.add_signal_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_signal_handler()</span></code></a> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">signal</span>

<span class="k">def</span> <span class="nf">ask_exit</span><span class="p">(</span><span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;got signal </span><span class="si">%s</span><span class="s2">: exit&quot;</span> <span class="o">%</span> <span class="n">signame</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">signame</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;SIGINT&#39;</span><span class="p">,</span> <span class="s1">&#39;SIGTERM&#39;</span><span class="p">}:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signame</span><span class="p">),</span>
            <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">ask_exit</span><span class="p">,</span> <span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">))</span>

    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Event loop running for 1 hour, press Ctrl+C to interrupt.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pid </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span><span class="si">}</span><span class="s2">: send SIGINT or SIGTERM to exit.&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#">Boucle d'évènements</a><ul>
<li><a class="reference internal" href="#event-loop-methods">Méthodes de la boucle d'évènements</a><ul>
<li><a class="reference internal" href="#running-and-stopping-the-loop">Démarrer et arrêter une boucle d'évènements</a></li>
<li><a class="reference internal" href="#scheduling-callbacks">Planification des fonctions de rappel</a></li>
<li><a class="reference internal" href="#scheduling-delayed-callbacks">Planification des rappels différés</a></li>
<li><a class="reference internal" href="#creating-futures-and-tasks">Création de <em>Futures</em> et des tâches</a></li>
<li><a class="reference internal" href="#opening-network-connections">Création de connexions</a></li>
<li><a class="reference internal" href="#creating-network-servers">Création de serveurs</a></li>
<li><a class="reference internal" href="#transferring-files">Transfert de fichiers</a></li>
<li><a class="reference internal" href="#tls-upgrade">Passage du flux en TLS</a></li>
<li><a class="reference internal" href="#watching-file-descriptors">Surveillance de descripteur de fichier</a></li>
<li><a class="reference internal" href="#working-with-socket-objects-directly">Travail direct avec des objets <em>socket</em></a></li>
<li><a class="reference internal" href="#dns">DNS</a></li>
<li><a class="reference internal" href="#working-with-pipes">Travail avec des tubes (<em>pipes</em>)</a></li>
<li><a class="reference internal" href="#unix-signals">Signaux Unix</a></li>
<li><a class="reference internal" href="#executing-code-in-thread-or-process-pools">Exécution de code dans des pools de threads ou de processus</a></li>
<li><a class="reference internal" href="#error-handling-api">API de gestion d'erreur</a></li>
<li><a class="reference internal" href="#enabling-debug-mode">Activation du mode débogage</a></li>
<li><a class="reference internal" href="#running-subprocesses">Exécution de sous-processus</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callback-handles">Fonctions de rappel sur des descripteurs</a></li>
<li><a class="reference internal" href="#server-objects">Objets Serveur</a></li>
<li><a class="reference internal" href="#event-loop-implementations">Implémentations de boucle d'évènements</a></li>
<li><a class="reference internal" href="#examples">Exemples</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">&quot;Hello World&quot; avec <code class="docutils literal notranslate"><span class="pre">call_soon()</span></code></a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">Affichage de la date actuelle avec <code class="docutils literal notranslate"><span class="pre">call_later()</span></code></a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">Surveillance des événements de lecture pour un descripteur de fichier</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">Gestion des signaux <em>SIGINT</em> et <em>SIGTERM</em></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="asyncio-exceptions.html"
                          title="Chapitre précédent">Exceptions</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="asyncio-future.html"
                          title="Chapitre suivant">Futures</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/asyncio-eventloop.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="Futures"
             >suivant</a> |</li>
        <li class="right" >
          <a href="asyncio-exceptions.html" title="Exceptions"
             >précédent</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La bibliothèque standard</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Réseau et communication entre processus</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — Entrées/Sorties asynchrones</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Boucle d'évènements</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Mis à jour le oct. 26, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Créé en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>