
<!DOCTYPE html>

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="Glossaire" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/glossary.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content=">>>, L'invite de commande utilisée par défaut dans l'interpréteur interactif. On la voit souvent dans des exemples de code qui peuvent être exécutés interactivement dans l'interpréteur.,,..., Peut ..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content=">>>, L'invite de commande utilisée par défaut dans l'interpréteur interactif. On la voit souvent dans des exemples de code qui peuvent être exécutés interactivement dans l'interpréteur.,,..., Peut ..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Glossaire &#8212; Documentation Python 3.12.0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/pydoctheme.css?digest=b37c26da2f7529d09fe70b41c4b2133fe4931a90" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="_static/pygments_dark.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Recherchez dans Documentation Python 3.12.0"
          href="_static/opensearch.xml"/>
    <link rel="author" title="À propos de ces documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="À propos de ces documents" href="about.html" />
    <link rel="prev" title="FAQ &#34;Pourquoi Python est installé sur mon ordinateur ?&#34;" href="faq/installed.html" />
    <link rel="canonical" href="https://docs.python.org/3/glossary.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="_static/py.svg" />
            <script type="text/javascript" src="_static/copybutton.js"></script>
            <script type="text/javascript" src="_static/menu.js"></script>
            <script type="text/javascript" src="_static/search-focus.js"></script>
            <script type="text/javascript" src="_static/themetoggle.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="_static/py.svg" alt="Logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" />
                <input type="submit" value="Go"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="faq/installed.html"
                          title="Chapitre précédent">FAQ &quot;Pourquoi Python est installé sur mon ordinateur ?&quot;</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="about.html"
                          title="Chapitre suivant">À propos de ces documents</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="about.html" title="À propos de ces documents"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="FAQ &#34;Pourquoi Python est installé sur mon ordinateur ?&#34;"
             accesskey="P">précédent</a> |</li>

          <li><img src="_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.12.0 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">Glossaire</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="glossary">
<span id="id1"></span><h1>Glossaire<a class="headerlink" href="#glossary" title="Lien permanent vers ce titre">¶</a></h1>
<dl class="glossary">
<dt id="term-0"><code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code><a class="headerlink" href="#term-0" title="Lien permanent vers ce terme">¶</a></dt><dd><p>L'invite de commande utilisée par défaut dans l'interpréteur interactif. On la voit souvent dans des exemples de code qui peuvent être exécutés interactivement dans l'interpréteur.</p>
</dd>
<dt id="term-..."><code class="docutils literal notranslate"><span class="pre">...</span></code><a class="headerlink" href="#term-..." title="Lien permanent vers ce terme">¶</a></dt><dd><p>Peut faire référence à :</p>
<ul class="simple">
<li><p>L'invite de commande utilisée par défaut dans l'interpréteur interactif lorsqu'on entre un bloc de code indenté, dans des délimiteurs fonctionnant par paires (parenthèses, crochets, accolades, triple guillemets), ou après un avoir spécifié un décorateur.</p></li>
<li><p>La constante <a class="reference internal" href="library/constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal notranslate"><span class="pre">Ellipsis</span></code></a>.</p></li>
</ul>
</dd>
<dt id="term-2to3">2to3<a class="headerlink" href="#term-2to3" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Outil qui essaie de convertir du code pour Python 2.x en code pour Python 3.x en gérant la plupart des incompatibilités qui peuvent être détectées en analysant la source et parcourant son arbre syntaxique.</p>
<p><em>2to3</em> est disponible dans la bibliothèque standard sous le nom de <a class="reference internal" href="library/2to3.html#module-lib2to3" title="lib2to3: The 2to3 library"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lib2to3</span></code></a> ; un point d’entrée indépendant est fourni via <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/2to3</span></code>. Cf. <a class="reference internal" href="library/2to3.html#to3-reference"><span class="std std-ref">2to3 --- Automated Python 2 to 3 code translation</span></a>.</p>
</dd>
<dt id="term-abstract-base-class">classe mère abstraite<a class="headerlink" href="#term-abstract-base-class" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Les classes mères abstraites (ABC, suivant l'abréviation anglaise <em>Abstract Base Class</em>) complètent le <a class="reference internal" href="#term-duck-typing"><span class="xref std std-term">duck-typing</span></a> en fournissant un moyen de définir des interfaces pour les cas où d'autres techniques comme <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> seraient inélégantes ou subtilement fausses (par exemple avec les <a class="reference internal" href="reference/datamodel.html#special-lookup"><span class="std std-ref">méthodes magiques</span></a>). Les ABC introduisent des sous-classes virtuelles qui n'héritent pas d'une classe mais qui sont quand même reconnues par <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> ou <a class="reference internal" href="library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> (voir la documentation du module <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>). Python contient de nombreuses ABC pour les structures de données (dans le module <a class="reference internal" href="library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a>), les nombres (dans le module <a class="reference internal" href="library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">numbers</span></code></a>), les flux (dans le module <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>) et les chercheurs-chargeurs du système d'importation (dans le module <a class="reference internal" href="library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a>). Vous pouvez créer vos propres ABC avec le module <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>.</p>
</dd>
<dt id="term-annotation">annotation<a class="headerlink" href="#term-annotation" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Étiquette associée à une variable, un attribut de classe, un paramètre de fonction ou une valeur de retour. Elle est utilisée par convention comme <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hint</span></a>.</p>
<p>Les annotations de variables locales ne sont pas accessibles au moment de l'exécution, mais les annotations de variables globales, d'attributs de classe et de fonctions sont stockées dans l'attribut spécial <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> des modules, classes et fonctions, respectivement.</p>
<p>Voir <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">annotation de variable</span></a>, <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">annotation de fonction</span></a>, les <span class="target" id="index-70"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> et <span class="target" id="index-71"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>, qui décrivent cette fonctionnalité. Voir aussi <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Bonnes pratiques concernant les annotations</span></a> sur les bonnes pratiques concernant les annotations.</p>
</dd>
<dt id="term-argument">argument<a class="headerlink" href="#term-argument" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Valeur, donnée à une <a class="reference internal" href="#term-function"><span class="xref std std-term">fonction</span></a> ou à une <a class="reference internal" href="#term-method"><span class="xref std std-term">méthode</span></a> lors de son appel. Il existe deux types d'arguments :</p>
<ul>
<li><p><em class="dfn">argument nommé</em> : un argument précédé d'un identifiant (comme <code class="docutils literal notranslate"><span class="pre">name=</span></code>) ou un dictionnaire précédé de <code class="docutils literal notranslate"><span class="pre">**</span></code>, lors d'un appel de fonction. Par exemple, <code class="docutils literal notranslate"><span class="pre">3</span></code> et <code class="docutils literal notranslate"><span class="pre">5</span></code> sont tous les deux des arguments nommés dans l'appel à <a class="reference internal" href="library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> ici :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="n">real</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;real&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">argument positionnel</em> : un argument qui n'est pas nommé. Les arguments positionnels apparaissent au début de la liste des arguments, ou donnés sous forme d'un <a class="reference internal" href="#term-iterable"><span class="xref std std-term">itérable</span></a> précédé par <code class="docutils literal notranslate"><span class="pre">*</span></code>. Par exemple, <code class="docutils literal notranslate"><span class="pre">3</span></code> et <code class="docutils literal notranslate"><span class="pre">5</span></code> sont tous les deux des arguments positionnels dans les appels suivants :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<p>Les arguments se retrouvent dans le corps de la fonction appelée parmi les variables locales. Voir la section <a class="reference internal" href="reference/expressions.html#calls"><span class="std std-ref">Appels</span></a> à propos des règles dictant cette affectation. Syntaxiquement, toute expression est acceptée comme argument, et c'est la valeur résultante de l'expression qui sera affectée à la variable locale.</p>
<p>Voir aussi <a class="reference internal" href="#term-parameter"><span class="xref std std-term">paramètre</span></a> dans le glossaire, la question <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">Différence entre argument et paramètre</span></a> de la FAQ et la <span class="target" id="index-72"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>.</p>
</dd>
<dt id="term-asynchronous-context-manager">gestionnaire de contexte asynchrone<a class="headerlink" href="#term-asynchronous-context-manager" title="Lien permanent vers ce terme">¶</a></dt><dd><p>An object which controls the environment seen in an
<a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> statement by defining <a class="reference internal" href="reference/datamodel.html#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> and
<a class="reference internal" href="reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a> methods.  Introduced by <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-asynchronous-generator">générateur asynchrone<a class="headerlink" href="#term-asynchronous-generator" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Fonction qui renvoie un <a class="reference internal" href="#term-asynchronous-generator-iterator"><span class="xref std std-term">itérateur de générateur asynchrone</span></a>. Cela ressemble à une coroutine définie par <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>, sauf qu'elle contient une ou des expressions <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> produisant ainsi uns série de valeurs utilisables dans une boucle <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
<p>Générateur asynchrone fait généralement référence à une fonction, mais peut faire référence à un <em>itérateur de générateur asynchrone</em> dans certains contextes. Dans les cas où le sens voulu n'est pas clair, utiliser l'ensemble des termes lève l’ambiguïté.</p>
<p>Un générateur asynchrone peut contenir des expressions <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> ainsi que des instructions <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>, et <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>.</p>
</dd>
<dt id="term-asynchronous-generator-iterator">itérateur de générateur asynchrone<a class="headerlink" href="#term-asynchronous-generator-iterator" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Objet créé par un <a class="reference internal" href="#term-asynchronous-generator"><span class="xref std std-term">générateur asynchrone</span></a>.</p>
<p>This is an <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> which when called using the
<a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> method returns an awaitable object which will execute
the body of the asynchronous generator function until the next
<a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> expression.</p>
<p>Each <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> temporarily suspends processing, remembering the
location execution state (including local variables and pending
try-statements).  When the <em>asynchronous generator iterator</em> effectively
resumes with another awaitable returned by <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>, it
picks up where it left off.  See <span class="target" id="index-4"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> and <span class="target" id="index-5"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a>.</p>
</dd>
<dt id="term-asynchronous-iterable">itérable asynchrone<a class="headerlink" href="#term-asynchronous-iterable" title="Lien permanent vers ce terme">¶</a></dt><dd><p>An object, that can be used in an <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> statement.
Must return an <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> from its
<a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> method.  Introduced by <span class="target" id="index-6"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-asynchronous-iterator">itérateur asynchrone<a class="headerlink" href="#term-asynchronous-iterator" title="Lien permanent vers ce terme">¶</a></dt><dd><p>An object that implements the <a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> and <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>
methods.  <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> must return an <a class="reference internal" href="#term-awaitable"><span class="xref std std-term">awaitable</span></a> object.
<a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> resolves the awaitables returned by an asynchronous
iterator's <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> method until it raises a
<a class="reference internal" href="library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> exception.  Introduced by <span class="target" id="index-7"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-attribute">attribut<a class="headerlink" href="#term-attribute" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Valeur associée à un objet et habituellement désignée par son nom <em>via</em> une notation utilisant des points. Par exemple, si un objet <em>o</em> possède un attribut <em>a</em>, cet attribut est référencé par <em>o.a</em>.</p>
<p>Il est possible de donner à un objet un attribut dont le nom n'est pas un identifiant tel que défini pour les <a class="reference internal" href="reference/lexical_analysis.html#identifiers"><span class="std std-ref">Identifiants et mots-clés</span></a>, par exemple en utilisant <a class="reference internal" href="library/functions.html#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a>, si l'objet le permet. Un tel attribut ne sera pas accessible à l'aide d'une expression pointée et on devra y accéder avec <a class="reference internal" href="library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a>.</p>
</dd>
<dt id="term-awaitable">attendable (<em>awaitable</em>)<a class="headerlink" href="#term-awaitable" title="Lien permanent vers ce terme">¶</a></dt><dd><p>An object that can be used in an <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> expression.  Can be
a <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">coroutine</span></a> or an object with an <a class="reference internal" href="reference/datamodel.html#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> method.
See also <span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-BDFL">BDFL<a class="headerlink" href="#term-BDFL" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Dictateur bienveillant à vie (<em>Benevolent Dictator For Life</em> en anglais). Pseudonyme de <a class="reference external" href="https://gvanrossum.github.io/">Guido van Rossum</a>, le créateur de Python.</p>
</dd>
<dt id="term-binary-file">fichier binaire<a class="headerlink" href="#term-binary-file" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Un <a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a> capable de lire et d'écrire des <a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>. Des fichiers binaires sont, par exemple, les fichiers ouverts en mode binaire (<code class="docutils literal notranslate"><span class="pre">'rb'</span></code>, <code class="docutils literal notranslate"><span class="pre">'wb'</span></code>, ou <code class="docutils literal notranslate"><span class="pre">'rb+'</span></code>), <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin.buffer</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout.buffer</span></code>, les instances de <a class="reference internal" href="library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> ou de <a class="reference internal" href="library/gzip.html#gzip.GzipFile" title="gzip.GzipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">gzip.GzipFile</span></code></a>.</p>
<p>Consultez <a class="reference internal" href="#term-text-file"><span class="xref std std-term">fichier texte</span></a>, un objet fichier capable de lire et d'écrire des objets <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
</dd>
<dt id="term-borrowed-reference">référence empruntée<a class="headerlink" href="#term-borrowed-reference" title="Lien permanent vers ce terme">¶</a></dt><dd><p>In Python's C API, a borrowed reference is a reference to an object,
where the code using the object does not own the reference.
It becomes a dangling
pointer if the object is destroyed. For example, a garbage collection can
remove the last <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">strong reference</span></a> to the object and so destroy it.</p>
<p>Il est recommandé d'appeler <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> sur la <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">référence empruntée</span></a>, ce qui la transforme <em>in situ</em> en une <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">référence forte</span></a>. Vous pouvez faire une exception si vous êtes certain que l'objet ne peut pas être supprimé avant la dernière utilisation de la référence empruntée. Voir aussi la fonction <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a>, qui crée une nouvelle <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">référence forte</span></a>.</p>
</dd>
<dt id="term-bytes-like-object">objet octet-compatible<a class="headerlink" href="#term-bytes-like-object" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Un objet gérant le <a class="reference internal" href="c-api/buffer.html#bufferobjects"><span class="std std-ref">protocole tampon</span></a> et pouvant exporter un tampon (<em>buffer</em> en anglais) C-<a class="reference internal" href="#term-contiguous"><span class="xref std std-term">contigu</span></a>. Cela inclut les objets <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> et <a class="reference internal" href="library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a>, ainsi que beaucoup d'objets <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>. Les objets octets-compatibles peuvent être utilisés pour diverses opérations sur des données binaires, comme la compression, la sauvegarde dans un fichier binaire ou l'envoi sur le réseau.</p>
<p>Certaines opérations nécessitent de travailler sur des données binaires variables. La documentation parle de ceux-ci comme des <em>read-write bytes-like objects</em>. Par exemple, <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> ou une <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> d'un <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> en font partie. D'autres opérations nécessitent de travailler sur des données binaires stockées dans des objets immuables (« <em>objets octets-compatibles en lecture seule</em> »), par exemple des <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> ou des <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> d'un objet <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
<dt id="term-bytecode">code intermédiaire (<em>bytecode</em>)<a class="headerlink" href="#term-bytecode" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Le code source, en Python, est compilé en un code intermédiaire (<em>bytecode</em> en anglais), la représentation interne à CPython d'un programme Python. Le code intermédiaire est mis en cache dans un fichier <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> de manière à ce qu'une seconde exécution soit plus rapide (la compilation en code intermédiaire a déjà été faite). On dit que ce <em>langage intermédiaire</em> est exécuté sur une <a class="reference internal" href="#term-virtual-machine"><span class="xref std std-term">virtual machine</span></a> qui exécute des instructions machine pour chaque instruction du code intermédiaire. Notez que le code intermédiaire n'a pas vocation à fonctionner sur différentes machines virtuelles Python ou à être stable entre différentes versions de Python.</p>
<p>La documentation du <a class="reference internal" href="library/dis.html#bytecodes"><span class="std std-ref">module dis</span></a> fournit une liste des instructions du code intermédiaire.</p>
</dd>
<dt id="term-callable">appelable (<em>callable</em>)<a class="headerlink" href="#term-callable" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Un appelable est un objet qui peut être appelé, éventuellement avec un ensemble d'arguments (voir  <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>), avec la syntaxe suivante :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">callable</span><span class="p">(</span><span class="n">argument1</span><span class="p">,</span> <span class="n">argument2</span><span class="p">,</span> <span class="n">argumentN</span><span class="p">)</span>
</pre></div>
</div>
<p>Une <a class="reference internal" href="#term-function"><span class="xref std std-term">fonction</span></a>, et par extension une <a class="reference internal" href="#term-method"><span class="xref std std-term">méthode</span></a>, est un appelable. Une instance d'une classe qui implémente la méthode <a class="reference internal" href="reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> est également un appelable.</p>
</dd>
<dt id="term-callback">fonction de rappel (<em>callback</em>)<a class="headerlink" href="#term-callback" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Une fonction (classique, par opposition à une coroutine) passée en argument pour être exécutée plus tard.</p>
</dd>
<dt id="term-class">classe<a class="headerlink" href="#term-class" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Modèle pour créer des objets définis par l'utilisateur. Une définition de classe (<em>class</em>) contient normalement des définitions de méthodes qui agissent sur les instances de la classe.</p>
</dd>
<dt id="term-class-variable">variable de classe<a class="headerlink" href="#term-class-variable" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Une variable définie dans une classe et destinée à être modifiée uniquement au niveau de la classe (c'est-à-dire, pas dans une instance de la classe).</p>
</dd>
<dt id="term-complex-number">nombre complexe<a class="headerlink" href="#term-complex-number" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Extension des nombres réels familiers, dans laquelle tous les nombres sont exprimés sous la forme d'une somme d'une partie réelle et d'une partie imaginaire. Les nombres imaginaires sont les nombres réels multipliés par l'unité imaginaire (la racine carrée de <code class="docutils literal notranslate"><span class="pre">-1</span></code>, souvent écrite <code class="docutils literal notranslate"><span class="pre">i</span></code> en mathématiques ou <code class="docutils literal notranslate"><span class="pre">j</span></code> par les ingénieurs). Python comprend nativement les nombres complexes, écrits avec cette dernière notation : la partie imaginaire est écrite avec un suffixe <code class="docutils literal notranslate"><span class="pre">j</span></code>, exemple, <code class="docutils literal notranslate"><span class="pre">3+1j</span></code>. Pour utiliser les équivalents complexes de <a class="reference internal" href="library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a>, utilisez <a class="reference internal" href="library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a>. Les nombres complexes sont un concept assez avancé en mathématiques. Si vous ne connaissez pas ce concept, vous pouvez tranquillement les ignorer.</p>
</dd>
<dt id="term-context-manager">gestionnaire de contexte<a class="headerlink" href="#term-context-manager" title="Lien permanent vers ce terme">¶</a></dt><dd><p>An object which controls the environment seen in a <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>
statement by defining <a class="reference internal" href="reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> and <a class="reference internal" href="reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> methods.
See <span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a>.</p>
</dd>
<dt id="term-context-variable">variable de contexte<a class="headerlink" href="#term-context-variable" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Une variable qui peut avoir des valeurs différentes en fonction de son contexte. Cela est similaire au stockage par fil d’exécution (<em>Thread Local Storage</em> en anglais) dans lequel chaque fil d’exécution peut avoir une valeur différente pour une variable. Toutefois, avec les variables de contexte, il peut y avoir plusieurs contextes dans un fil d’exécution et l’utilisation principale pour les variables de contexte est de garder une trace des variables dans les tâches asynchrones concourantes. Voir <a class="reference internal" href="library/contextvars.html#module-contextvars" title="contextvars: Context Variables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>.</p>
</dd>
<dt id="term-contiguous">contigu<a class="headerlink" href="#term-contiguous" title="Lien permanent vers ce terme">¶</a></dt><dd><p id="index-10">Un tampon (<em>buffer</em> en anglais) est considéré comme contigu s’il est soit <em>C-contigu</em> soit <em>Fortran-contigu</em>. Les tampons de dimension zéro sont C-contigus et Fortran-contigus. Pour un tableau à une dimension, ses éléments doivent être placés en mémoire l’un à côté de l’autre, dans l’ordre croissant de leur indice, en commençant à zéro. Pour qu’un tableau multidimensionnel soit C-contigu, le dernier indice doit être celui qui varie le plus rapidement lors du parcours de ses éléments dans l’ordre de leur adresse mémoire. À l'inverse, dans les tableaux Fortran-contigu, c’est le premier indice qui doit varier le plus rapidement.</p>
</dd>
<dt id="term-coroutine">coroutine<a class="headerlink" href="#term-coroutine" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Les coroutines sont une forme généralisée des fonctions. On entre dans une fonction en un point et on en sort en un autre point. On peut entrer, sortir et reprendre l'exécution d'une coroutine en plusieurs points. Elles peuvent être implémentées en utilisant l'instruction <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>. Voir aussi la <span class="target" id="index-73"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-coroutine-function">fonction coroutine<a class="headerlink" href="#term-coroutine-function" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Fonction qui renvoie un objet <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">coroutine</span></a>. Une fonction coroutine peut être définie par l'instruction <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> et peut contenir les mots clés <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> ainsi que <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>. A été introduit par la <span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-CPython">CPython<a class="headerlink" href="#term-CPython" title="Lien permanent vers ce terme">¶</a></dt><dd><p>L'implémentation canonique du langage de programmation Python, tel que distribué sur <a class="reference external" href="https://www.python.org">python.org</a>. Le terme &quot;CPython&quot; est utilisé dans certains contextes lorsqu'il est nécessaire de distinguer cette implémentation des autres comme <em>Jython</em> ou <em>IronPython</em>.</p>
</dd>
<dt id="term-decorator">décorateur<a class="headerlink" href="#term-decorator" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Fonction dont la valeur de retour est une autre fonction. Un décorateur est habituellement utilisé pour transformer une fonction via la syntaxe <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code>, dont les exemples typiques sont : <a class="reference internal" href="library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> et <a class="reference internal" href="library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>.</p>
<p>La syntaxe des décorateurs est simplement du sucre syntaxique, les définitions des deux fonctions suivantes sont sémantiquement équivalentes :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Quoique moins fréquemment utilisé, le même concept existe pour les classes. Consultez la documentation <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">définitions de fonctions</span></a> et <a class="reference internal" href="reference/compound_stmts.html#class"><span class="std std-ref">définitions de classes</span></a> pour en savoir plus sur les décorateurs.</p>
</dd>
<dt id="term-descriptor">descripteur<a class="headerlink" href="#term-descriptor" title="Lien permanent vers ce terme">¶</a></dt><dd><p>N'importe quel objet définissant les méthodes <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code>, ou <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>. Lorsque l'attribut d'une classe est un descripteur, son comportement spécial est déclenché lors de la recherche des attributs. Normalement, lorsque vous écrivez <em>a.b</em> pour obtenir, affecter ou effacer un attribut, Python recherche l'objet nommé <em>b</em> dans le dictionnaire de la classe de <em>a</em>. Mais si <em>b</em> est un descripteur, c'est la méthode de ce descripteur qui est alors appelée. Comprendre les descripteurs est requis pour avoir une compréhension approfondie de Python, ils sont la base de nombre de ses caractéristiques notamment les fonctions, méthodes, propriétés, méthodes de classes, méthodes statiques et les références aux classes parentes.</p>
<p>Pour plus d'informations sur les méthodes des descripteurs, consultez <a class="reference internal" href="reference/datamodel.html#descriptors"><span class="std std-ref">Implémentation de descripteurs</span></a> ou le <a class="reference internal" href="howto/descriptor.html#descriptorhowto"><span class="std std-ref">guide pour l'utilisation des descripteurs</span></a>.</p>
</dd>
<dt id="term-dictionary">dictionnaire<a class="headerlink" href="#term-dictionary" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Structure de donnée associant des clés à des valeurs. Les clés peuvent être n'importe quel objet possédant les méthodes <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> et <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code>. En Perl, les dictionnaires sont appelés &quot;<em>hash</em>&quot;.</p>
</dd>
<dt id="term-dictionary-comprehension">dictionnaire en compréhension (ou dictionnaire en intension)<a class="headerlink" href="#term-dictionary-comprehension" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Écriture concise pour traiter tout ou partie des éléments d'un itérable et renvoyer un dictionnaire contenant les résultats. <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{n:</span> <span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span> <span class="pre">for</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">range(10)}</span></code> génère un dictionnaire contenant des clés <code class="docutils literal notranslate"><span class="pre">n</span></code> liées à leurs valeurs <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span></code>. Voir <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">compréhensions</span></a>.</p>
</dd>
<dt id="term-dictionary-view">vue de dictionnaire<a class="headerlink" href="#term-dictionary-view" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Objets retournés par les méthodes <a class="reference internal" href="library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a> et <a class="reference internal" href="library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a>. Ils fournissent des vues dynamiques des entrées du dictionnaire, ce qui signifie que lorsque le dictionnaire change, la vue change. Pour transformer une vue en vraie liste, utilisez <code class="docutils literal notranslate"><span class="pre">list(dictview)</span></code>. Voir <a class="reference internal" href="library/stdtypes.html#dict-views"><span class="std std-ref">Les vues de dictionnaires</span></a>.</p>
</dd>
<dt id="term-docstring">chaîne de documentation (<em>docstring</em>)<a class="headerlink" href="#term-docstring" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Première chaîne littérale qui apparaît dans l'expression d'une classe, fonction, ou module. Bien qu'ignorée à l'exécution, elle est reconnue par le compilateur et placée dans l'attribut <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> de la classe, de la fonction ou du module. Comme cette chaîne est disponible par introspection, c'est l'endroit idéal pour documenter l'objet.</p>
</dd>
<dt id="term-duck-typing">typage canard (<em>duck-typing</em>)<a class="headerlink" href="#term-duck-typing" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Style de programmation qui ne prend pas en compte le type d'un objet pour déterminer s'il respecte une interface, mais qui appelle simplement la méthode ou l'attribut (<em>Si ça a un bec et que ça cancane, ça doit être un canard</em>, <em>duck</em> signifie canard en anglais). En se concentrant sur les interfaces plutôt que les types, du code bien construit améliore sa flexibilité en autorisant des substitutions polymorphiques. Le <em>duck-typing</em> évite de vérifier les types via <a class="reference internal" href="library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> ou <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>, Notez cependant que le <em>duck-typing</em> peut travailler de pair avec les <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">classes mère abstraites</span></a>. À la place, le <em>duck-typing</em> utilise plutôt <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> ou la programmation <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a>.</p>
</dd>
<dt id="term-EAFP">EAFP<a class="headerlink" href="#term-EAFP" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Il est plus simple de demander pardon que demander la permission (<em>Easier to Ask for Forgiveness than Permission</em> en anglais). Ce style de développement Python fait l'hypothèse que le code est valide et traite les exceptions si cette hypothèse s'avère fausse. Ce style, propre et efficace, est caractérisé par la présence de beaucoup de mots clés <a class="reference internal" href="reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> et <a class="reference internal" href="reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>. Cette technique de programmation contraste avec le style <a class="reference internal" href="#term-LBYL"><span class="xref std std-term">LBYL</span></a> utilisé couramment dans les langages tels que C.</p>
</dd>
<dt id="term-expression">expression<a class="headerlink" href="#term-expression" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Suite logique de termes et chiffres conformes à la syntaxe Python dont l'évaluation fournit une valeur. En d'autres termes, une expression est une suite d'éléments tels que des noms, opérateurs, littéraux, accès d'attributs, méthodes ou fonctions qui aboutissent à une valeur. Contrairement à beaucoup d'autres langages, les différentes constructions du langage ne sont pas toutes des expressions. On trouve également des <a class="reference internal" href="#term-statement"><span class="xref std std-term">instructions</span></a> qui ne peuvent pas être utilisées comme expressions, tel que <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a>. Les affectations sont également des instructions et non des expressions.</p>
</dd>
<dt id="term-extension-module">module d'extension<a class="headerlink" href="#term-extension-module" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Module écrit en C ou C++, utilisant l'API C de Python pour interagir avec Python et le code de l'utilisateur.</p>
</dd>
<dt id="term-f-string">f-string<a class="headerlink" href="#term-f-string" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Chaîne littérale préfixée de <code class="docutils literal notranslate"><span class="pre">'f'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'F'</span></code>. Les &quot;f-strings&quot; sont un raccourci pour <a class="reference internal" href="reference/lexical_analysis.html#f-strings"><span class="std std-ref">formatted string literals</span></a>. Voir la <span class="target" id="index-75"></span><a class="pep reference external" href="https://peps.python.org/pep-0498/"><strong>PEP 498</strong></a>.</p>
</dd>
<dt id="term-file-object">objet fichier<a class="headerlink" href="#term-file-object" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Objet exposant une ressource via une API orientée fichier (avec les méthodes <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> ou <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>). En fonction de la manière dont il a été créé, un objet fichier peut interfacer l'accès à un fichier sur le disque ou à un autre type de stockage ou de communication (typiquement l'entrée standard, la sortie standard, un tampon en mémoire, un connecteur réseau…). Les objets fichiers sont aussi appelés <em class="dfn">file-like-objects</em> ou <em class="dfn">streams</em>.</p>
<p>Il existe en réalité trois catégories de fichiers objets : les <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">fichiers binaires</span></a> bruts, les <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">fichiers binaires</span></a> avec tampon (<em>buffer</em>) et les <a class="reference internal" href="#term-text-file"><span class="xref std std-term">fichiers textes</span></a>. Leurs interfaces sont définies dans le module <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>. Le moyen le plus simple et direct de créer un objet fichier est d'utiliser la fonction <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
</dd>
<dt id="term-file-like-object">objet fichier-compatible<a class="headerlink" href="#term-file-like-object" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Synonyme de <a class="reference internal" href="#term-file-object"><span class="xref std std-term">objet fichier</span></a>.</p>
</dd>
<dt id="term-filesystem-encoding-and-error-handler">encodage du système de fichiers et gestionnaire d'erreurs associé<a class="headerlink" href="#term-filesystem-encoding-and-error-handler" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Encodage et gestionnaire d'erreurs utilisés par Python pour décoder les octets fournis par le système d'exploitation et encoder les chaînes de caractères Unicode afin de les passer au système.</p>
<p>L'encodage du système de fichiers doit impérativement pouvoir décoder tous les octets jusqu'à 128. Si ce n'est pas le cas, certaines fonctions de l'API lèvent <a class="reference internal" href="library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>.</p>
<p>Cet encodage et son gestionnaire d'erreur peuvent être obtenus à l'aide des fonctions <a class="reference internal" href="library/sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a> et <a class="reference internal" href="library/sys.html#sys.getfilesystemencodeerrors" title="sys.getfilesystemencodeerrors"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencodeerrors()</span></code></a>.</p>
<p>L'<a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">encodage du système de fichiers et gestionnaire d'erreurs associé</span></a> sont configurés au démarrage de Python par la fonction <a class="reference internal" href="c-api/init_config.html#c.PyConfig_Read" title="PyConfig_Read"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Read()</span></code></a> : regardez <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_encoding" title="PyConfig.filesystem_encoding"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_encoding</span></code></a> et <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_errors" title="PyConfig.filesystem_errors"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_errors</span></code></a> dans les membres de <a class="reference internal" href="c-api/init_config.html#c.PyConfig" title="PyConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyConfig</span></code></a>.</p>
<p>Voir aussi <a class="reference internal" href="#term-locale-encoding"><span class="xref std std-term">encodage régional</span></a>.</p>
</dd>
<dt id="term-finder">chercheur<a class="headerlink" href="#term-finder" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Objet qui essaie de trouver un <a class="reference internal" href="#term-loader"><span class="xref std std-term">chargeur</span></a> pour le module en cours d'importation.</p>
<p>Depuis Python 3.3, il existe deux types de chercheurs : les <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">chercheurs dans les méta-chemins</span></a> à utiliser avec <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> ; les <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">chercheurs d'entrée dans path</span></a> à utiliser avec <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>.</p>
<p>Voir les <span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>, <span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> et <span class="target" id="index-78"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a> pour plus de détails.</p>
</dd>
<dt id="term-floor-division">division entière<a class="headerlink" href="#term-floor-division" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Division mathématique arrondissant à l'entier inférieur. L'opérateur de la division entière est <code class="docutils literal notranslate"><span class="pre">//</span></code>. Par exemple l'expression <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">//</span> <span class="pre">4</span></code> vaut <code class="docutils literal notranslate"><span class="pre">2</span></code>, contrairement à <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">/</span> <span class="pre">4</span></code> qui vaut <code class="docutils literal notranslate"><span class="pre">2.75</span></code>. Notez que <code class="docutils literal notranslate"><span class="pre">(-11)</span> <span class="pre">//</span> <span class="pre">4</span></code> vaut <code class="docutils literal notranslate"><span class="pre">-3</span></code> car l'arrondi se fait à l'entier inférieur. Voir la <span class="target" id="index-79"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a>.</p>
</dd>
<dt id="term-function">fonction<a class="headerlink" href="#term-function" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Suite d'instructions qui renvoie une valeur à son appelant. On peut lui passer des <a class="reference internal" href="#term-argument"><span class="xref std std-term">arguments</span></a> qui pourront être utilisés dans le corps de la fonction. Voir aussi <a class="reference internal" href="#term-parameter"><span class="xref std std-term">paramètre</span></a>, <a class="reference internal" href="#term-method"><span class="xref std std-term">méthode</span></a> et <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Définition de fonctions</span></a>.</p>
</dd>
<dt id="term-function-annotation">annotation de fonction<a class="headerlink" href="#term-function-annotation" title="Lien permanent vers ce terme">¶</a></dt><dd><p><a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> d'un paramètre de fonction ou valeur de retour.</p>
<p>Les annotations de fonctions sont généralement utilisées pour des <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">indications de types</span></a> : par exemple, cette fonction devrait prendre deux arguments <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> et devrait également avoir une valeur de retour de type <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_two_numbers</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
   <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>L'annotation syntaxique de la fonction est expliquée dans la section <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Définition de fonctions</span></a>.</p>
<p>Voir <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">annotation de variable</span></a> et la <span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, qui décrivent cette fonctionnalité. Voir aussi <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Bonnes pratiques concernant les annotations</span></a> sur les bonnes pratiques concernant les annotations.</p>
</dd>
<dt id="term-__future__">__future__<a class="headerlink" href="#term-__future__" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Une <a class="reference internal" href="reference/simple_stmts.html#future"><span class="std std-ref">importation depuis le futur</span></a> s'écrit <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">&lt;fonctionnalité&gt;</span></code>. Lorsqu'une importation du futur est active dans un module, Python compile ce module avec une certaine modification de la syntaxe ou du comportement qui est vouée à devenir standard dans une version ultérieure. Le module <a class="reference internal" href="library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> documente les possibilités pour <em>fonctionnalité</em>. L'importation a aussi l'effet normal d'importer une variable du module. Cette variable contient des informations utiles sur la fonctionnalité en question, notamment la version de Python dans laquelle elle a été ajoutée, et celle dans laquelle elle deviendra standard :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">__future__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__future__</span><span class="o">.</span><span class="n">division</span>
<span class="go">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>
</pre></div>
</div>
</dd>
<dt id="term-garbage-collection">ramasse-miettes<a class="headerlink" href="#term-garbage-collection" title="Lien permanent vers ce terme">¶</a></dt><dd><p>(<em>garbage collection</em> en anglais) Mécanisme permettant de libérer de la mémoire lorsqu'elle n'est plus utilisée. Python utilise un ramasse-miettes par comptage de référence et un ramasse-miettes cyclique capable de détecter et casser les références circulaires. Le ramasse-miettes peut être contrôlé en utilisant le module <a class="reference internal" href="library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a>.</p>
</dd>
<dt id="index-19"><span id="term-generator"></span>générateur<a class="headerlink" href="#index-19" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Fonction qui renvoie un <a class="reference internal" href="#term-generator-iterator"><span class="xref std std-term">itérateur de générateur</span></a>. Cela ressemble à une fonction normale, en dehors du fait qu'elle contient une ou des expressions <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> produisant une série de valeurs utilisable dans une boucle <em>for</em> ou récupérées une à une via la fonction <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>.</p>
<p>Fait généralement référence à une fonction génératrice mais peut faire référence à un <em>itérateur de générateur</em> dans certains contextes. Dans les cas où le sens voulu n'est pas clair, utiliser les termes complets lève l’ambiguïté.</p>
</dd>
<dt id="term-generator-iterator">itérateur de générateur<a class="headerlink" href="#term-generator-iterator" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Objet créé par une fonction <a class="reference internal" href="#term-generator"><span class="xref std std-term">générateur</span></a>.</p>
<p>Chaque <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> suspend temporairement l'exécution, en se rappelant l'endroit et l'état de l'exécution (y compris les variables locales et les <em>try</em> en cours). Lorsque l'itérateur de générateur reprend, il repart là où il en était (contrairement à une fonction qui prendrait un nouveau départ à chaque invocation).</p>
</dd>
<dt id="index-20"><span id="term-generator-expression"></span>expression génératrice<a class="headerlink" href="#index-20" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Expression qui donne un itérateur. Elle ressemble à une expression normale, suivie d'une clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> définissant une variable de boucle, un intervalle et une clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> optionnelle. Toute cette expression génère des valeurs pour la fonction qui l'entoure :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>         <span class="c1"># sum of squares 0, 1, 4, ... 81</span>
<span class="go">285</span>
</pre></div>
</div>
</dd>
<dt id="term-generic-function">fonction générique<a class="headerlink" href="#term-generic-function" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Fonction composée de plusieurs fonctions implémentant les mêmes opérations pour différents types. L'implémentation à utiliser est déterminée lors de l'appel par l'algorithme de répartition.</p>
<p>Voir aussi <a class="reference internal" href="#term-single-dispatch"><span class="xref std std-term">single dispatch</span></a>, le décorateur <a class="reference internal" href="library/functools.html#functools.singledispatch" title="functools.singledispatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatch()</span></code></a> et la <span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0443/"><strong>PEP 443</strong></a>.</p>
</dd>
<dt id="term-generic-type">type générique<a class="headerlink" href="#term-generic-type" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Un <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a> qui peut être paramétré ; généralement un <a class="reference internal" href="reference/datamodel.html#sequence-types"><span class="std std-ref">conteneur</span></a> comme <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> ou <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. Utilisé pour les <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">indications de type</span></a> et les <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotations</span></a>.</p>
<p>Pour plus de détails, voir <a class="reference internal" href="library/stdtypes.html#types-genericalias"><span class="std std-ref">types alias génériques</span></a> et le module <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a>.  On trouvera l'historique de cette fonctionnalité dans les <span class="target" id="index-82"></span><a class="pep reference external" href="https://peps.python.org/pep-0483/"><strong>PEP 483</strong></a>, <span class="target" id="index-83"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> et <span class="target" id="index-84"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a>.</p>
</dd>
<dt id="term-GIL">GIL<a class="headerlink" href="#term-GIL" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Voir <a class="reference internal" href="#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a>.</p>
</dd>
<dt id="term-global-interpreter-lock">verrou global de l'interpréteur<a class="headerlink" href="#term-global-interpreter-lock" title="Lien permanent vers ce terme">¶</a></dt><dd><p>(<em>global interpreter lock</em> en anglais) Mécanisme utilisé par l'interpréteur <a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> pour s'assurer qu'un seul fil d'exécution (<em>thread</em> en anglais) n'exécute le <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a> à la fois. Cela simplifie l'implémentation de CPython en rendant le modèle objet (incluant des parties critiques comme la classe native <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) implicitement protégé contre les accès concourants. Verrouiller l'interpréteur entier rend plus facile l'implémentation de multiples fils d'exécution (<em>multi-thread</em> en anglais), au détriment malheureusement de beaucoup du parallélisme possible sur les machines ayant plusieurs processeurs.</p>
<p>Cependant, certains modules d'extension, standards ou non, sont conçus de manière à libérer le GIL lorsqu'ils effectuent des tâches lourdes tel que la compression ou le hachage. De la même manière, le GIL est toujours libéré lors des entrées-sorties.</p>
<p>Les tentatives précédentes d'implémenter un interpréteur Python avec une granularité de verrouillage plus fine ont toutes échouées, à cause de leurs mauvaises performances dans le cas d'un processeur unique. Il est admis que corriger ce problème de performance induit mènerait à une implémentation beaucoup plus compliquée et donc plus coûteuse à maintenir.</p>
</dd>
<dt id="term-hash-based-pyc"><em>pyc</em> utilisant le hachage<a class="headerlink" href="#term-hash-based-pyc" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Un fichier de cache de code intermédiaire (<em>bytecode</em> en anglais) qui utilise le hachage plutôt que l'heure de dernière modification du fichier source correspondant pour déterminer sa validité. Voir <a class="reference internal" href="reference/import.html#pyc-invalidation"><span class="std std-ref">Invalidation de bytecode mis en cache</span></a>.</p>
</dd>
<dt id="term-hashable">hachable<a class="headerlink" href="#term-hashable" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Un objet est <em>hachable</em> s'il a une empreinte (<em>hash</em>) qui ne change jamais (il doit donc implémenter une méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code>) et s'il peut être comparé à d'autres objets (avec la méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code>). Les objets hachables dont la comparaison par <code class="docutils literal notranslate"><span class="pre">__eq__</span></code> est vraie doivent avoir la même empreinte.</p>
<p>La hachabilité permet à un objet d'être utilisé comme clé de dictionnaire ou en tant que membre d'un ensemble (type <em>set</em>), car ces structures de données utilisent ce <em>hash</em>.</p>
<p>La plupart des types immuables natifs de Python sont hachables, mais les conteneurs muables (comme les listes ou les dictionnaires) ne le sont pas ; les conteneurs immuables (comme les n-uplets ou les ensembles figés) ne sont hachables que si leurs éléments sont hachables. Les instances de classes définies par les utilisateurs sont hachables par défaut. Elles sont toutes considérées différentes (sauf avec elles-mêmes) et leur valeur de hachage est calculée à partir de leur <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>.</p>
</dd>
<dt id="term-IDLE">IDLE<a class="headerlink" href="#term-IDLE" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Environnement d'apprentissage et de développement intégré pour Python. <a class="reference internal" href="library/idle.html#idle"><span class="std std-ref">IDLE</span></a> est un éditeur basique et un interpréteur livré avec la distribution standard de Python.</p>
</dd>
<dt id="term-immutable">immuable<a class="headerlink" href="#term-immutable" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Objet dont la valeur ne change pas. Les nombres, les chaînes et les <em>n</em>-uplets sont immuables. Ils ne peuvent être modifiés. Un nouvel objet doit être créé si une valeur différente doit être stockée. Ils jouent un rôle important quand une valeur de <em>hash</em> constante est requise, typiquement en clé de dictionnaire.</p>
</dd>
<dt id="term-import-path">chemin des importations<a class="headerlink" href="#term-import-path" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Liste de <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">entrées</span></a> dans lesquelles le <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">chercheur basé sur les chemins</span></a> cherche les modules à importer. Typiquement, lors d'une importation, cette liste vient de <a class="reference internal" href="library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> ; pour les sous-paquets, elle peut aussi venir de l'attribut <code class="docutils literal notranslate"><span class="pre">__path__</span></code> du paquet parent.</p>
</dd>
<dt id="term-importing">importation<a class="headerlink" href="#term-importing" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Processus rendant le code Python d'un module disponible dans un autre.</p>
</dd>
<dt id="term-importer">importateur<a class="headerlink" href="#term-importer" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Objet qui trouve et charge un module, en même temps un <a class="reference internal" href="#term-finder"><span class="xref std std-term">chercheur</span></a> et un <a class="reference internal" href="#term-loader"><span class="xref std std-term">chargeur</span></a>.</p>
</dd>
<dt id="term-interactive">interactif<a class="headerlink" href="#term-interactive" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Python a un interpréteur interactif, ce qui signifie que vous pouvez écrire des expressions et des instructions à l'invite de l'interpréteur. L'interpréteur Python va les exécuter immédiatement et vous en présenter le résultat. Démarrez juste <code class="docutils literal notranslate"><span class="pre">python</span></code> (probablement depuis le menu principal de votre ordinateur). C'est un moyen puissant pour tester de nouvelles idées ou étudier de nouveaux modules (souvenez-vous de <code class="docutils literal notranslate"><span class="pre">help(x)</span></code>).</p>
</dd>
<dt id="term-interpreted">interprété<a class="headerlink" href="#term-interpreted" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Python est un langage interprété, en opposition aux langages compilés, bien que la frontière soit floue en raison de la présence d'un compilateur en code intermédiaire. Cela signifie que les fichiers sources peuvent être exécutés directement, sans avoir à compiler un fichier exécutable intermédiaire. Les langages interprétés ont généralement un cycle de développement / débogage plus court que les langages compilés. Cependant, ils s'exécutent généralement plus lentement. Voir aussi <a class="reference internal" href="#term-interactive"><span class="xref std std-term">interactif</span></a>.</p>
</dd>
<dt id="term-interpreter-shutdown">arrêt de l'interpréteur<a class="headerlink" href="#term-interpreter-shutdown" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Lorsqu'on lui demande de s'arrêter, l'interpréteur Python entre dans une phase spéciale où il libère graduellement les ressources allouées, comme les modules ou quelques structures de données internes. Il fait aussi quelques appels au <a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">ramasse-miettes</span></a>. Cela peut déclencher l'exécution de code dans des destructeurs ou des fonctions de rappels de <em>weakrefs</em>. Le code exécuté lors de l'arrêt peut rencontrer des exceptions puisque les ressources auxquelles il fait appel sont susceptibles de ne plus fonctionner, (typiquement les modules des bibliothèques ou le mécanisme de <em>warning</em>).</p>
<p>La principale raison d'arrêt de l'interpréteur est que le module <code class="docutils literal notranslate"><span class="pre">__main__</span></code> ou le script en cours d'exécution a terminé de s'exécuter.</p>
</dd>
<dt id="term-iterable">itérable<a class="headerlink" href="#term-iterable" title="Lien permanent vers ce terme">¶</a></dt><dd><p>An object capable of returning its members one at a time. Examples of
iterables include all sequence types (such as <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>,
and <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) and some non-sequence types like <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>,
<a class="reference internal" href="#term-file-object"><span class="xref std std-term">file objects</span></a>, and objects of any classes you define
with an <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> method or with a <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method
that implements <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a> semantics.</p>
<p>Les itérables peuvent être utilisés dans des boucles <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> et à beaucoup d'autres endroits où une séquence est requise (<a class="reference internal" href="library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a>, <a class="reference internal" href="library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a>…). Lorsqu'un itérable est passé comme argument à la fonction native <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a>, celle-ci fournit en retour un itérateur sur cet itérable. Cet itérateur n'est valable que pour une seule passe sur le jeu de valeurs. Lors de l'utilisation d'itérables, il n'est habituellement pas nécessaire d'appeler <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> ou de s'occuper soi-même des objets itérateurs. L'instruction <code class="docutils literal notranslate"><span class="pre">for</span></code> le fait automatiquement pour vous, créant une variable temporaire anonyme pour garder l'itérateur durant la boucle. Voir aussi <a class="reference internal" href="#term-iterator"><span class="xref std std-term">itérateur</span></a>, <a class="reference internal" href="#term-sequence"><span class="xref std std-term">séquence</span></a> et <a class="reference internal" href="#term-generator"><span class="xref std std-term">générateur</span></a>.</p>
</dd>
<dt id="term-iterator">itérateur<a class="headerlink" href="#term-iterator" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Objet représentant un flux de donnée. Des appels successifs à la méthode <a class="reference internal" href="library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> de l'itérateur (ou le passer à la fonction native <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>) donne successivement les objets du flux. Lorsque plus aucune donnée n'est disponible, une exception <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> est levée. À ce point, l'itérateur est épuisé et tous les appels suivants à sa méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> lèveront encore une exception <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>. Les itérateurs doivent avoir une méthode <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> qui renvoie l'objet itérateur lui-même, de façon à ce que chaque itérateur soit aussi itérable et puisse être utilisé dans la plupart des endroits où d'autres itérables sont attendus. Une exception notable est un code qui tente plusieurs itérations complètes. Un objet conteneur, (tel que <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>) produit un nouvel itérateur neuf à chaque fois qu'il est passé à la fonction <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> ou s'il est utilisé dans une boucle <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>. Faire ceci sur un itérateur donnerait simplement le même objet itérateur épuisé utilisé dans son itération précédente, le faisant ressembler à un conteneur vide.</p>
<p>Vous trouverez davantage d'informations dans <a class="reference internal" href="library/stdtypes.html#typeiter"><span class="std std-ref">Les types itérateurs</span></a>.</p>
<div class="impl-detail compound">
<p><strong>Particularité de l'implémentation CPython :</strong> CPython n'est pas toujours cohérent sur le fait de demander ou non à un itérateur de définir <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code>.</p>
</div>
</dd>
<dt id="term-key-function">fonction clé<a class="headerlink" href="#term-key-function" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Une fonction clé est un objet appelable qui renvoie une valeur à fins de tri ou de classement. Par exemple, la fonction <a class="reference internal" href="library/locale.html#locale.strxfrm" title="locale.strxfrm"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.strxfrm()</span></code></a> est utilisée pour générer une clé de classement prenant en compte les conventions de classement spécifiques aux paramètres régionaux courants.</p>
<p>Plusieurs outils dans Python acceptent des fonctions clés pour déterminer comment les éléments sont classés ou groupés. On peut citer les fonctions <a class="reference internal" href="library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.merge" title="heapq.merge"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.merge()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nsmallest" title="heapq.nsmallest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nsmallest()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nlargest" title="heapq.nlargest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nlargest()</span></code></a> et <a class="reference internal" href="library/itertools.html#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code></a>.</p>
<p>Il existe plusieurs moyens de créer une fonction clé. Par exemple, la méthode <a class="reference internal" href="library/stdtypes.html#str.lower" title="str.lower"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.lower()</span></code></a> peut servir de fonction clé pour effectuer des recherches insensibles à la casse. Aussi, il est possible de créer des fonctions clés avec des expressions <a class="reference internal" href="reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a>, comme <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">r:</span> <span class="pre">(r[0],</span> <span class="pre">r[2])</span></code>. Par ailleurs <a class="reference internal" href="library/operator.html#operator.attrgetter" title="operator.attrgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">attrgetter()</span></code></a>, <a class="reference internal" href="library/operator.html#operator.itemgetter" title="operator.itemgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">itemgetter()</span></code></a> et <a class="reference internal" href="library/operator.html#operator.methodcaller" title="operator.methodcaller"><code class="xref py py-func docutils literal notranslate"><span class="pre">methodcaller()</span></code></a> permettent de créer des fonctions clés. Voir <a class="reference internal" href="howto/sorting.html#sortinghowto"><span class="std std-ref">le guide pour le tri</span></a> pour des exemples de création et d'utilisation de fonctions clefs.</p>
</dd>
<dt id="term-keyword-argument">argument nommé<a class="headerlink" href="#term-keyword-argument" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Voir <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>.</p>
</dd>
<dt id="term-lambda">lambda<a class="headerlink" href="#term-lambda" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Fonction anonyme sous la forme d'une <a class="reference internal" href="#term-expression"><span class="xref std std-term">expression</span></a> et ne contenant qu'une seule expression, exécutée lorsque la fonction est appelée. La syntaxe pour créer des fonctions lambda est : <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">[parameters]:</span> <span class="pre">expression</span></code></p>
</dd>
<dt id="term-LBYL">LBYL<a class="headerlink" href="#term-LBYL" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Regarde avant de sauter, (<em>Look before you leap</em> en anglais). Ce style de programmation consiste à vérifier des conditions avant d'effectuer des appels ou des accès. Ce style contraste avec le style <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a> et se caractérise par la présence de beaucoup d'instructions <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>.</p>
<p>Dans un environnement avec plusieurs fils d'exécution (<em>multi-threaded</em> en anglais), le style <em>LBYL</em> peut engendrer un séquencement critique (<em>race condition</em> en anglais) entre le &quot;regarde&quot; et le &quot;sauter&quot;. Par exemple, le code <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">mapping:</span> <span class="pre">return</span> <span class="pre">mapping[key]</span></code> peut échouer si un autre fil d'exécution supprime la clé <em>key</em> du <em>mapping</em> après le test mais avant l'accès. Ce problème peut être résolu avec des verrous (<em>locks</em>) ou avec l'approche EAFP.</p>
</dd>
<dt id="term-locale-encoding">encodage régional<a class="headerlink" href="#term-locale-encoding" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Sous Unix, il est défini par la variable régionale LC_CTYPE. Il peut être modifié par <a class="reference internal" href="library/locale.html#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.setlocale(locale.LC_CTYPE,</span> <span class="pre">new_locale)</span></code></a>.</p>
<p>Sous Windows, c'est un encodage ANSI (par ex. : <code class="docutils literal notranslate"><span class="pre">&quot;cp1252&quot;</span></code>).</p>
<p>Sous Android et VxWorks, Python utilise <code class="docutils literal notranslate"><span class="pre">&quot;utf-8&quot;</span></code> comme encodage régional.</p>
<p><code class="docutils literal notranslate"><span class="pre">locale.getencoding()</span></code> permet de récupérer l'encodage régional.</p>
<p>Voir aussi l'<a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">encodage du systèmes de fichiers et gestionnaire d'erreurs associé</span></a>.</p>
</dd>
<dt id="term-list">liste<a class="headerlink" href="#term-list" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Un type natif de <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a> dans Python. En dépit de son nom, une <code class="docutils literal notranslate"><span class="pre">list</span></code> ressemble plus à un tableau (<em>array</em> dans la plupart des langages) qu'à une liste chaînée puisque les accès se font en O(1).</p>
</dd>
<dt id="term-list-comprehension">liste en compréhension (ou liste en intension)<a class="headerlink" href="#term-list-comprehension" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Écriture concise pour manipuler tout ou partie des éléments d'une séquence et renvoyer une liste contenant les résultats. <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">['{:#04x}'.format(x)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(256)</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0]</span></code> génère la liste composée des nombres pairs de 0 à 255 écrits sous formes de chaînes de caractères et en hexadécimal (<code class="docutils literal notranslate"><span class="pre">0x…</span></code>). La clause <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> est optionnelle. Si elle est omise, tous les éléments du <code class="docutils literal notranslate"><span class="pre">range(256)</span></code> seront utilisés.</p>
</dd>
<dt id="term-loader">chargeur<a class="headerlink" href="#term-loader" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Objet qui charge un module. Il doit définir une méthode nommée <code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code>. Un chargeur est typiquement donné par un <a class="reference internal" href="#term-finder"><span class="xref std std-term">chercheur</span></a>. Voir la <span class="target" id="index-85"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> pour plus de détails et <code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.ABC.Loader</span></code> pour sa <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">classe mère abstraite</span></a>.</p>
</dd>
<dt id="term-magic-method">méthode magique<a class="headerlink" href="#term-magic-method" title="Lien permanent vers ce terme">¶</a></dt><dd><p id="index-26">Un synonyme informel de <a class="reference internal" href="#term-special-method"><span class="xref std std-term">special method</span></a>.</p>
</dd>
<dt id="term-mapping">tableau de correspondances (<em>mapping</em> en anglais)<a class="headerlink" href="#term-mapping" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Conteneur permettant de rechercher des éléments à partir de clés et implémentant les méthodes spécifiées dans les classes mères abstraites des <a class="reference internal" href="library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">tableaux</span> <span class="pre">de</span> <span class="pre">correspondances</span></code></a> (immuables) ou <a class="reference internal" href="library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">tableaux</span> <span class="pre">de</span> <span class="pre">correspondances</span> <span class="pre">muables</span></code></a> (voir les <a class="reference internal" href="library/collections.abc.html#collections-abstract-base-classes"><span class="std std-ref">classes mères abstraites</span></a>). Les classes suivantes sont des exemples de tableaux de correspondances : <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> et <a class="reference internal" href="library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>.</p>
</dd>
<dt id="term-meta-path-finder">chercheur dans les méta-chemins<a class="headerlink" href="#term-meta-path-finder" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Un <a class="reference internal" href="#term-finder"><span class="xref std std-term">chercheur</span></a> renvoyé par une recherche dans <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>. Les chercheurs dans les méta-chemins ressemblent, mais sont différents des <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">chercheurs d'entrée dans path</span></a>.</p>
<p>Voir <a class="reference internal" href="library/importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> pour les méthodes que les chercheurs dans les méta-chemins doivent implémenter.</p>
</dd>
<dt id="term-metaclass">métaclasse<a class="headerlink" href="#term-metaclass" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Classe d'une classe. Les définitions de classe créent un nom pour la classe, un dictionnaire de classe et une liste de classes parentes. La métaclasse a pour rôle de réunir ces trois paramètres pour construire la classe. La plupart des langages orientés objet fournissent une implémentation par défaut. La particularité de Python est la possibilité de créer des métaclasses personnalisées. La plupart des utilisateurs n'auront jamais besoin de cet outil, mais lorsque le besoin survient, les métaclasses offrent des solutions élégantes et puissantes. Elles sont utilisées pour journaliser les accès à des propriétés, rendre sûrs les environnements <em>multi-threads</em>, suivre la création d'objets, implémenter des singletons et bien d'autres tâches.</p>
<p>Plus d'informations sont disponibles dans : <a class="reference internal" href="reference/datamodel.html#metaclasses"><span class="std std-ref">Métaclasses</span></a>.</p>
</dd>
<dt id="term-method">méthode<a class="headerlink" href="#term-method" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Fonction définie à l'intérieur d'une classe. Lorsqu'elle est appelée comme un attribut d'une instance de cette classe, la méthode reçoit l'instance en premier <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a> (qui, par convention, est habituellement nommé <code class="docutils literal notranslate"><span class="pre">self</span></code>). Voir <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> et <a class="reference internal" href="#term-nested-scope"><span class="xref std std-term">nested scope</span></a>.</p>
</dd>
<dt id="term-method-resolution-order">ordre de résolution des méthodes<a class="headerlink" href="#term-method-resolution-order" title="Lien permanent vers ce terme">¶</a></dt><dd><p>L'ordre de résolution des méthodes (<em>MRO</em> pour <em>Method Resolution Order</em> en anglais) est, lors de la recherche d'un attribut dans les classes parentes, la façon dont l'interpréteur Python classe ces classes parentes. Voir <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">The Python 2.3 Method Resolution Order</a> pour plus de détails sur l'algorithme utilisé par l'interpréteur Python depuis la version 2.3.</p>
</dd>
<dt id="term-module">module<a class="headerlink" href="#term-module" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Objet utilisé pour organiser une portion unitaire de code en Python. Les modules ont un espace de nommage et peuvent contenir n'importe quels objets Python. Charger des modules est appelé <a class="reference internal" href="#term-importing"><span class="xref std std-term">importer</span></a>.</p>
<p>Voir aussi <a class="reference internal" href="#term-package"><span class="xref std std-term">paquet</span></a>.</p>
</dd>
<dt id="term-module-spec">spécificateur de module<a class="headerlink" href="#term-module-spec" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Espace de nommage contenant les informations, relatives à l'importation, utilisées pour charger un module. C'est une instance de la classe <a class="reference internal" href="library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ModuleSpec</span></code></a>.</p>
</dd>
<dt id="term-MRO">MRO<a class="headerlink" href="#term-MRO" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Voir <a class="reference internal" href="#term-method-resolution-order"><span class="xref std std-term">ordre de résolution des méthodes</span></a>.</p>
</dd>
<dt id="term-mutable">muable<a class="headerlink" href="#term-mutable" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Un objet muable peut changer de valeur tout en gardant le même <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>. Voir aussi <a class="reference internal" href="#term-immutable"><span class="xref std std-term">immuable</span></a>.</p>
</dd>
<dt id="term-named-tuple"><em>n</em>-uplet nommé<a class="headerlink" href="#term-named-tuple" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Le terme &quot;n-uplet nommé&quot; s'applique à tous les types ou classes qui héritent de la classe <code class="docutils literal notranslate"><span class="pre">tuple</span></code> et dont les éléments indexables sont aussi accessibles en utilisant des attributs nommés. Les types et classes peuvent avoir aussi d'autres caractéristiques.</p>
<p>Plusieurs types natifs sont appelés n-uplets, y compris les valeurs retournées par <a class="reference internal" href="library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> et <a class="reference internal" href="library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a>. Un autre exemple est <a class="reference internal" href="library/sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info</span></code></a> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>                   <span class="c1"># indexed access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max_exp</span>              <span class="c1"># named field access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>   <span class="c1"># kind of tuple</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Certains <em>n-uplets nommés</em> sont des types natifs (comme les exemples ci-dessus). Sinon, un <em>n-uplet nommé</em> peut être créé à partir d'une définition de classe habituelle qui hérite de <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> et qui définit les champs nommés. Une telle classe peut être écrite à la main ou être créée avec la fonction <a class="reference internal" href="library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>. Cette dernière méthode ajoute des méthodes supplémentaires qui ne seront pas trouvées dans celles écrites à la main ni dans les n-uplets nommés natifs.</p>
</dd>
<dt id="term-namespace">espace de nommage<a class="headerlink" href="#term-namespace" title="Lien permanent vers ce terme">¶</a></dt><dd><p>L'endroit où une variable est stockée. Les espaces de nommage sont implémentés avec des dictionnaires. Il existe des espaces de nommage globaux, natifs ou imbriqués dans les objets (dans les méthodes). Les espaces de nommage favorisent la modularité car ils permettent d'éviter les conflits de noms. Par exemple, les fonctions <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">builtins.open</span></code></a> et <a class="reference internal" href="library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> sont différenciées par leurs espaces de nom. Les espaces de nommage aident aussi à la lisibilité et la maintenabilité en rendant clair quel module implémente une fonction. Par exemple, écrire <a class="reference internal" href="library/random.html#random.seed" title="random.seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.seed()</span></code></a> ou <a class="reference internal" href="library/itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> affiche clairement que ces fonctions sont implémentées respectivement dans les modules <a class="reference internal" href="library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> et <a class="reference internal" href="library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a>.</p>
</dd>
<dt id="term-namespace-package">paquet-espace de nommage<a class="headerlink" href="#term-namespace-package" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Un <a class="reference internal" href="#term-package"><span class="xref std std-term">paquet</span></a> tel que défini dans la <span class="target" id="index-86"></span><a class="pep reference external" href="https://peps.python.org/pep-0421/"><strong>PEP 421</strong></a> qui ne sert qu'à contenir des sous-paquets. Les paquets-espace de nommage peuvent n'avoir aucune représentation physique et, plus spécifiquement, ne sont pas comme un <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">paquet classique</span></a> puisqu'ils n'ont pas de fichier <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>.</p>
<p>Voir aussi <a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a>.</p>
</dd>
<dt id="term-nested-scope">portée imbriquée<a class="headerlink" href="#term-nested-scope" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Possibilité de faire référence à une variable déclarée dans une définition englobante. Typiquement, une fonction définie à l'intérieur d'une autre fonction a accès aux variables de cette dernière. Souvenez-vous cependant que cela ne fonctionne que pour accéder à des variables, pas pour les assigner. Les variables locales sont lues et assignées dans l'espace de nommage le plus proche. Tout comme les variables globales qui sont stockés dans l'espace de nommage global, le mot clef <a class="reference internal" href="reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> permet d'écrire dans l'espace de nommage dans lequel est déclarée la variable.</p>
</dd>
<dt id="term-new-style-class">nouvelle classe<a class="headerlink" href="#term-new-style-class" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Ancien nom pour l'implémentation actuelle des classes, pour tous les objets. Dans les anciennes versions de Python, seules les nouvelles classes pouvaient utiliser les nouvelles fonctionnalités telles que <a class="reference internal" href="reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>, les descripteurs, les propriétés, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code>, les méthodes de classe et les méthodes statiques.</p>
</dd>
<dt id="term-object">objet<a class="headerlink" href="#term-object" title="Lien permanent vers ce terme">¶</a></dt><dd><p>N'importe quelle donnée comportant des états (sous forme d'attributs ou d'une valeur) et un comportement (des méthodes). C'est aussi (<code class="docutils literal notranslate"><span class="pre">object</span></code>) l'ancêtre commun à absolument toutes les <a class="reference internal" href="#term-new-style-class"><span class="xref std std-term">nouvelles classes</span></a>.</p>
</dd>
<dt id="term-package">paquet<a class="headerlink" href="#term-package" title="Lien permanent vers ce terme">¶</a></dt><dd><p><a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a> Python qui peut contenir des sous-modules ou des sous-paquets. Techniquement, un paquet est un module qui possède un attribut <code class="docutils literal notranslate"><span class="pre">__path__</span></code>.</p>
<p>Voir aussi <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">paquet classique</span></a> et <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">namespace package</span></a>.</p>
</dd>
<dt id="term-parameter">paramètre<a class="headerlink" href="#term-parameter" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Entité nommée dans la définition d'une <a class="reference internal" href="#term-function"><span class="xref std std-term">fonction</span></a> (ou méthode), décrivant un <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a> (ou dans certains cas des arguments) que la fonction accepte. Il existe cinq sortes de paramètres :</p>
<ul>
<li><p><em class="dfn">positional-or-keyword</em> : l'argument peut être passé soit par sa <a class="reference internal" href="#term-argument"><span class="xref std std-term">position</span></a>, soit en tant que <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument nommé</span></a>. C'est le type de paramètre par défaut. Par exemple, <em>foo</em> et <em>bar</em> dans l'exemple suivant :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="positional-only-parameter">
<li><p><em class="dfn">positional-only</em> : définit un argument qui ne peut être fourni que par position. Les paramètres <em>positional-only</em> peuvent être définis en insérant un caractère &quot;/&quot; dans la liste de paramètres de la définition de fonction après eux. Par exemple : <em>posonly1</em> et <em>posonly2</em> dans le code suivant :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">posonly1</span><span class="p">,</span> <span class="n">posonly2</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">positional_or_keyword</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="keyword-only-parameter">
<li><p><em class="dfn">keyword-only</em> : l'argument ne peut être fourni que nommé. Les paramètres <em>keyword-only</em> peuvent être définis en utilisant un seul paramètre <em>var-positional</em>, ou en ajoutant une étoile (<code class="docutils literal notranslate"><span class="pre">*</span></code>) seule dans la liste des paramètres avant eux. Par exemple, <em>kw_only1</em> et <em>kw_only2</em> dans le code suivant :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kw_only1</span><span class="p">,</span> <span class="n">kw_only2</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">var-positional</em> : une séquence d'arguments positionnels peut être fournie (en plus de tous les arguments positionnels déjà acceptés par d'autres paramètres). Un tel paramètre peut être défini en préfixant son nom par une <code class="docutils literal notranslate"><span class="pre">*</span></code>. Par exemple <em>args</em> ci-après :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">var-keyword</em> : une quantité arbitraire d'arguments peut être passée, chacun étant nommé (en plus de tous les arguments nommés déjà acceptés par d'autres paramètres). Un tel paramètre est défini en préfixant le nom du paramètre par <code class="docutils literal notranslate"><span class="pre">**</span></code>. Par exemple, <em>kwargs</em> ci-dessus.</p></li>
</ul>
<p>Les paramètres peuvent spécifier des arguments obligatoires ou optionnels, ainsi que des valeurs par défaut pour les arguments optionnels.</p>
<p>Voir aussi <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a> dans le glossaire, la question sur <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">la différence entre les arguments et les paramètres</span></a> dans la FAQ, la classe <a class="reference internal" href="library/inspect.html#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.Parameter</span></code></a>, la section <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Définition de fonctions</span></a> et la <span class="target" id="index-87"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>.</p>
</dd>
<dt id="term-path-entry">entrée de chemin<a class="headerlink" href="#term-path-entry" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Emplacement dans le <a class="reference internal" href="#term-import-path"><span class="xref std std-term">chemin des importations</span></a> (<em>import path</em> en anglais, d'où le <em>path</em>) que le <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">chercheur basé sur les chemins</span></a> consulte pour trouver des modules à importer.</p>
</dd>
<dt id="term-path-entry-finder">chercheur de chemins<a class="headerlink" href="#term-path-entry-finder" title="Lien permanent vers ce terme">¶</a></dt><dd><p><a class="reference internal" href="#term-finder"><span class="xref std std-term">chercheur</span></a> renvoyé par un appelable sur un <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> (c'est-à-dire un <a class="reference internal" href="#term-path-entry-hook"><span class="xref std std-term">point d'entrée pour la recherche dans path</span></a>) qui sait où trouver des modules lorsqu'on lui donne une <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">entrée de path</span></a>.</p>
<p>Voir <a class="reference internal" href="library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> pour les méthodes qu'un chercheur d'entrée dans <em>path</em> doit implémenter.</p>
</dd>
<dt id="term-path-entry-hook">point d'entrée pour la recherche dans <em>path</em><a class="headerlink" href="#term-path-entry-hook" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Appelable dans la liste <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hook</span></code> qui donne un <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">chercheur d'entrée dans path</span></a> s'il sait où trouver des modules pour une <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">entrée dans path</span></a> donnée.</p>
</dd>
<dt id="term-path-based-finder">chercheur basé sur les chemins<a class="headerlink" href="#term-path-based-finder" title="Lien permanent vers ce terme">¶</a></dt><dd><p>L'un des <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">chercheurs dans les méta-chemins</span></a> par défaut qui cherche des modules dans un <a class="reference internal" href="#term-import-path"><span class="xref std std-term">chemin des importations</span></a>.</p>
</dd>
<dt id="term-path-like-object">objet simili-chemin<a class="headerlink" href="#term-path-like-object" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Objet représentant un chemin du système de fichiers. Un objet simili-chemin est un objet <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou un objet <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> représentant un chemin ou un objet implémentant le protocole <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a>. Un objet qui accepte le protocole <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> peut être converti en un chemin <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> du système de fichiers en appelant la fonction <a class="reference internal" href="library/os.html#os.fspath" title="os.fspath"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fspath()</span></code></a>. <a class="reference internal" href="library/os.html#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsdecode()</span></code></a> et <a class="reference internal" href="library/os.html#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsencode()</span></code></a> peuvent être utilisées, respectivement, pour garantir un résultat de type <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> à la place. A été Introduit par la <span class="target" id="index-88"></span><a class="pep reference external" href="https://peps.python.org/pep-0519/"><strong>PEP 519</strong></a>.</p>
</dd>
<dt id="term-PEP">PEP<a class="headerlink" href="#term-PEP" title="Lien permanent vers ce terme">¶</a></dt><dd><p><em>Python Enhancement Proposal</em> (Proposition d'amélioration de Python). Une PEP est un document de conception fournissant des informations à la communauté Python ou décrivant une nouvelle fonctionnalité pour Python, ses processus ou son environnement. Les PEP doivent fournir une spécification technique concise et une justification des fonctionnalités proposées.</p>
<p>Les PEP sont censées être les principaux mécanismes pour proposer de nouvelles fonctionnalités majeures, pour recueillir les commentaires de la communauté sur une question et pour documenter les décisions de conception qui sont intégrées en Python. L’auteur du PEP est responsable de l’établissement d’un consensus au sein de la communauté et de documenter les opinions contradictoires.</p>
<p>Voir la <span class="target" id="index-89"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a>.</p>
</dd>
<dt id="term-portion">portion<a class="headerlink" href="#term-portion" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Jeu de fichiers dans un seul dossier (pouvant être stocké sous forme de fichier zip) qui contribue à l'espace de nommage d'un paquet, tel que défini dans la <span class="target" id="index-90"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>.</p>
</dd>
<dt id="term-positional-argument">argument positionnel<a class="headerlink" href="#term-positional-argument" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Voir <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>.</p>
</dd>
<dt id="term-provisional-API">API provisoire<a class="headerlink" href="#term-provisional-API" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Une API provisoire est une API qui n'offre aucune garantie de rétrocompatibilité (la bibliothèque standard exige la rétrocompatibilité). Bien que des changements majeurs d'une telle interface ne soient pas attendus, tant qu'elle est étiquetée provisoire, des changements cassant la rétrocompatibilité (y compris sa suppression complète) peuvent survenir si les développeurs principaux le jugent nécessaire. Ces modifications ne surviendront que si de sérieux problèmes sont découverts et qu'ils n'avaient pas été identifiés avant l'ajout de l'API.</p>
<p>Même pour les API provisoires, les changements cassant la rétrocompatibilité sont considérés comme des &quot;solutions de dernier recours&quot;. Tout ce qui est possible sera fait pour tenter de résoudre les problèmes en conservant la rétrocompatibilité.</p>
<p>Ce processus permet à la bibliothèque standard de continuer à évoluer avec le temps, sans se bloquer longtemps sur des erreurs d'architecture. Voir la <span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-0411/"><strong>PEP 411</strong></a> pour plus de détails.</p>
</dd>
<dt id="term-provisional-package">paquet provisoire<a class="headerlink" href="#term-provisional-package" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Voir <a class="reference internal" href="#term-provisional-API"><span class="xref std std-term">provisional API</span></a>.</p>
</dd>
<dt id="term-Python-3000">Python 3000<a class="headerlink" href="#term-Python-3000" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Surnom donné à la série des Python 3.x (très vieux surnom donné à l'époque où Python 3 représentait un futur lointain). Aussi abrégé <em>Py3k</em>.</p>
</dd>
<dt id="term-Pythonic"><em>Pythonique</em><a class="headerlink" href="#term-Pythonic" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Idée, ou bout de code, qui colle aux idiomes de Python plutôt qu'aux concepts communs rencontrés dans d'autres langages. Par exemple, il est idiomatique en Python de parcourir les éléments d'un itérable en utilisant <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>. Beaucoup d'autres langages n'ont pas cette possibilité, donc les gens qui ne sont pas habitués à Python utilisent parfois un compteur numérique à la place :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">food</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>Plutôt qu'utiliser la méthode, plus propre et élégante, donc <em>Pythonique</em> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">food</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt id="term-qualified-name">nom qualifié<a class="headerlink" href="#term-qualified-name" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Nom, comprenant des points, montrant le &quot;chemin&quot; de l'espace de nommage global d'un module vers une classe, fonction ou méthode définie dans ce module, tel que défini dans la <span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-3155/"><strong>PEP 3155</strong></a>. Pour les fonctions et classes de premier niveau, le nom qualifié est le même que le nom de l'objet :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">meth</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D.meth&#39;</span>
</pre></div>
</div>
<p>Lorsqu'il est utilisé pour nommer des modules, le <em>nom qualifié complet</em> (<em>fully qualified name - FQN</em> en anglais) signifie le chemin complet (séparé par des points) vers le module, incluant tous les paquets parents. Par exemple : <code class="docutils literal notranslate"><span class="pre">email.mime.text</span></code> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">email.mime.text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="o">.</span><span class="n">mime</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;email.mime.text&#39;</span>
</pre></div>
</div>
</dd>
<dt id="term-reference-count">nombre de références<a class="headerlink" href="#term-reference-count" title="Lien permanent vers ce terme">¶</a></dt><dd><p>The number of references to an object.  When the reference count of an
object drops to zero, it is deallocated.  Some objects are
&quot;immortal&quot; and have reference counts that are never modified, and
therefore the objects are never deallocated.  Reference counting is
generally not visible to Python code, but it is a key element of the
<a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> implementation.  Programmers can call the
<a class="reference internal" href="library/sys.html#sys.getrefcount" title="sys.getrefcount"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrefcount()</span></code></a> function to return the
reference count for a particular object.</p>
</dd>
<dt id="term-regular-package">paquet classique<a class="headerlink" href="#term-regular-package" title="Lien permanent vers ce terme">¶</a></dt><dd><p><a class="reference internal" href="#term-package"><span class="xref std std-term">paquet</span></a> traditionnel, tel qu'un dossier contenant un fichier <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>.</p>
<p>Voir aussi <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">paquet-espace de nommage</span></a>.</p>
</dd>
<dt id="term-__slots__">__slots__<a class="headerlink" href="#term-__slots__" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Déclaration dans une classe qui économise de la mémoire en pré-allouant de l'espace pour les attributs des instances et qui élimine le dictionnaire (des attributs) des instances. Bien que populaire, cette technique est difficile à maîtriser et devrait être réservée à de rares cas où un grand nombre d'instances dans une application devient un sujet critique pour la mémoire.</p>
</dd>
<dt id="term-sequence">séquence<a class="headerlink" href="#term-sequence" title="Lien permanent vers ce terme">¶</a></dt><dd><p>An <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterable</span></a> which supports efficient element access using integer
indices via the <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> special method and defines a
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> method that returns the length of the sequence.
Some built-in sequence types are <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>,
<a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, and <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Note that <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> also
supports <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code>, but is considered a
mapping rather than a sequence because the lookups use arbitrary
<a class="reference internal" href="#term-immutable"><span class="xref std std-term">immutable</span></a> keys rather than integers.</p>
<p>The <a class="reference internal" href="library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> abstract base class
defines a much richer interface that goes beyond just
<a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code>, adding <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code>, and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code>. Types that implement this expanded
interface can be registered explicitly using
<a class="reference internal" href="library/abc.html#abc.ABCMeta.register" title="abc.ABCMeta.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">register()</span></code></a>.</p>
</dd>
<dt id="term-set-comprehension">ensemble en compréhension (ou ensemble en intension)<a class="headerlink" href="#term-set-comprehension" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Une façon compacte de traiter tout ou partie des éléments d'un itérable et de renvoyer un <em>set</em> avec les résultats. <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{c</span> <span class="pre">for</span> <span class="pre">c</span> <span class="pre">in</span> <span class="pre">'abracadabra'</span> <span class="pre">if</span> <span class="pre">c</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">'abc'}</span></code> génère l'ensemble contenant les lettres « r » et « d » <code class="docutils literal notranslate"><span class="pre">{'r',</span> <span class="pre">'d'}</span></code>. Voir <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">Agencements des listes, ensembles et dictionnaires</span></a>.</p>
</dd>
<dt id="term-single-dispatch">distribution simple<a class="headerlink" href="#term-single-dispatch" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Forme de distribution, comme les <a class="reference internal" href="#term-generic-function"><span class="xref std std-term">fonction génériques</span></a>, où l'implémentation est choisie en fonction du type d'un seul argument.</p>
</dd>
<dt id="term-slice">tranche<a class="headerlink" href="#term-slice" title="Lien permanent vers ce terme">¶</a></dt><dd><p>(<em>slice</em> en anglais), un objet contenant habituellement une portion de <a class="reference internal" href="#term-sequence"><span class="xref std std-term">séquence</span></a>. Une tranche est créée en utilisant la notation <code class="docutils literal notranslate"><span class="pre">[]</span></code> avec des <code class="docutils literal notranslate"><span class="pre">:</span></code> entre les nombres lorsque plusieurs sont fournis, comme dans <code class="docutils literal notranslate"><span class="pre">variable_name[1:3:5]</span></code>. Cette notation utilise des objets <a class="reference internal" href="library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> en interne.</p>
</dd>
<dt id="term-special-method">méthode spéciale<a class="headerlink" href="#term-special-method" title="Lien permanent vers ce terme">¶</a></dt><dd><p id="index-34">(<em>special method</em> en anglais) Méthode appelée implicitement par Python pour exécuter une opération sur un type, comme une addition. De telles méthodes ont des noms commençant et terminant par des doubles tirets bas. Les méthodes spéciales sont documentées dans <a class="reference internal" href="reference/datamodel.html#specialnames"><span class="std std-ref">Méthodes spéciales</span></a>.</p>
</dd>
<dt id="term-statement">instruction<a class="headerlink" href="#term-statement" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Une instruction (<em>statement</em> en anglais) est un composant d'un &quot;bloc&quot; de code. Une instruction est soit une <a class="reference internal" href="#term-expression"><span class="xref std std-term">expression</span></a>, soit une ou plusieurs constructions basées sur un mot-clé, comme <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> ou <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>.</p>
</dd>
<dt id="term-strong-reference">référence forte<a class="headerlink" href="#term-strong-reference" title="Lien permanent vers ce terme">¶</a></dt><dd><p>In Python's C API, a strong reference is a reference to an object
which is owned by the code holding the reference.  The strong
reference is taken by calling <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> when the
reference is created and released with <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a>
when the reference is deleted.</p>
<p>Une référence forte est créée à l'aide de la fonction <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a>. Il faut normalement appeler <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> dessus avant de sortir de sa portée lexicale, sans quoi il y a une fuite de référence.</p>
<p>Voir aussi <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">référence empruntée</span></a>.</p>
</dd>
<dt id="term-text-encoding">encodages de texte<a class="headerlink" href="#term-text-encoding" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Une chaîne de caractères en Python est une suite de points de code Unicode (dans l'intervalle <code class="docutils literal notranslate"><span class="pre">U+0000</span></code>--<code class="docutils literal notranslate"><span class="pre">U+10FFFF</span></code>). Pour stocker ou transmettre une chaîne, il est nécessaire de la sérialiser en suite d'octets.</p>
<p>Sérialiser une chaîne de caractères en une suite d'octets s'appelle « encoder » et recréer la chaîne à partir de la suite d'octets s'appelle « décoder ».</p>
<p>Il existe de multiples <a class="reference internal" href="library/codecs.html#standard-encodings"><span class="std std-ref">codecs</span></a> pour la sérialisation de texte, que l'on regroupe sous l'expression « encodages de texte ».</p>
</dd>
<dt id="term-text-file">fichier texte<a class="headerlink" href="#term-text-file" title="Lien permanent vers ce terme">¶</a></dt><dd><p><a class="reference internal" href="#term-file-object"><span class="xref std std-term">Objet fichier</span></a> capable de lire et d'écrire des objets <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>. Souvent, un fichier texte (<em>text file</em> en anglais) accède en fait à un flux de donnée en octets et gère l'<a class="reference internal" href="#term-text-encoding"><span class="xref std std-term">encodage de texte</span></a> automatiquement. Des exemples de fichiers textes sont les fichiers ouverts en mode texte (<code class="docutils literal notranslate"><span class="pre">'r'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'w'</span></code>), <a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>, <a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> et les instances de <a class="reference internal" href="library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a>.</p>
<p>Voir aussi <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">fichier binaire</span></a> pour un objet fichier capable de lire et d'écrire des <a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">objets octets-compatibles</span></a>.</p>
</dd>
<dt id="term-triple-quoted-string">chaîne entre triple guillemets<a class="headerlink" href="#term-triple-quoted-string" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Chaîne qui est délimitée par trois guillemets simples (<code class="docutils literal notranslate"><span class="pre">'</span></code>) ou trois guillemets doubles (<code class="docutils literal notranslate"><span class="pre">&quot;</span></code>). Bien qu'elle ne fournisse aucune fonctionnalité qui ne soit pas disponible avec une chaîne entre guillemets, elle est utile pour de nombreuses raisons. Elle vous autorise à insérer des guillemets simples et doubles dans une chaîne sans avoir à les protéger et elle peut s'étendre sur plusieurs lignes sans avoir à terminer chaque ligne par un <code class="docutils literal notranslate"><span class="pre">\</span></code>. Elle est ainsi particulièrement utile pour les chaînes de documentation (<em>docstrings</em>).</p>
</dd>
<dt id="term-type">type<a class="headerlink" href="#term-type" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Le type d'un objet Python détermine quel genre d'objet c'est. Tous les objets ont un type. Le type d'un objet peut être obtenu via son attribut <a class="reference internal" href="library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> ou via <code class="docutils literal notranslate"><span class="pre">type(obj)</span></code>.</p>
</dd>
<dt id="term-type-alias">alias de type<a class="headerlink" href="#term-type-alias" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Synonyme d'un type, créé en affectant le type à un identifiant.</p>
<p>Les alias de types sont utiles pour simplifier les <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">indications de types</span></a>. Par exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span>
        <span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>pourrait être rendu plus lisible comme ceci :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span><span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Voir <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> et la <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, qui décrivent cette fonctionnalité.</p>
</dd>
<dt id="term-type-hint">indication de type<a class="headerlink" href="#term-type-hint" title="Lien permanent vers ce terme">¶</a></dt><dd><p>L'<a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> qui spécifie le type attendu pour une variable, un attribut de classe, un paramètre de fonction ou une valeur de retour.</p>
<p>Les indications de type sont facultatives et ne sont pas indispensables à l'interpréteur Python, mais elles sont utiles aux outils d'analyse de type statique et aident les IDE à compléter et à réusiner (<em>code refactoring</em> en anglais) le code.</p>
<p>Les indications de type de variables globales, d'attributs de classe et de fonctions, mais pas de variables locales, peuvent être consultées en utilisant <a class="reference internal" href="library/typing.html#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a>.</p>
<p>Voir <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> et la <span class="target" id="index-94"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, qui décrivent cette fonctionnalité.</p>
</dd>
<dt id="term-universal-newlines">retours à la ligne universels<a class="headerlink" href="#term-universal-newlines" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Une manière d'interpréter des flux de texte dans lesquels sont reconnues toutes les fins de ligne suivantes : la convention Unix <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, la convention Windows <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code> et l'ancienne convention Macintosh <code class="docutils literal notranslate"><span class="pre">'\r'</span></code>. Voir la <span class="target" id="index-95"></span><a class="pep reference external" href="https://peps.python.org/pep-0278/"><strong>PEP 278</strong></a> et la <span class="target" id="index-96"></span><a class="pep reference external" href="https://peps.python.org/pep-3116/"><strong>PEP 3116</strong></a>, ainsi que la fonction <a class="reference internal" href="library/stdtypes.html#bytes.splitlines" title="bytes.splitlines"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.splitlines()</span></code></a> pour d'autres usages.</p>
</dd>
<dt id="term-variable-annotation">annotation de variable<a class="headerlink" href="#term-variable-annotation" title="Lien permanent vers ce terme">¶</a></dt><dd><p><a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> d'une variable ou d'un attribut de classe.</p>
<p>Lorsque vous annotez une variable ou un attribut de classe, l'affectation est facultative :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;annotation&#39;</span>
</pre></div>
</div>
<p>Les annotations de variables sont généralement utilisées pour des <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">indications de types</span></a> : par exemple, cette variable devrait prendre des valeurs de type <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>La syntaxe d'annotation de variable est expliquée dans la section <a class="reference internal" href="reference/simple_stmts.html#annassign"><span class="std std-ref">Les assignations annotées</span></a>.</p>
<p>Reportez-vous à <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">annotation de fonction</span></a>, à la <span class="target" id="index-97"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> et à la <span class="target" id="index-98"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a> qui décrivent cette fonctionnalité. Voir aussi <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Bonnes pratiques concernant les annotations</span></a> sur les bonnes pratiques concernant les annotations.</p>
</dd>
<dt id="term-virtual-environment">environnement virtuel<a class="headerlink" href="#term-virtual-environment" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Environnement d'exécution isolé (en mode coopératif) qui permet aux utilisateurs de Python et aux applications d'installer et de mettre à jour des paquets sans interférer avec d'autres applications Python fonctionnant sur le même système.</p>
<p>Voir aussi <a class="reference internal" href="library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a>.</p>
</dd>
<dt id="term-virtual-machine">machine virtuelle<a class="headerlink" href="#term-virtual-machine" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Ordinateur défini entièrement par du logiciel. La machine virtuelle (<em>virtual machine</em>) de Python exécute le <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">code intermédiaire</span></a> produit par le compilateur de <em>bytecode</em>.</p>
</dd>
<dt id="term-Zen-of-Python">Le zen de Python<a class="headerlink" href="#term-Zen-of-Python" title="Lien permanent vers ce terme">¶</a></dt><dd><p>Liste de principes et de préceptes utiles pour comprendre et utiliser le langage. Cette liste peut être obtenue en tapant &quot;<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">this</span></code>&quot; dans une invite Python interactive.</p>
</dd>
</dl>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="faq/installed.html"
                          title="Chapitre précédent">FAQ &quot;Pourquoi Python est installé sur mon ordinateur ?&quot;</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="about.html"
                          title="Chapitre suivant">À propos de ces documents</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="about.html" title="À propos de ces documents"
             >suivant</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="FAQ &#34;Pourquoi Python est installé sur mon ordinateur ?&#34;"
             >précédent</a> |</li>

          <li><img src="_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.12.0 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">Glossaire</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Mis à jour le oct. 26, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Créé en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>