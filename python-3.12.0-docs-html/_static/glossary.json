{">>>": {"title": ">>>", "body": "<main>\n<dd><p>L'invite de commande utilis\u00e9e par d\u00e9faut dans l'interpr\u00e9teur interactif. On la voit souvent dans des exemples de code qui peuvent \u00eatre ex\u00e9cut\u00e9s interactivement dans l'interpr\u00e9teur.</p>\n</dd>\n</main>\n"}, "...": {"title": "...", "body": "<main>\n<dd><p>Peut faire r\u00e9f\u00e9rence \u00e0\u00a0:</p>\n<ul class=\"simple\">\n<li><p>L'invite de commande utilis\u00e9e par d\u00e9faut dans l'interpr\u00e9teur interactif lorsqu'on entre un bloc de code indent\u00e9, dans des d\u00e9limiteurs fonctionnant par paires (parenth\u00e8ses, crochets, accolades, triple guillemets), ou apr\u00e8s un avoir sp\u00e9cifi\u00e9 un d\u00e9corateur.</p></li>\n<li><p>La constante <a class=\"reference internal\" href=\"library/constants.html#Ellipsis\" title=\"Ellipsis\"><code class=\"xref py py-const docutils literal notranslate\"><span class=\"pre\">Ellipsis</span></code></a>.</p></li>\n</ul>\n</dd>\n</main>\n"}, "2to3": {"title": "2to3", "body": "<main>\n<dd><p>Outil qui essaie de convertir du code pour Python 2.x en code pour Python 3.x en g\u00e9rant la plupart des incompatibilit\u00e9s qui peuvent \u00eatre d\u00e9tect\u00e9es en analysant la source et parcourant son arbre syntaxique.</p>\n<p><em>2to3</em> est disponible dans la biblioth\u00e8que standard sous le nom de <a class=\"reference internal\" href=\"library/2to3.html#module-lib2to3\" title=\"lib2to3: The 2to3 library\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">lib2to3</span></code></a>\u00a0; un point d\u2019entr\u00e9e ind\u00e9pendant est fourni via <code class=\"file docutils literal notranslate\"><span class=\"pre\">Tools/scripts/2to3</span></code>. Cf. <a class=\"reference internal\" href=\"library/2to3.html#to3-reference\"><span class=\"std std-ref\">2to3 --- Automated Python 2 to 3 code translation</span></a>.</p>\n</dd>\n</main>\n"}, "classe m\u00e8re abstraite": {"title": "classe m\u00e8re abstraite", "body": "<main>\n<dd><p>Les classes m\u00e8res abstraites (ABC, suivant l'abr\u00e9viation anglaise <em>Abstract Base Class</em>) compl\u00e8tent le <a class=\"reference internal\" href=\"#term-duck-typing\"><span class=\"xref std std-term\">duck-typing</span></a> en fournissant un moyen de d\u00e9finir des interfaces pour les cas o\u00f9 d'autres techniques comme <a class=\"reference internal\" href=\"library/functions.html#hasattr\" title=\"hasattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">hasattr()</span></code></a> seraient in\u00e9l\u00e9gantes ou subtilement fausses (par exemple avec les <a class=\"reference internal\" href=\"reference/datamodel.html#special-lookup\"><span class=\"std std-ref\">m\u00e9thodes magiques</span></a>). Les ABC introduisent des sous-classes virtuelles qui n'h\u00e9ritent pas d'une classe mais qui sont quand m\u00eame reconnues par <a class=\"reference internal\" href=\"library/functions.html#isinstance\" title=\"isinstance\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">isinstance()</span></code></a> ou <a class=\"reference internal\" href=\"library/functions.html#issubclass\" title=\"issubclass\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">issubclass()</span></code></a> (voir la documentation du module <a class=\"reference internal\" href=\"library/abc.html#module-abc\" title=\"abc: Abstract base classes according to :pep:`3119`.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">abc</span></code></a>). Python contient de nombreuses ABC pour les structures de donn\u00e9es (dans le module <a class=\"reference internal\" href=\"library/collections.abc.html#module-collections.abc\" title=\"collections.abc: Abstract base classes for containers\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">collections.abc</span></code></a>), les nombres (dans le module <a class=\"reference internal\" href=\"library/numbers.html#module-numbers\" title=\"numbers: Numeric abstract base classes (Complex, Real, Integral, etc.).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">numbers</span></code></a>), les flux (dans le module <a class=\"reference internal\" href=\"library/io.html#module-io\" title=\"io: Core tools for working with streams.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">io</span></code></a>) et les chercheurs-chargeurs du syst\u00e8me d'importation (dans le module <a class=\"reference internal\" href=\"library/importlib.html#module-importlib.abc\" title=\"importlib.abc: Abstract base classes related to import\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">importlib.abc</span></code></a>). Vous pouvez cr\u00e9er vos propres ABC avec le module <a class=\"reference internal\" href=\"library/abc.html#module-abc\" title=\"abc: Abstract base classes according to :pep:`3119`.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">abc</span></code></a>.</p>\n</dd>\n</main>\n"}, "annotation": {"title": "annotation", "body": "<main>\n<dd><p>\u00c9tiquette associ\u00e9e \u00e0 une variable, un attribut de classe, un param\u00e8tre de fonction ou une valeur de retour. Elle est utilis\u00e9e par convention comme <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">type hint</span></a>.</p>\n<p>Les annotations de variables locales ne sont pas accessibles au moment de l'ex\u00e9cution, mais les annotations de variables globales, d'attributs de classe et de fonctions sont stock\u00e9es dans l'attribut sp\u00e9cial <code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__annotations__</span></code> des modules, classes et fonctions, respectivement.</p>\n<p>Voir <a class=\"reference internal\" href=\"#term-variable-annotation\"><span class=\"xref std std-term\">annotation de variable</span></a>, <a class=\"reference internal\" href=\"#term-function-annotation\"><span class=\"xref std std-term\">annotation de fonction</span></a>, les <span class=\"target\" id=\"index-70\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a> et <span class=\"target\" id=\"index-71\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0526/\"><strong>PEP 526</strong></a>, qui d\u00e9crivent cette fonctionnalit\u00e9. Voir aussi <a class=\"reference internal\" href=\"howto/annotations.html#annotations-howto\"><span class=\"std std-ref\">Bonnes pratiques concernant les annotations</span></a> sur les bonnes pratiques concernant les annotations.</p>\n</dd>\n</main>\n"}, "argument": {"title": "argument", "body": "<main>\n<dd><p>Valeur, donn\u00e9e \u00e0 une <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">fonction</span></a> ou \u00e0 une <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">m\u00e9thode</span></a> lors de son appel. Il existe deux types d'arguments\u00a0:</p>\n<ul>\n<li><p><em class=\"dfn\">argument nomm\u00e9</em>\u00a0: un argument pr\u00e9c\u00e9d\u00e9 d'un identifiant (comme <code class=\"docutils literal notranslate\"><span class=\"pre\">name=</span></code>) ou un dictionnaire pr\u00e9c\u00e9d\u00e9 de <code class=\"docutils literal notranslate\"><span class=\"pre\">**</span></code>, lors d'un appel de fonction. Par exemple, <code class=\"docutils literal notranslate\"><span class=\"pre\">3</span></code> et <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code> sont tous les deux des arguments nomm\u00e9s dans l'appel \u00e0 <a class=\"reference internal\" href=\"library/functions.html#complex\" title=\"complex\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">complex()</span></code></a> ici\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"n\">real</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">imag</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"p\">{</span><span class=\"s1\">&#39;real&#39;</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">&#39;imag&#39;</span><span class=\"p\">:</span> <span class=\"mi\">5</span><span class=\"p\">})</span>\n</pre></div>\n</div>\n</li>\n<li><p><em class=\"dfn\">argument positionnel</em>\u00a0: un argument qui n'est pas nomm\u00e9. Les arguments positionnels apparaissent au d\u00e9but de la liste des arguments, ou donn\u00e9s sous forme d'un <a class=\"reference internal\" href=\"#term-iterable\"><span class=\"xref std std-term\">it\u00e9rable</span></a> pr\u00e9c\u00e9d\u00e9 par <code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code>. Par exemple, <code class=\"docutils literal notranslate\"><span class=\"pre\">3</span></code> et <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code> sont tous les deux des arguments positionnels dans les appels suivants\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n</li>\n</ul>\n<p>Les arguments se retrouvent dans le corps de la fonction appel\u00e9e parmi les variables locales. Voir la section <a class=\"reference internal\" href=\"reference/expressions.html#calls\"><span class=\"std std-ref\">Appels</span></a> \u00e0 propos des r\u00e8gles dictant cette affectation. Syntaxiquement, toute expression est accept\u00e9e comme argument, et c'est la valeur r\u00e9sultante de l'expression qui sera affect\u00e9e \u00e0 la variable locale.</p>\n<p>Voir aussi <a class=\"reference internal\" href=\"#term-parameter\"><span class=\"xref std std-term\">param\u00e8tre</span></a> dans le glossaire, la question <a class=\"reference internal\" href=\"faq/programming.html#faq-argument-vs-parameter\"><span class=\"std std-ref\">Diff\u00e9rence entre argument et param\u00e8tre</span></a> de la FAQ et la <span class=\"target\" id=\"index-72\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0362/\"><strong>PEP 362</strong></a>.</p>\n</dd>\n</main>\n"}, "gestionnaire de contexte asynchrone": {"title": "gestionnaire de contexte asynchrone", "body": "<main>\n<dd><p>An object which controls the environment seen in an\n<a class=\"reference internal\" href=\"reference/compound_stmts.html#async-with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">with</span></code></a> statement by defining <a class=\"reference internal\" href=\"reference/datamodel.html#object.__aenter__\" title=\"object.__aenter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aenter__()</span></code></a> and\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__aexit__\" title=\"object.__aexit__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aexit__()</span></code></a> methods.  Introduced by <span class=\"target\" id=\"index-3\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "g\u00e9n\u00e9rateur asynchrone": {"title": "g\u00e9n\u00e9rateur asynchrone", "body": "<main>\n<dd><p>Fonction qui renvoie un <a class=\"reference internal\" href=\"#term-asynchronous-generator-iterator\"><span class=\"xref std std-term\">it\u00e9rateur de g\u00e9n\u00e9rateur asynchrone</span></a>. Cela ressemble \u00e0 une coroutine d\u00e9finie par <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-def\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code></a>, sauf qu'elle contient une ou des expressions <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> produisant ainsi uns s\u00e9rie de valeurs utilisables dans une boucle <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a>.</p>\n<p>G\u00e9n\u00e9rateur asynchrone fait g\u00e9n\u00e9ralement r\u00e9f\u00e9rence \u00e0 une fonction, mais peut faire r\u00e9f\u00e9rence \u00e0 un <em>it\u00e9rateur de g\u00e9n\u00e9rateur asynchrone</em> dans certains contextes. Dans les cas o\u00f9 le sens voulu n'est pas clair, utiliser l'ensemble des termes l\u00e8ve l\u2019ambigu\u00eft\u00e9.</p>\n<p>Un g\u00e9n\u00e9rateur asynchrone peut contenir des expressions <a class=\"reference internal\" href=\"reference/expressions.html#await\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">await</span></code></a> ainsi que des instructions <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a>, et <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">with</span></code></a>.</p>\n</dd>\n</main>\n"}, "it\u00e9rateur de g\u00e9n\u00e9rateur asynchrone": {"title": "it\u00e9rateur de g\u00e9n\u00e9rateur asynchrone", "body": "<main>\n<dd><p>Objet cr\u00e9\u00e9 par un <a class=\"reference internal\" href=\"#term-asynchronous-generator\"><span class=\"xref std std-term\">g\u00e9n\u00e9rateur asynchrone</span></a>.</p>\n<p>This is an <a class=\"reference internal\" href=\"#term-asynchronous-iterator\"><span class=\"xref std std-term\">asynchronous iterator</span></a> which when called using the\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a> method returns an awaitable object which will execute\nthe body of the asynchronous generator function until the next\n<a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> expression.</p>\n<p>Each <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> temporarily suspends processing, remembering the\nlocation execution state (including local variables and pending\ntry-statements).  When the <em>asynchronous generator iterator</em> effectively\nresumes with another awaitable returned by <a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a>, it\npicks up where it left off.  See <span class=\"target\" id=\"index-4\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a> and <span class=\"target\" id=\"index-5\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0525/\"><strong>PEP 525</strong></a>.</p>\n</dd>\n</main>\n"}, "it\u00e9rable asynchrone": {"title": "it\u00e9rable asynchrone", "body": "<main>\n<dd><p>An object, that can be used in an <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a> statement.\nMust return an <a class=\"reference internal\" href=\"#term-asynchronous-iterator\"><span class=\"xref std std-term\">asynchronous iterator</span></a> from its\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__aiter__\" title=\"object.__aiter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aiter__()</span></code></a> method.  Introduced by <span class=\"target\" id=\"index-6\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "it\u00e9rateur asynchrone": {"title": "it\u00e9rateur asynchrone", "body": "<main>\n<dd><p>An object that implements the <a class=\"reference internal\" href=\"reference/datamodel.html#object.__aiter__\" title=\"object.__aiter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aiter__()</span></code></a> and <a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a>\nmethods.  <a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a> must return an <a class=\"reference internal\" href=\"#term-awaitable\"><span class=\"xref std std-term\">awaitable</span></a> object.\n<a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a> resolves the awaitables returned by an asynchronous\niterator's <a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a> method until it raises a\n<a class=\"reference internal\" href=\"library/exceptions.html#StopAsyncIteration\" title=\"StopAsyncIteration\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">StopAsyncIteration</span></code></a> exception.  Introduced by <span class=\"target\" id=\"index-7\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "attribut": {"title": "attribut", "body": "<main>\n<dd><p>Valeur associ\u00e9e \u00e0 un objet et habituellement d\u00e9sign\u00e9e par son nom <em>via</em> une notation utilisant des points. Par exemple, si un objet <em>o</em> poss\u00e8de un attribut <em>a</em>, cet attribut est r\u00e9f\u00e9renc\u00e9 par <em>o.a</em>.</p>\n<p>Il est possible de donner \u00e0 un objet un attribut dont le nom n'est pas un identifiant tel que d\u00e9fini pour les <a class=\"reference internal\" href=\"reference/lexical_analysis.html#identifiers\"><span class=\"std std-ref\">Identifiants et mots-cl\u00e9s</span></a>, par exemple en utilisant <a class=\"reference internal\" href=\"library/functions.html#setattr\" title=\"setattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">setattr()</span></code></a>, si l'objet le permet. Un tel attribut ne sera pas accessible \u00e0 l'aide d'une expression point\u00e9e et on devra y acc\u00e9der avec <a class=\"reference internal\" href=\"library/functions.html#getattr\" title=\"getattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">getattr()</span></code></a>.</p>\n</dd>\n</main>\n"}, "attendable (awaitable)": {"title": "attendable (awaitable)", "body": "<main>\n<dd><p>An object that can be used in an <a class=\"reference internal\" href=\"reference/expressions.html#await\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">await</span></code></a> expression.  Can be\na <a class=\"reference internal\" href=\"#term-coroutine\"><span class=\"xref std std-term\">coroutine</span></a> or an object with an <a class=\"reference internal\" href=\"reference/datamodel.html#object.__await__\" title=\"object.__await__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__await__()</span></code></a> method.\nSee also <span class=\"target\" id=\"index-8\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "bdfl": {"title": "BDFL", "body": "<main>\n<dd><p>Dictateur bienveillant \u00e0 vie (<em>Benevolent Dictator For Life</em> en anglais). Pseudonyme de <a class=\"reference external\" href=\"https://gvanrossum.github.io/\">Guido van Rossum</a>, le cr\u00e9ateur de Python.</p>\n</dd>\n</main>\n"}, "fichier binaire": {"title": "fichier binaire", "body": "<main>\n<dd><p>Un <a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file object</span></a> capable de lire et d'\u00e9crire des <a class=\"reference internal\" href=\"#term-bytes-like-object\"><span class=\"xref std std-term\">bytes-like objects</span></a>. Des fichiers binaires sont, par exemple, les fichiers ouverts en mode binaire (<code class=\"docutils literal notranslate\"><span class=\"pre\">'rb'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'wb'</span></code>, ou <code class=\"docutils literal notranslate\"><span class=\"pre\">'rb+'</span></code>), <code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdin.buffer</span></code>, <code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdout.buffer</span></code>, les instances de <a class=\"reference internal\" href=\"library/io.html#io.BytesIO\" title=\"io.BytesIO\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">io.BytesIO</span></code></a> ou de <a class=\"reference internal\" href=\"library/gzip.html#gzip.GzipFile\" title=\"gzip.GzipFile\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">gzip.GzipFile</span></code></a>.</p>\n<p>Consultez <a class=\"reference internal\" href=\"#term-text-file\"><span class=\"xref std std-term\">fichier texte</span></a>, un objet fichier capable de lire et d'\u00e9crire des objets <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>.</p>\n</dd>\n</main>\n"}, "r\u00e9f\u00e9rence emprunt\u00e9e": {"title": "r\u00e9f\u00e9rence emprunt\u00e9e", "body": "<main>\n<dd><p>In Python's C API, a borrowed reference is a reference to an object,\nwhere the code using the object does not own the reference.\nIt becomes a dangling\npointer if the object is destroyed. For example, a garbage collection can\nremove the last <a class=\"reference internal\" href=\"#term-strong-reference\"><span class=\"xref std std-term\">strong reference</span></a> to the object and so destroy it.</p>\n<p>Il est recommand\u00e9 d'appeler <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_INCREF\" title=\"Py_INCREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_INCREF()</span></code></a> sur la <a class=\"reference internal\" href=\"#term-borrowed-reference\"><span class=\"xref std std-term\">r\u00e9f\u00e9rence emprunt\u00e9e</span></a>, ce qui la transforme <em>in situ</em> en une <a class=\"reference internal\" href=\"#term-strong-reference\"><span class=\"xref std std-term\">r\u00e9f\u00e9rence forte</span></a>. Vous pouvez faire une exception si vous \u00eates certain que l'objet ne peut pas \u00eatre supprim\u00e9 avant la derni\u00e8re utilisation de la r\u00e9f\u00e9rence emprunt\u00e9e. Voir aussi la fonction <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_NewRef\" title=\"Py_NewRef\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_NewRef()</span></code></a>, qui cr\u00e9e une nouvelle <a class=\"reference internal\" href=\"#term-strong-reference\"><span class=\"xref std std-term\">r\u00e9f\u00e9rence forte</span></a>.</p>\n</dd>\n</main>\n"}, "objet octet-compatible": {"title": "objet octet-compatible", "body": "<main>\n<dd><p>Un objet g\u00e9rant le <a class=\"reference internal\" href=\"c-api/buffer.html#bufferobjects\"><span class=\"std std-ref\">protocole tampon</span></a> et pouvant exporter un tampon (<em>buffer</em> en anglais) C-<a class=\"reference internal\" href=\"#term-contiguous\"><span class=\"xref std std-term\">contigu</span></a>. Cela inclut les objets <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#bytearray\" title=\"bytearray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytearray</span></code></a> et <a class=\"reference internal\" href=\"library/array.html#array.array\" title=\"array.array\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">array.array</span></code></a>, ainsi que beaucoup d'objets <a class=\"reference internal\" href=\"library/stdtypes.html#memoryview\" title=\"memoryview\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">memoryview</span></code></a>. Les objets octets-compatibles peuvent \u00eatre utilis\u00e9s pour diverses op\u00e9rations sur des donn\u00e9es binaires, comme la compression, la sauvegarde dans un fichier binaire ou l'envoi sur le r\u00e9seau.</p>\n<p>Certaines op\u00e9rations n\u00e9cessitent de travailler sur des donn\u00e9es binaires variables. La documentation parle de ceux-ci comme des <em>read-write bytes-like objects</em>. Par exemple, <a class=\"reference internal\" href=\"library/stdtypes.html#bytearray\" title=\"bytearray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytearray</span></code></a> ou une <a class=\"reference internal\" href=\"library/stdtypes.html#memoryview\" title=\"memoryview\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">memoryview</span></code></a> d'un <a class=\"reference internal\" href=\"library/stdtypes.html#bytearray\" title=\"bytearray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytearray</span></code></a> en font partie. D'autres op\u00e9rations n\u00e9cessitent de travailler sur des donn\u00e9es binaires stock\u00e9es dans des objets immuables (\u00ab\u00a0<em>objets octets-compatibles en lecture seule</em>\u00a0\u00bb), par exemple des <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> ou des <a class=\"reference internal\" href=\"library/stdtypes.html#memoryview\" title=\"memoryview\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">memoryview</span></code></a> d'un objet <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a>.</p>\n</dd>\n</main>\n"}, "code interm\u00e9diaire (bytecode)": {"title": "code interm\u00e9diaire (bytecode)", "body": "<main>\n<dd><p>Le code source, en Python, est compil\u00e9 en un code interm\u00e9diaire (<em>bytecode</em> en anglais), la repr\u00e9sentation interne \u00e0 CPython d'un programme Python. Le code interm\u00e9diaire est mis en cache dans un fichier <code class=\"docutils literal notranslate\"><span class=\"pre\">.pyc</span></code> de mani\u00e8re \u00e0 ce qu'une seconde ex\u00e9cution soit plus rapide (la compilation en code interm\u00e9diaire a d\u00e9j\u00e0 \u00e9t\u00e9 faite). On dit que ce <em>langage interm\u00e9diaire</em> est ex\u00e9cut\u00e9 sur une <a class=\"reference internal\" href=\"#term-virtual-machine\"><span class=\"xref std std-term\">virtual machine</span></a> qui ex\u00e9cute des instructions machine pour chaque instruction du code interm\u00e9diaire. Notez que le code interm\u00e9diaire n'a pas vocation \u00e0 fonctionner sur diff\u00e9rentes machines virtuelles Python ou \u00e0 \u00eatre stable entre diff\u00e9rentes versions de Python.</p>\n<p>La documentation du <a class=\"reference internal\" href=\"library/dis.html#bytecodes\"><span class=\"std std-ref\">module dis</span></a> fournit une liste des instructions du code interm\u00e9diaire.</p>\n</dd>\n</main>\n"}, "appelable (callable)": {"title": "appelable (callable)", "body": "<main>\n<dd><p>Un appelable est un objet qui peut \u00eatre appel\u00e9, \u00e9ventuellement avec un ensemble d'arguments (voir  <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>), avec la syntaxe suivante\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">callable</span><span class=\"p\">(</span><span class=\"n\">argument1</span><span class=\"p\">,</span> <span class=\"n\">argument2</span><span class=\"p\">,</span> <span class=\"n\">argumentN</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Une <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">fonction</span></a>, et par extension une <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">m\u00e9thode</span></a>, est un appelable. Une instance d'une classe qui impl\u00e9mente la m\u00e9thode <a class=\"reference internal\" href=\"reference/datamodel.html#object.__call__\" title=\"object.__call__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__call__()</span></code></a> est \u00e9galement un appelable.</p>\n</dd>\n</main>\n"}, "fonction de rappel (callback)": {"title": "fonction de rappel (callback)", "body": "<main>\n<dd><p>Une fonction (classique, par opposition \u00e0 une coroutine) pass\u00e9e en argument pour \u00eatre ex\u00e9cut\u00e9e plus tard.</p>\n</dd>\n</main>\n"}, "classe": {"title": "classe", "body": "<main>\n<dd><p>Mod\u00e8le pour cr\u00e9er des objets d\u00e9finis par l'utilisateur. Une d\u00e9finition de classe (<em>class</em>) contient normalement des d\u00e9finitions de m\u00e9thodes qui agissent sur les instances de la classe.</p>\n</dd>\n</main>\n"}, "variable de classe": {"title": "variable de classe", "body": "<main>\n<dd><p>Une variable d\u00e9finie dans une classe et destin\u00e9e \u00e0 \u00eatre modifi\u00e9e uniquement au niveau de la classe (c'est-\u00e0-dire, pas dans une instance de la classe).</p>\n</dd>\n</main>\n"}, "nombre complexe": {"title": "nombre complexe", "body": "<main>\n<dd><p>Extension des nombres r\u00e9els familiers, dans laquelle tous les nombres sont exprim\u00e9s sous la forme d'une somme d'une partie r\u00e9elle et d'une partie imaginaire. Les nombres imaginaires sont les nombres r\u00e9els multipli\u00e9s par l'unit\u00e9 imaginaire (la racine carr\u00e9e de <code class=\"docutils literal notranslate\"><span class=\"pre\">-1</span></code>, souvent \u00e9crite <code class=\"docutils literal notranslate\"><span class=\"pre\">i</span></code> en math\u00e9matiques ou <code class=\"docutils literal notranslate\"><span class=\"pre\">j</span></code> par les ing\u00e9nieurs). Python comprend nativement les nombres complexes, \u00e9crits avec cette derni\u00e8re notation\u00a0: la partie imaginaire est \u00e9crite avec un suffixe <code class=\"docutils literal notranslate\"><span class=\"pre\">j</span></code>, exemple, <code class=\"docutils literal notranslate\"><span class=\"pre\">3+1j</span></code>. Pour utiliser les \u00e9quivalents complexes de <a class=\"reference internal\" href=\"library/math.html#module-math\" title=\"math: Mathematical functions (sin() etc.).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">math</span></code></a>, utilisez <a class=\"reference internal\" href=\"library/cmath.html#module-cmath\" title=\"cmath: Mathematical functions for complex numbers.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">cmath</span></code></a>. Les nombres complexes sont un concept assez avanc\u00e9 en math\u00e9matiques. Si vous ne connaissez pas ce concept, vous pouvez tranquillement les ignorer.</p>\n</dd>\n</main>\n"}, "gestionnaire de contexte": {"title": "gestionnaire de contexte", "body": "<main>\n<dd><p>An object which controls the environment seen in a <a class=\"reference internal\" href=\"reference/compound_stmts.html#with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">with</span></code></a>\nstatement by defining <a class=\"reference internal\" href=\"reference/datamodel.html#object.__enter__\" title=\"object.__enter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__enter__()</span></code></a> and <a class=\"reference internal\" href=\"reference/datamodel.html#object.__exit__\" title=\"object.__exit__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__exit__()</span></code></a> methods.\nSee <span class=\"target\" id=\"index-9\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0343/\"><strong>PEP 343</strong></a>.</p>\n</dd>\n</main>\n"}, "variable de contexte": {"title": "variable de contexte", "body": "<main>\n<dd><p>Une variable qui peut avoir des valeurs diff\u00e9rentes en fonction de son contexte. Cela est similaire au stockage par fil d\u2019ex\u00e9cution (<em>Thread Local Storage</em> en anglais) dans lequel chaque fil d\u2019ex\u00e9cution peut avoir une valeur diff\u00e9rente pour une variable. Toutefois, avec les variables de contexte, il peut y avoir plusieurs contextes dans un fil d\u2019ex\u00e9cution et l\u2019utilisation principale pour les variables de contexte est de garder une trace des variables dans les t\u00e2ches asynchrones concourantes. Voir <a class=\"reference internal\" href=\"library/contextvars.html#module-contextvars\" title=\"contextvars: Context Variables\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">contextvars</span></code></a>.</p>\n</dd>\n</main>\n"}, "contigu": {"title": "contigu", "body": "<main>\n<dd><p id=\"index-10\">Un tampon (<em>buffer</em> en anglais) est consid\u00e9r\u00e9 comme contigu s\u2019il est soit <em>C-contigu</em> soit <em>Fortran-contigu</em>. Les tampons de dimension z\u00e9ro sont C-contigus et Fortran-contigus. Pour un tableau \u00e0 une dimension, ses \u00e9l\u00e9ments doivent \u00eatre plac\u00e9s en m\u00e9moire l\u2019un \u00e0 c\u00f4t\u00e9 de l\u2019autre, dans l\u2019ordre croissant de leur indice, en commen\u00e7ant \u00e0 z\u00e9ro. Pour qu\u2019un tableau multidimensionnel soit C-contigu, le dernier indice doit \u00eatre celui qui varie le plus rapidement lors du parcours de ses \u00e9l\u00e9ments dans l\u2019ordre de leur adresse m\u00e9moire. \u00c0 l'inverse, dans les tableaux Fortran-contigu, c\u2019est le premier indice qui doit varier le plus rapidement.</p>\n</dd>\n</main>\n"}, "coroutine": {"title": "coroutine", "body": "<main>\n<dd><p>Les coroutines sont une forme g\u00e9n\u00e9ralis\u00e9e des fonctions. On entre dans une fonction en un point et on en sort en un autre point. On peut entrer, sortir et reprendre l'ex\u00e9cution d'une coroutine en plusieurs points. Elles peuvent \u00eatre impl\u00e9ment\u00e9es en utilisant l'instruction <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-def\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code></a>. Voir aussi la <span class=\"target\" id=\"index-73\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "fonction coroutine": {"title": "fonction coroutine", "body": "<main>\n<dd><p>Fonction qui renvoie un objet <a class=\"reference internal\" href=\"#term-coroutine\"><span class=\"xref std std-term\">coroutine</span></a>. Une fonction coroutine peut \u00eatre d\u00e9finie par l'instruction <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-def\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code></a> et peut contenir les mots cl\u00e9s <a class=\"reference internal\" href=\"reference/expressions.html#await\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">await</span></code></a>, <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a> ainsi que <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">with</span></code></a>. A \u00e9t\u00e9 introduit par la <span class=\"target\" id=\"index-74\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "cpython": {"title": "CPython", "body": "<main>\n<dd><p>L'impl\u00e9mentation canonique du langage de programmation Python, tel que distribu\u00e9 sur <a class=\"reference external\" href=\"https://www.python.org\">python.org</a>. Le terme &quot;CPython&quot; est utilis\u00e9 dans certains contextes lorsqu'il est n\u00e9cessaire de distinguer cette impl\u00e9mentation des autres comme <em>Jython</em> ou <em>IronPython</em>.</p>\n</dd>\n</main>\n"}, "d\u00e9corateur": {"title": "d\u00e9corateur", "body": "<main>\n<dd><p>Fonction dont la valeur de retour est une autre fonction. Un d\u00e9corateur est habituellement utilis\u00e9 pour transformer une fonction via la syntaxe <code class=\"docutils literal notranslate\"><span class=\"pre\">&#64;wrapper</span></code>, dont les exemples typiques sont\u00a0: <a class=\"reference internal\" href=\"library/functions.html#classmethod\" title=\"classmethod\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">classmethod()</span></code></a> et <a class=\"reference internal\" href=\"library/functions.html#staticmethod\" title=\"staticmethod\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">staticmethod()</span></code></a>.</p>\n<p>La syntaxe des d\u00e9corateurs est simplement du sucre syntaxique, les d\u00e9finitions des deux fonctions suivantes sont s\u00e9mantiquement \u00e9quivalentes\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"nb\">staticmethod</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@staticmethod</span>\n<span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n</pre></div>\n</div>\n<p>Quoique moins fr\u00e9quemment utilis\u00e9, le m\u00eame concept existe pour les classes. Consultez la documentation <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">d\u00e9finitions de fonctions</span></a> et <a class=\"reference internal\" href=\"reference/compound_stmts.html#class\"><span class=\"std std-ref\">d\u00e9finitions de classes</span></a> pour en savoir plus sur les d\u00e9corateurs.</p>\n</dd>\n</main>\n"}, "descripteur": {"title": "descripteur", "body": "<main>\n<dd><p>N'importe quel objet d\u00e9finissant les m\u00e9thodes <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__get__()</span></code>, <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__set__()</span></code>, ou <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__delete__()</span></code>. Lorsque l'attribut d'une classe est un descripteur, son comportement sp\u00e9cial est d\u00e9clench\u00e9 lors de la recherche des attributs. Normalement, lorsque vous \u00e9crivez <em>a.b</em> pour obtenir, affecter ou effacer un attribut, Python recherche l'objet nomm\u00e9 <em>b</em> dans le dictionnaire de la classe de <em>a</em>. Mais si <em>b</em> est un descripteur, c'est la m\u00e9thode de ce descripteur qui est alors appel\u00e9e. Comprendre les descripteurs est requis pour avoir une compr\u00e9hension approfondie de Python, ils sont la base de nombre de ses caract\u00e9ristiques notamment les fonctions, m\u00e9thodes, propri\u00e9t\u00e9s, m\u00e9thodes de classes, m\u00e9thodes statiques et les r\u00e9f\u00e9rences aux classes parentes.</p>\n<p>Pour plus d'informations sur les m\u00e9thodes des descripteurs, consultez <a class=\"reference internal\" href=\"reference/datamodel.html#descriptors\"><span class=\"std std-ref\">Impl\u00e9mentation de descripteurs</span></a> ou le <a class=\"reference internal\" href=\"howto/descriptor.html#descriptorhowto\"><span class=\"std std-ref\">guide pour l'utilisation des descripteurs</span></a>.</p>\n</dd>\n</main>\n"}, "dictionnaire": {"title": "dictionnaire", "body": "<main>\n<dd><p>Structure de donn\u00e9e associant des cl\u00e9s \u00e0 des valeurs. Les cl\u00e9s peuvent \u00eatre n'importe quel objet poss\u00e9dant les m\u00e9thodes <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__hash__()</span></code> et <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__eq__()</span></code>. En Perl, les dictionnaires sont appel\u00e9s &quot;<em>hash</em>&quot;.</p>\n</dd>\n</main>\n"}, "dictionnaire en compr\u00e9hension (ou dictionnaire en intension)": {"title": "dictionnaire en compr\u00e9hension (ou dictionnaire en intension)", "body": "<main>\n<dd><p>\u00c9criture concise pour traiter tout ou partie des \u00e9l\u00e9ments d'un it\u00e9rable et renvoyer un dictionnaire contenant les r\u00e9sultats. <code class=\"docutils literal notranslate\"><span class=\"pre\">results</span> <span class=\"pre\">=</span> <span class=\"pre\">{n:</span> <span class=\"pre\">n</span> <span class=\"pre\">**</span> <span class=\"pre\">2</span> <span class=\"pre\">for</span> <span class=\"pre\">n</span> <span class=\"pre\">in</span> <span class=\"pre\">range(10)}</span></code> g\u00e9n\u00e8re un dictionnaire contenant des cl\u00e9s <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code> li\u00e9es \u00e0 leurs valeurs <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span> <span class=\"pre\">**</span> <span class=\"pre\">2</span></code>. Voir <a class=\"reference internal\" href=\"reference/expressions.html#comprehensions\"><span class=\"std std-ref\">compr\u00e9hensions</span></a>.</p>\n</dd>\n</main>\n"}, "vue de dictionnaire": {"title": "vue de dictionnaire", "body": "<main>\n<dd><p>Objets retourn\u00e9s par les m\u00e9thodes <a class=\"reference internal\" href=\"library/stdtypes.html#dict.keys\" title=\"dict.keys\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">dict.keys()</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#dict.values\" title=\"dict.values\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">dict.values()</span></code></a> et <a class=\"reference internal\" href=\"library/stdtypes.html#dict.items\" title=\"dict.items\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">dict.items()</span></code></a>. Ils fournissent des vues dynamiques des entr\u00e9es du dictionnaire, ce qui signifie que lorsque le dictionnaire change, la vue change. Pour transformer une vue en vraie liste, utilisez <code class=\"docutils literal notranslate\"><span class=\"pre\">list(dictview)</span></code>. Voir <a class=\"reference internal\" href=\"library/stdtypes.html#dict-views\"><span class=\"std std-ref\">Les vues de dictionnaires</span></a>.</p>\n</dd>\n</main>\n"}, "cha\u00eene de documentation (docstring)": {"title": "cha\u00eene de documentation (docstring)", "body": "<main>\n<dd><p>Premi\u00e8re cha\u00eene litt\u00e9rale qui appara\u00eet dans l'expression d'une classe, fonction, ou module. Bien qu'ignor\u00e9e \u00e0 l'ex\u00e9cution, elle est reconnue par le compilateur et plac\u00e9e dans l'attribut <code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__doc__</span></code> de la classe, de la fonction ou du module. Comme cette cha\u00eene est disponible par introspection, c'est l'endroit id\u00e9al pour documenter l'objet.</p>\n</dd>\n</main>\n"}, "typage canard (duck-typing)": {"title": "typage canard (duck-typing)", "body": "<main>\n<dd><p>Style de programmation qui ne prend pas en compte le type d'un objet pour d\u00e9terminer s'il respecte une interface, mais qui appelle simplement la m\u00e9thode ou l'attribut (<em>Si \u00e7a a un bec et que \u00e7a cancane, \u00e7a doit \u00eatre un canard</em>, <em>duck</em> signifie canard en anglais). En se concentrant sur les interfaces plut\u00f4t que les types, du code bien construit am\u00e9liore sa flexibilit\u00e9 en autorisant des substitutions polymorphiques. Le <em>duck-typing</em> \u00e9vite de v\u00e9rifier les types via <a class=\"reference internal\" href=\"library/functions.html#type\" title=\"type\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">type()</span></code></a> ou <a class=\"reference internal\" href=\"library/functions.html#isinstance\" title=\"isinstance\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">isinstance()</span></code></a>, Notez cependant que le <em>duck-typing</em> peut travailler de pair avec les <a class=\"reference internal\" href=\"#term-abstract-base-class\"><span class=\"xref std std-term\">classes m\u00e8re abstraites</span></a>. \u00c0 la place, le <em>duck-typing</em> utilise plut\u00f4t <a class=\"reference internal\" href=\"library/functions.html#hasattr\" title=\"hasattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">hasattr()</span></code></a> ou la programmation <a class=\"reference internal\" href=\"#term-EAFP\"><span class=\"xref std std-term\">EAFP</span></a>.</p>\n</dd>\n</main>\n"}, "eafp": {"title": "EAFP", "body": "<main>\n<dd><p>Il est plus simple de demander pardon que demander la permission (<em>Easier to Ask for Forgiveness than Permission</em> en anglais). Ce style de d\u00e9veloppement Python fait l'hypoth\u00e8se que le code est valide et traite les exceptions si cette hypoth\u00e8se s'av\u00e8re fausse. Ce style, propre et efficace, est caract\u00e9ris\u00e9 par la pr\u00e9sence de beaucoup de mots cl\u00e9s <a class=\"reference internal\" href=\"reference/compound_stmts.html#try\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">try</span></code></a> et <a class=\"reference internal\" href=\"reference/compound_stmts.html#except\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">except</span></code></a>. Cette technique de programmation contraste avec le style <a class=\"reference internal\" href=\"#term-LBYL\"><span class=\"xref std std-term\">LBYL</span></a> utilis\u00e9 couramment dans les langages tels que C.</p>\n</dd>\n</main>\n"}, "expression": {"title": "expression", "body": "<main>\n<dd><p>Suite logique de termes et chiffres conformes \u00e0 la syntaxe Python dont l'\u00e9valuation fournit une valeur. En d'autres termes, une expression est une suite d'\u00e9l\u00e9ments tels que des noms, op\u00e9rateurs, litt\u00e9raux, acc\u00e8s d'attributs, m\u00e9thodes ou fonctions qui aboutissent \u00e0 une valeur. Contrairement \u00e0 beaucoup d'autres langages, les diff\u00e9rentes constructions du langage ne sont pas toutes des expressions. On trouve \u00e9galement des <a class=\"reference internal\" href=\"#term-statement\"><span class=\"xref std std-term\">instructions</span></a> qui ne peuvent pas \u00eatre utilis\u00e9es comme expressions, tel que <a class=\"reference internal\" href=\"reference/compound_stmts.html#while\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">while</span></code></a>. Les affectations sont \u00e9galement des instructions et non des expressions.</p>\n</dd>\n</main>\n"}, "module d'extension": {"title": "module d'extension", "body": "<main>\n<dd><p>Module \u00e9crit en C ou C++, utilisant l'API C de Python pour interagir avec Python et le code de l'utilisateur.</p>\n</dd>\n</main>\n"}, "f-string": {"title": "f-string", "body": "<main>\n<dd><p>Cha\u00eene litt\u00e9rale pr\u00e9fix\u00e9e de <code class=\"docutils literal notranslate\"><span class=\"pre\">'f'</span></code> ou <code class=\"docutils literal notranslate\"><span class=\"pre\">'F'</span></code>. Les &quot;f-strings&quot; sont un raccourci pour <a class=\"reference internal\" href=\"reference/lexical_analysis.html#f-strings\"><span class=\"std std-ref\">formatted string literals</span></a>. Voir la <span class=\"target\" id=\"index-75\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0498/\"><strong>PEP 498</strong></a>.</p>\n</dd>\n</main>\n"}, "objet fichier": {"title": "objet fichier", "body": "<main>\n<dd><p>Objet exposant une ressource via une API orient\u00e9e fichier (avec les m\u00e9thodes <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">read()</span></code> ou <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">write()</span></code>). En fonction de la mani\u00e8re dont il a \u00e9t\u00e9 cr\u00e9\u00e9, un objet fichier peut interfacer l'acc\u00e8s \u00e0 un fichier sur le disque ou \u00e0 un autre type de stockage ou de communication (typiquement l'entr\u00e9e standard, la sortie standard, un tampon en m\u00e9moire, un connecteur r\u00e9seau\u2026). Les objets fichiers sont aussi appel\u00e9s <em class=\"dfn\">file-like-objects</em> ou <em class=\"dfn\">streams</em>.</p>\n<p>Il existe en r\u00e9alit\u00e9 trois cat\u00e9gories de fichiers objets\u00a0: les <a class=\"reference internal\" href=\"#term-binary-file\"><span class=\"xref std std-term\">fichiers binaires</span></a> bruts, les <a class=\"reference internal\" href=\"#term-binary-file\"><span class=\"xref std std-term\">fichiers binaires</span></a> avec tampon (<em>buffer</em>) et les <a class=\"reference internal\" href=\"#term-text-file\"><span class=\"xref std std-term\">fichiers textes</span></a>. Leurs interfaces sont d\u00e9finies dans le module <a class=\"reference internal\" href=\"library/io.html#module-io\" title=\"io: Core tools for working with streams.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">io</span></code></a>. Le moyen le plus simple et direct de cr\u00e9er un objet fichier est d'utiliser la fonction <a class=\"reference internal\" href=\"library/functions.html#open\" title=\"open\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">open()</span></code></a>.</p>\n</dd>\n</main>\n"}, "objet fichier-compatible": {"title": "objet fichier-compatible", "body": "<main>\n<dd><p>Synonyme de <a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">objet fichier</span></a>.</p>\n</dd>\n</main>\n"}, "encodage du syst\u00e8me de fichiers et gestionnaire d'erreurs associ\u00e9": {"title": "encodage du syst\u00e8me de fichiers et gestionnaire d'erreurs associ\u00e9", "body": "<main>\n<dd><p>Encodage et gestionnaire d'erreurs utilis\u00e9s par Python pour d\u00e9coder les octets fournis par le syst\u00e8me d'exploitation et encoder les cha\u00eenes de caract\u00e8res Unicode afin de les passer au syst\u00e8me.</p>\n<p>L'encodage du syst\u00e8me de fichiers doit imp\u00e9rativement pouvoir d\u00e9coder tous les octets jusqu'\u00e0 128. Si ce n'est pas le cas, certaines fonctions de l'API l\u00e8vent <a class=\"reference internal\" href=\"library/exceptions.html#UnicodeError\" title=\"UnicodeError\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">UnicodeError</span></code></a>.</p>\n<p>Cet encodage et son gestionnaire d'erreur peuvent \u00eatre obtenus \u00e0 l'aide des fonctions <a class=\"reference internal\" href=\"library/sys.html#sys.getfilesystemencoding\" title=\"sys.getfilesystemencoding\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sys.getfilesystemencoding()</span></code></a> et <a class=\"reference internal\" href=\"library/sys.html#sys.getfilesystemencodeerrors\" title=\"sys.getfilesystemencodeerrors\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sys.getfilesystemencodeerrors()</span></code></a>.</p>\n<p>L'<a class=\"reference internal\" href=\"#term-filesystem-encoding-and-error-handler\"><span class=\"xref std std-term\">encodage du syst\u00e8me de fichiers et gestionnaire d'erreurs associ\u00e9</span></a> sont configur\u00e9s au d\u00e9marrage de Python par la fonction <a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig_Read\" title=\"PyConfig_Read\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">PyConfig_Read()</span></code></a>\u00a0: regardez <a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig.filesystem_encoding\" title=\"PyConfig.filesystem_encoding\"><code class=\"xref c c-member docutils literal notranslate\"><span class=\"pre\">filesystem_encoding</span></code></a> et <a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig.filesystem_errors\" title=\"PyConfig.filesystem_errors\"><code class=\"xref c c-member docutils literal notranslate\"><span class=\"pre\">filesystem_errors</span></code></a> dans les membres de <a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig\" title=\"PyConfig\"><code class=\"xref c c-type docutils literal notranslate\"><span class=\"pre\">PyConfig</span></code></a>.</p>\n<p>Voir aussi <a class=\"reference internal\" href=\"#term-locale-encoding\"><span class=\"xref std std-term\">encodage r\u00e9gional</span></a>.</p>\n</dd>\n</main>\n"}, "chercheur": {"title": "chercheur", "body": "<main>\n<dd><p>Objet qui essaie de trouver un <a class=\"reference internal\" href=\"#term-loader\"><span class=\"xref std std-term\">chargeur</span></a> pour le module en cours d'importation.</p>\n<p>Depuis Python 3.3, il existe deux types de chercheurs\u00a0: les <a class=\"reference internal\" href=\"#term-meta-path-finder\"><span class=\"xref std std-term\">chercheurs dans les m\u00e9ta-chemins</span></a> \u00e0 utiliser avec <a class=\"reference internal\" href=\"library/sys.html#sys.meta_path\" title=\"sys.meta_path\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.meta_path</span></code></a>\u00a0; les <a class=\"reference internal\" href=\"#term-path-entry-finder\"><span class=\"xref std std-term\">chercheurs d'entr\u00e9e dans path</span></a> \u00e0 utiliser avec <a class=\"reference internal\" href=\"library/sys.html#sys.path_hooks\" title=\"sys.path_hooks\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path_hooks</span></code></a>.</p>\n<p>Voir les <span class=\"target\" id=\"index-76\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0302/\"><strong>PEP 302</strong></a>, <span class=\"target\" id=\"index-77\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0420/\"><strong>PEP 420</strong></a> et <span class=\"target\" id=\"index-78\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0451/\"><strong>PEP 451</strong></a> pour plus de d\u00e9tails.</p>\n</dd>\n</main>\n"}, "division enti\u00e8re": {"title": "division enti\u00e8re", "body": "<main>\n<dd><p>Division math\u00e9matique arrondissant \u00e0 l'entier inf\u00e9rieur. L'op\u00e9rateur de la division enti\u00e8re est <code class=\"docutils literal notranslate\"><span class=\"pre\">//</span></code>. Par exemple l'expression <code class=\"docutils literal notranslate\"><span class=\"pre\">11</span> <span class=\"pre\">//</span> <span class=\"pre\">4</span></code> vaut <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span></code>, contrairement \u00e0 <code class=\"docutils literal notranslate\"><span class=\"pre\">11</span> <span class=\"pre\">/</span> <span class=\"pre\">4</span></code> qui vaut <code class=\"docutils literal notranslate\"><span class=\"pre\">2.75</span></code>. Notez que <code class=\"docutils literal notranslate\"><span class=\"pre\">(-11)</span> <span class=\"pre\">//</span> <span class=\"pre\">4</span></code> vaut <code class=\"docutils literal notranslate\"><span class=\"pre\">-3</span></code> car l'arrondi se fait \u00e0 l'entier inf\u00e9rieur. Voir la <span class=\"target\" id=\"index-79\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0328/\"><strong>PEP 328</strong></a>.</p>\n</dd>\n</main>\n"}, "fonction": {"title": "fonction", "body": "<main>\n<dd><p>Suite d'instructions qui renvoie une valeur \u00e0 son appelant. On peut lui passer des <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">arguments</span></a> qui pourront \u00eatre utilis\u00e9s dans le corps de la fonction. Voir aussi <a class=\"reference internal\" href=\"#term-parameter\"><span class=\"xref std std-term\">param\u00e8tre</span></a>, <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">m\u00e9thode</span></a> et <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">D\u00e9finition de fonctions</span></a>.</p>\n</dd>\n</main>\n"}, "annotation de fonction": {"title": "annotation de fonction", "body": "<main>\n<dd><p><a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotation</span></a> d'un param\u00e8tre de fonction ou valeur de retour.</p>\n<p>Les annotations de fonctions sont g\u00e9n\u00e9ralement utilis\u00e9es pour des <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">indications de types</span></a>\u00a0: par exemple, cette fonction devrait prendre deux arguments <a class=\"reference internal\" href=\"library/functions.html#int\" title=\"int\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">int</span></code></a> et devrait \u00e9galement avoir une valeur de retour de type <a class=\"reference internal\" href=\"library/functions.html#int\" title=\"int\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">int</span></code></a>\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">sum_two_numbers</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n   <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span>\n</pre></div>\n</div>\n<p>L'annotation syntaxique de la fonction est expliqu\u00e9e dans la section\u00a0<a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">D\u00e9finition de fonctions</span></a>.</p>\n<p>Voir <a class=\"reference internal\" href=\"#term-variable-annotation\"><span class=\"xref std std-term\">annotation de variable</span></a> et la <span class=\"target\" id=\"index-80\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, qui d\u00e9crivent cette fonctionnalit\u00e9. Voir aussi <a class=\"reference internal\" href=\"howto/annotations.html#annotations-howto\"><span class=\"std std-ref\">Bonnes pratiques concernant les annotations</span></a> sur les bonnes pratiques concernant les annotations.</p>\n</dd>\n</main>\n"}, "__future__": {"title": "__future__", "body": "<main>\n<dd><p>Une <a class=\"reference internal\" href=\"reference/simple_stmts.html#future\"><span class=\"std std-ref\">importation depuis le futur</span></a> s'\u00e9crit <code class=\"docutils literal notranslate\"><span class=\"pre\">from</span> <span class=\"pre\">__future__</span> <span class=\"pre\">import</span> <span class=\"pre\">&lt;fonctionnalit\u00e9&gt;</span></code>. Lorsqu'une importation du futur est active dans un module, Python compile ce module avec une certaine modification de la syntaxe ou du comportement qui est vou\u00e9e \u00e0 devenir standard dans une version ult\u00e9rieure. Le module <a class=\"reference internal\" href=\"library/__future__.html#module-__future__\" title=\"__future__: Future statement definitions\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">__future__</span></code></a> documente les possibilit\u00e9s pour <em>fonctionnalit\u00e9</em>. L'importation a aussi l'effet normal d'importer une variable du module. Cette variable contient des informations utiles sur la fonctionnalit\u00e9 en question, notamment la version de Python dans laquelle elle a \u00e9t\u00e9 ajout\u00e9e, et celle dans laquelle elle deviendra standard\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">__future__</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">__future__</span><span class=\"o\">.</span><span class=\"n\">division</span>\n<span class=\"go\">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "ramasse-miettes": {"title": "ramasse-miettes", "body": "<main>\n<dd><p>(<em>garbage collection</em> en anglais) M\u00e9canisme permettant de lib\u00e9rer de la m\u00e9moire lorsqu'elle n'est plus utilis\u00e9e. Python utilise un ramasse-miettes par comptage de r\u00e9f\u00e9rence et un ramasse-miettes cyclique capable de d\u00e9tecter et casser les r\u00e9f\u00e9rences circulaires. Le ramasse-miettes peut \u00eatre contr\u00f4l\u00e9 en utilisant le module <a class=\"reference internal\" href=\"library/gc.html#module-gc\" title=\"gc: Interface to the cycle-detecting garbage collector.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">gc</span></code></a>.</p>\n</dd>\n</main>\n"}, "g\u00e9n\u00e9rateur": {"title": "g\u00e9n\u00e9rateur", "body": "<main>\n<dd><p>Fonction qui renvoie un <a class=\"reference internal\" href=\"#term-generator-iterator\"><span class=\"xref std std-term\">it\u00e9rateur de g\u00e9n\u00e9rateur</span></a>. Cela ressemble \u00e0 une fonction normale, en dehors du fait qu'elle contient une ou des expressions <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> produisant une s\u00e9rie de valeurs utilisable dans une boucle <em>for</em> ou r\u00e9cup\u00e9r\u00e9es une \u00e0 une via la fonction <a class=\"reference internal\" href=\"library/functions.html#next\" title=\"next\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">next()</span></code></a>.</p>\n<p>Fait g\u00e9n\u00e9ralement r\u00e9f\u00e9rence \u00e0 une fonction g\u00e9n\u00e9ratrice mais peut faire r\u00e9f\u00e9rence \u00e0 un <em>it\u00e9rateur de g\u00e9n\u00e9rateur</em> dans certains contextes. Dans les cas o\u00f9 le sens voulu n'est pas clair, utiliser les termes complets l\u00e8ve l\u2019ambigu\u00eft\u00e9.</p>\n</dd>\n</main>\n"}, "it\u00e9rateur de g\u00e9n\u00e9rateur": {"title": "it\u00e9rateur de g\u00e9n\u00e9rateur", "body": "<main>\n<dd><p>Objet cr\u00e9\u00e9 par une fonction <a class=\"reference internal\" href=\"#term-generator\"><span class=\"xref std std-term\">g\u00e9n\u00e9rateur</span></a>.</p>\n<p>Chaque <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> suspend temporairement l'ex\u00e9cution, en se rappelant l'endroit et l'\u00e9tat de l'ex\u00e9cution (y compris les variables locales et les <em>try</em> en cours). Lorsque l'it\u00e9rateur de g\u00e9n\u00e9rateur reprend, il repart l\u00e0 o\u00f9 il en \u00e9tait (contrairement \u00e0 une fonction qui prendrait un nouveau d\u00e9part \u00e0 chaque invocation).</p>\n</dd>\n</main>\n"}, "expression g\u00e9n\u00e9ratrice": {"title": "expression g\u00e9n\u00e9ratrice", "body": "<main>\n<dd><p>Expression qui donne un it\u00e9rateur. Elle ressemble \u00e0 une expression normale, suivie d'une clause <code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code> d\u00e9finissant une variable de boucle, un intervalle et une clause <code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code> optionnelle. Toute cette expression g\u00e9n\u00e8re des valeurs pour la fonction qui l'entoure\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">*</span><span class=\"n\">i</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">))</span>         <span class=\"c1\"># sum of squares 0, 1, 4, ... 81</span>\n<span class=\"go\">285</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "fonction g\u00e9n\u00e9rique": {"title": "fonction g\u00e9n\u00e9rique", "body": "<main>\n<dd><p>Fonction compos\u00e9e de plusieurs fonctions impl\u00e9mentant les m\u00eames op\u00e9rations pour diff\u00e9rents types. L'impl\u00e9mentation \u00e0 utiliser est d\u00e9termin\u00e9e lors de l'appel par l'algorithme de r\u00e9partition.</p>\n<p>Voir aussi <a class=\"reference internal\" href=\"#term-single-dispatch\"><span class=\"xref std std-term\">single dispatch</span></a>, le d\u00e9corateur <a class=\"reference internal\" href=\"library/functools.html#functools.singledispatch\" title=\"functools.singledispatch\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">functools.singledispatch()</span></code></a> et la <span class=\"target\" id=\"index-81\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0443/\"><strong>PEP 443</strong></a>.</p>\n</dd>\n</main>\n"}, "type g\u00e9n\u00e9rique": {"title": "type g\u00e9n\u00e9rique", "body": "<main>\n<dd><p>Un <a class=\"reference internal\" href=\"#term-type\"><span class=\"xref std std-term\">type</span></a> qui peut \u00eatre param\u00e9tr\u00e9\u00a0; g\u00e9n\u00e9ralement un <a class=\"reference internal\" href=\"reference/datamodel.html#sequence-types\"><span class=\"std std-ref\">conteneur</span></a> comme <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a> ou <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>. Utilis\u00e9 pour les <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">indications de type</span></a> et les <a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotations</span></a>.</p>\n<p>Pour plus de d\u00e9tails, voir <a class=\"reference internal\" href=\"library/stdtypes.html#types-genericalias\"><span class=\"std std-ref\">types alias g\u00e9n\u00e9riques</span></a> et le module <a class=\"reference internal\" href=\"library/typing.html#module-typing\" title=\"typing: Support for type hints (see :pep:`484`).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">typing</span></code></a>.  On trouvera l'historique de cette fonctionnalit\u00e9 dans les <span class=\"target\" id=\"index-82\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0483/\"><strong>PEP 483</strong></a>, <span class=\"target\" id=\"index-83\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a> et <span class=\"target\" id=\"index-84\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0585/\"><strong>PEP 585</strong></a>.</p>\n</dd>\n</main>\n"}, "gil": {"title": "GIL", "body": "<main>\n<dd><p>Voir <a class=\"reference internal\" href=\"#term-global-interpreter-lock\"><span class=\"xref std std-term\">global interpreter lock</span></a>.</p>\n</dd>\n</main>\n"}, "verrou global de l'interpr\u00e9teur": {"title": "verrou global de l'interpr\u00e9teur", "body": "<main>\n<dd><p>(<em>global interpreter lock</em> en anglais) M\u00e9canisme utilis\u00e9 par l'interpr\u00e9teur <a class=\"reference internal\" href=\"#term-CPython\"><span class=\"xref std std-term\">CPython</span></a> pour s'assurer qu'un seul fil d'ex\u00e9cution (<em>thread</em> en anglais) n'ex\u00e9cute le <a class=\"reference internal\" href=\"#term-bytecode\"><span class=\"xref std std-term\">bytecode</span></a> \u00e0 la fois. Cela simplifie l'impl\u00e9mentation de CPython en rendant le mod\u00e8le objet (incluant des parties critiques comme la classe native <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>) implicitement prot\u00e9g\u00e9 contre les acc\u00e8s concourants. Verrouiller l'interpr\u00e9teur entier rend plus facile l'impl\u00e9mentation de multiples fils d'ex\u00e9cution (<em>multi-thread</em> en anglais), au d\u00e9triment malheureusement de beaucoup du parall\u00e9lisme possible sur les machines ayant plusieurs processeurs.</p>\n<p>Cependant, certains modules d'extension, standards ou non, sont con\u00e7us de mani\u00e8re \u00e0 lib\u00e9rer le GIL lorsqu'ils effectuent des t\u00e2ches lourdes tel que la compression ou le hachage. De la m\u00eame mani\u00e8re, le GIL est toujours lib\u00e9r\u00e9 lors des entr\u00e9es-sorties.</p>\n<p>Les tentatives pr\u00e9c\u00e9dentes d'impl\u00e9menter un interpr\u00e9teur Python avec une granularit\u00e9 de verrouillage plus fine ont toutes \u00e9chou\u00e9es, \u00e0 cause de leurs mauvaises performances dans le cas d'un processeur unique. Il est admis que corriger ce probl\u00e8me de performance induit m\u00e8nerait \u00e0 une impl\u00e9mentation beaucoup plus compliqu\u00e9e et donc plus co\u00fbteuse \u00e0 maintenir.</p>\n</dd>\n</main>\n"}, "pyc utilisant le hachage": {"title": "pyc utilisant le hachage", "body": "<main>\n<dd><p>Un fichier de cache de code interm\u00e9diaire (<em>bytecode</em> en anglais) qui utilise le hachage plut\u00f4t que l'heure de derni\u00e8re modification du fichier source correspondant pour d\u00e9terminer sa validit\u00e9. Voir <a class=\"reference internal\" href=\"reference/import.html#pyc-invalidation\"><span class=\"std std-ref\">Invalidation de bytecode mis en cache</span></a>.</p>\n</dd>\n</main>\n"}, "hachable": {"title": "hachable", "body": "<main>\n<dd><p>Un objet est <em>hachable</em> s'il a une empreinte (<em>hash</em>) qui ne change jamais (il doit donc impl\u00e9menter une m\u00e9thode <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__hash__()</span></code>) et s'il peut \u00eatre compar\u00e9 \u00e0 d'autres objets (avec la m\u00e9thode <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__eq__()</span></code>). Les objets hachables dont la comparaison par <code class=\"docutils literal notranslate\"><span class=\"pre\">__eq__</span></code> est vraie doivent avoir la m\u00eame empreinte.</p>\n<p>La hachabilit\u00e9 permet \u00e0 un objet d'\u00eatre utilis\u00e9 comme cl\u00e9 de dictionnaire ou en tant que membre d'un ensemble (type <em>set</em>), car ces structures de donn\u00e9es utilisent ce <em>hash</em>.</p>\n<p>La plupart des types immuables natifs de Python sont hachables, mais les conteneurs muables (comme les listes ou les dictionnaires) ne le sont pas\u00a0; les conteneurs immuables (comme les n-uplets ou les ensembles fig\u00e9s) ne sont hachables que si leurs \u00e9l\u00e9ments sont hachables. Les instances de classes d\u00e9finies par les utilisateurs sont hachables par d\u00e9faut. Elles sont toutes consid\u00e9r\u00e9es diff\u00e9rentes (sauf avec elles-m\u00eames) et leur valeur de hachage est calcul\u00e9e \u00e0 partir de leur <a class=\"reference internal\" href=\"library/functions.html#id\" title=\"id\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">id()</span></code></a>.</p>\n</dd>\n</main>\n"}, "idle": {"title": "IDLE", "body": "<main>\n<dd><p>Environnement d'apprentissage et de d\u00e9veloppement int\u00e9gr\u00e9 pour Python. <a class=\"reference internal\" href=\"library/idle.html#idle\"><span class=\"std std-ref\">IDLE</span></a> est un \u00e9diteur basique et un interpr\u00e9teur livr\u00e9 avec la distribution standard de Python.</p>\n</dd>\n</main>\n"}, "immuable": {"title": "immuable", "body": "<main>\n<dd><p>Objet dont la valeur ne change pas. Les nombres, les cha\u00eenes et les <em>n</em>-uplets sont immuables. Ils ne peuvent \u00eatre modifi\u00e9s. Un nouvel objet doit \u00eatre cr\u00e9\u00e9 si une valeur diff\u00e9rente doit \u00eatre stock\u00e9e. Ils jouent un r\u00f4le important quand une valeur de <em>hash</em> constante est requise, typiquement en cl\u00e9 de dictionnaire.</p>\n</dd>\n</main>\n"}, "chemin des importations": {"title": "chemin des importations", "body": "<main>\n<dd><p>Liste de <a class=\"reference internal\" href=\"#term-path-entry\"><span class=\"xref std std-term\">entr\u00e9es</span></a> dans lesquelles le <a class=\"reference internal\" href=\"#term-path-based-finder\"><span class=\"xref std std-term\">chercheur bas\u00e9 sur les chemins</span></a> cherche les modules \u00e0 importer. Typiquement, lors d'une importation, cette liste vient de <a class=\"reference internal\" href=\"library/sys.html#sys.path\" title=\"sys.path\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path</span></code></a>\u00a0; pour les sous-paquets, elle peut aussi venir de l'attribut <code class=\"docutils literal notranslate\"><span class=\"pre\">__path__</span></code> du paquet parent.</p>\n</dd>\n</main>\n"}, "importation": {"title": "importation", "body": "<main>\n<dd><p>Processus rendant le code Python d'un module disponible dans un autre.</p>\n</dd>\n</main>\n"}, "importateur": {"title": "importateur", "body": "<main>\n<dd><p>Objet qui trouve et charge un module, en m\u00eame temps un <a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">chercheur</span></a> et un <a class=\"reference internal\" href=\"#term-loader\"><span class=\"xref std std-term\">chargeur</span></a>.</p>\n</dd>\n</main>\n"}, "interactif": {"title": "interactif", "body": "<main>\n<dd><p>Python a un interpr\u00e9teur interactif, ce qui signifie que vous pouvez \u00e9crire des expressions et des instructions \u00e0 l'invite de l'interpr\u00e9teur. L'interpr\u00e9teur Python va les ex\u00e9cuter imm\u00e9diatement et vous en pr\u00e9senter le r\u00e9sultat. D\u00e9marrez juste <code class=\"docutils literal notranslate\"><span class=\"pre\">python</span></code> (probablement depuis le menu principal de votre ordinateur). C'est un moyen puissant pour tester de nouvelles id\u00e9es ou \u00e9tudier de nouveaux modules (souvenez-vous de <code class=\"docutils literal notranslate\"><span class=\"pre\">help(x)</span></code>).</p>\n</dd>\n</main>\n"}, "interpr\u00e9t\u00e9": {"title": "interpr\u00e9t\u00e9", "body": "<main>\n<dd><p>Python est un langage interpr\u00e9t\u00e9, en opposition aux langages compil\u00e9s, bien que la fronti\u00e8re soit floue en raison de la pr\u00e9sence d'un compilateur en code interm\u00e9diaire. Cela signifie que les fichiers sources peuvent \u00eatre ex\u00e9cut\u00e9s directement, sans avoir \u00e0 compiler un fichier ex\u00e9cutable interm\u00e9diaire. Les langages interpr\u00e9t\u00e9s ont g\u00e9n\u00e9ralement un cycle de d\u00e9veloppement / d\u00e9bogage plus court que les langages compil\u00e9s. Cependant, ils s'ex\u00e9cutent g\u00e9n\u00e9ralement plus lentement. Voir aussi <a class=\"reference internal\" href=\"#term-interactive\"><span class=\"xref std std-term\">interactif</span></a>.</p>\n</dd>\n</main>\n"}, "arr\u00eat de l'interpr\u00e9teur": {"title": "arr\u00eat de l'interpr\u00e9teur", "body": "<main>\n<dd><p>Lorsqu'on lui demande de s'arr\u00eater, l'interpr\u00e9teur Python entre dans une phase sp\u00e9ciale o\u00f9 il lib\u00e8re graduellement les ressources allou\u00e9es, comme les modules ou quelques structures de donn\u00e9es internes. Il fait aussi quelques appels au <a class=\"reference internal\" href=\"#term-garbage-collection\"><span class=\"xref std std-term\">ramasse-miettes</span></a>. Cela peut d\u00e9clencher l'ex\u00e9cution de code dans des destructeurs ou des fonctions de rappels de <em>weakrefs</em>. Le code ex\u00e9cut\u00e9 lors de l'arr\u00eat peut rencontrer des exceptions puisque les ressources auxquelles il fait appel sont susceptibles de ne plus fonctionner, (typiquement les modules des biblioth\u00e8ques ou le m\u00e9canisme de <em>warning</em>).</p>\n<p>La principale raison d'arr\u00eat de l'interpr\u00e9teur est que le module <code class=\"docutils literal notranslate\"><span class=\"pre\">__main__</span></code> ou le script en cours d'ex\u00e9cution a termin\u00e9 de s'ex\u00e9cuter.</p>\n</dd>\n</main>\n"}, "it\u00e9rable": {"title": "it\u00e9rable", "body": "<main>\n<dd><p>An object capable of returning its members one at a time. Examples of\niterables include all sequence types (such as <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>,\nand <a class=\"reference internal\" href=\"library/stdtypes.html#tuple\" title=\"tuple\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tuple</span></code></a>) and some non-sequence types like <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>,\n<a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file objects</span></a>, and objects of any classes you define\nwith an <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__iter__()</span></code> method or with a <a class=\"reference internal\" href=\"reference/datamodel.html#object.__getitem__\" title=\"object.__getitem__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code></a> method\nthat implements <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a> semantics.</p>\n<p>Les it\u00e9rables peuvent \u00eatre utilis\u00e9s dans des boucles <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a> et \u00e0 beaucoup d'autres endroits o\u00f9 une s\u00e9quence est requise (<a class=\"reference internal\" href=\"library/functions.html#zip\" title=\"zip\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">zip()</span></code></a>, <a class=\"reference internal\" href=\"library/functions.html#map\" title=\"map\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">map()</span></code></a>\u2026). Lorsqu'un it\u00e9rable est pass\u00e9 comme argument \u00e0 la fonction native <a class=\"reference internal\" href=\"library/functions.html#iter\" title=\"iter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter()</span></code></a>, celle-ci fournit en retour un it\u00e9rateur sur cet it\u00e9rable. Cet it\u00e9rateur n'est valable que pour une seule passe sur le jeu de valeurs. Lors de l'utilisation d'it\u00e9rables, il n'est habituellement pas n\u00e9cessaire d'appeler <a class=\"reference internal\" href=\"library/functions.html#iter\" title=\"iter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter()</span></code></a> ou de s'occuper soi-m\u00eame des objets it\u00e9rateurs. L'instruction <code class=\"docutils literal notranslate\"><span class=\"pre\">for</span></code> le fait automatiquement pour vous, cr\u00e9ant une variable temporaire anonyme pour garder l'it\u00e9rateur durant la boucle. Voir aussi <a class=\"reference internal\" href=\"#term-iterator\"><span class=\"xref std std-term\">it\u00e9rateur</span></a>, <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">s\u00e9quence</span></a> et <a class=\"reference internal\" href=\"#term-generator\"><span class=\"xref std std-term\">g\u00e9n\u00e9rateur</span></a>.</p>\n</dd>\n</main>\n"}, "it\u00e9rateur": {"title": "it\u00e9rateur", "body": "<main>\n<dd><p>Objet repr\u00e9sentant un flux de donn\u00e9e. Des appels successifs \u00e0 la m\u00e9thode <a class=\"reference internal\" href=\"library/stdtypes.html#iterator.__next__\" title=\"iterator.__next__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__next__()</span></code></a> de l'it\u00e9rateur (ou le passer \u00e0 la fonction native <a class=\"reference internal\" href=\"library/functions.html#next\" title=\"next\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">next()</span></code></a>) donne successivement les objets du flux. Lorsque plus aucune donn\u00e9e n'est disponible, une exception <a class=\"reference internal\" href=\"library/exceptions.html#StopIteration\" title=\"StopIteration\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">StopIteration</span></code></a> est lev\u00e9e. \u00c0 ce point, l'it\u00e9rateur est \u00e9puis\u00e9 et tous les appels suivants \u00e0 sa m\u00e9thode <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__next__()</span></code> l\u00e8veront encore une exception <a class=\"reference internal\" href=\"library/exceptions.html#StopIteration\" title=\"StopIteration\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">StopIteration</span></code></a>. Les it\u00e9rateurs doivent avoir une m\u00e9thode <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__iter__()</span></code> qui renvoie l'objet it\u00e9rateur lui-m\u00eame, de fa\u00e7on \u00e0 ce que chaque it\u00e9rateur soit aussi it\u00e9rable et puisse \u00eatre utilis\u00e9 dans la plupart des endroits o\u00f9 d'autres it\u00e9rables sont attendus. Une exception notable est un code qui tente plusieurs it\u00e9rations compl\u00e8tes. Un objet conteneur, (tel que <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a>) produit un nouvel it\u00e9rateur neuf \u00e0 chaque fois qu'il est pass\u00e9 \u00e0 la fonction <a class=\"reference internal\" href=\"library/functions.html#iter\" title=\"iter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter()</span></code></a> ou s'il est utilis\u00e9 dans une boucle <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a>. Faire ceci sur un it\u00e9rateur donnerait simplement le m\u00eame objet it\u00e9rateur \u00e9puis\u00e9 utilis\u00e9 dans son it\u00e9ration pr\u00e9c\u00e9dente, le faisant ressembler \u00e0 un conteneur vide.</p>\n<p>Vous trouverez davantage d'informations dans <a class=\"reference internal\" href=\"library/stdtypes.html#typeiter\"><span class=\"std std-ref\">Les types it\u00e9rateurs</span></a>.</p>\n<div class=\"impl-detail compound\">\n<p><strong>Particularit\u00e9 de l'impl\u00e9mentation CPython\u00a0:</strong> CPython n'est pas toujours coh\u00e9rent sur le fait de demander ou non \u00e0 un it\u00e9rateur de d\u00e9finir <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__iter__()</span></code>.</p>\n</div>\n</dd>\n</main>\n"}, "fonction cl\u00e9": {"title": "fonction cl\u00e9", "body": "<main>\n<dd><p>Une fonction cl\u00e9 est un objet appelable qui renvoie une valeur \u00e0 fins de tri ou de classement. Par exemple, la fonction <a class=\"reference internal\" href=\"library/locale.html#locale.strxfrm\" title=\"locale.strxfrm\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">locale.strxfrm()</span></code></a> est utilis\u00e9e pour g\u00e9n\u00e9rer une cl\u00e9 de classement prenant en compte les conventions de classement sp\u00e9cifiques aux param\u00e8tres r\u00e9gionaux courants.</p>\n<p>Plusieurs outils dans Python acceptent des fonctions cl\u00e9s pour d\u00e9terminer comment les \u00e9l\u00e9ments sont class\u00e9s ou group\u00e9s. On peut citer les fonctions <a class=\"reference internal\" href=\"library/functions.html#min\" title=\"min\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">min()</span></code></a>, <a class=\"reference internal\" href=\"library/functions.html#max\" title=\"max\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">max()</span></code></a>, <a class=\"reference internal\" href=\"library/functions.html#sorted\" title=\"sorted\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sorted()</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#list.sort\" title=\"list.sort\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">list.sort()</span></code></a>, <a class=\"reference internal\" href=\"library/heapq.html#heapq.merge\" title=\"heapq.merge\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">heapq.merge()</span></code></a>, <a class=\"reference internal\" href=\"library/heapq.html#heapq.nsmallest\" title=\"heapq.nsmallest\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">heapq.nsmallest()</span></code></a>, <a class=\"reference internal\" href=\"library/heapq.html#heapq.nlargest\" title=\"heapq.nlargest\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">heapq.nlargest()</span></code></a> et <a class=\"reference internal\" href=\"library/itertools.html#itertools.groupby\" title=\"itertools.groupby\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">itertools.groupby()</span></code></a>.</p>\n<p>Il existe plusieurs moyens de cr\u00e9er une fonction cl\u00e9. Par exemple, la m\u00e9thode <a class=\"reference internal\" href=\"library/stdtypes.html#str.lower\" title=\"str.lower\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">str.lower()</span></code></a> peut servir de fonction cl\u00e9 pour effectuer des recherches insensibles \u00e0 la casse. Aussi, il est possible de cr\u00e9er des fonctions cl\u00e9s avec des expressions <a class=\"reference internal\" href=\"reference/expressions.html#lambda\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">lambda</span></code></a>, comme <code class=\"docutils literal notranslate\"><span class=\"pre\">lambda</span> <span class=\"pre\">r:</span> <span class=\"pre\">(r[0],</span> <span class=\"pre\">r[2])</span></code>. Par ailleurs <a class=\"reference internal\" href=\"library/operator.html#operator.attrgetter\" title=\"operator.attrgetter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">attrgetter()</span></code></a>, <a class=\"reference internal\" href=\"library/operator.html#operator.itemgetter\" title=\"operator.itemgetter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">itemgetter()</span></code></a> et <a class=\"reference internal\" href=\"library/operator.html#operator.methodcaller\" title=\"operator.methodcaller\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">methodcaller()</span></code></a> permettent de cr\u00e9er des fonctions cl\u00e9s. Voir <a class=\"reference internal\" href=\"howto/sorting.html#sortinghowto\"><span class=\"std std-ref\">le guide pour le tri</span></a> pour des exemples de cr\u00e9ation et d'utilisation de fonctions clefs.</p>\n</dd>\n</main>\n"}, "argument nomm\u00e9": {"title": "argument nomm\u00e9", "body": "<main>\n<dd><p>Voir <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>.</p>\n</dd>\n</main>\n"}, "lambda": {"title": "lambda", "body": "<main>\n<dd><p>Fonction anonyme sous la forme d'une <a class=\"reference internal\" href=\"#term-expression\"><span class=\"xref std std-term\">expression</span></a> et ne contenant qu'une seule expression, ex\u00e9cut\u00e9e lorsque la fonction est appel\u00e9e. La syntaxe pour cr\u00e9er des fonctions lambda est\u00a0: <code class=\"docutils literal notranslate\"><span class=\"pre\">lambda</span> <span class=\"pre\">[parameters]:</span> <span class=\"pre\">expression</span></code></p>\n</dd>\n</main>\n"}, "lbyl": {"title": "LBYL", "body": "<main>\n<dd><p>Regarde avant de sauter, (<em>Look before you leap</em> en anglais). Ce style de programmation consiste \u00e0 v\u00e9rifier des conditions avant d'effectuer des appels ou des acc\u00e8s. Ce style contraste avec le style <a class=\"reference internal\" href=\"#term-EAFP\"><span class=\"xref std std-term\">EAFP</span></a> et se caract\u00e9rise par la pr\u00e9sence de beaucoup d'instructions <a class=\"reference internal\" href=\"reference/compound_stmts.html#if\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code></a>.</p>\n<p>Dans un environnement avec plusieurs fils d'ex\u00e9cution (<em>multi-threaded</em> en anglais), le style <em>LBYL</em> peut engendrer un s\u00e9quencement critique (<em>race condition</em> en anglais) entre le &quot;regarde&quot; et le &quot;sauter&quot;. Par exemple, le code <code class=\"docutils literal notranslate\"><span class=\"pre\">if</span> <span class=\"pre\">key</span> <span class=\"pre\">in</span> <span class=\"pre\">mapping:</span> <span class=\"pre\">return</span> <span class=\"pre\">mapping[key]</span></code> peut \u00e9chouer si un autre fil d'ex\u00e9cution supprime la cl\u00e9 <em>key</em> du <em>mapping</em> apr\u00e8s le test mais avant l'acc\u00e8s. Ce probl\u00e8me peut \u00eatre r\u00e9solu avec des verrous (<em>locks</em>) ou avec l'approche EAFP.</p>\n</dd>\n</main>\n"}, "encodage r\u00e9gional": {"title": "encodage r\u00e9gional", "body": "<main>\n<dd><p>Sous Unix, il est d\u00e9fini par la variable r\u00e9gionale LC_CTYPE. Il peut \u00eatre modifi\u00e9 par <a class=\"reference internal\" href=\"library/locale.html#locale.setlocale\" title=\"locale.setlocale\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">locale.setlocale(locale.LC_CTYPE,</span> <span class=\"pre\">new_locale)</span></code></a>.</p>\n<p>Sous Windows, c'est un encodage ANSI (par ex. : <code class=\"docutils literal notranslate\"><span class=\"pre\">&quot;cp1252&quot;</span></code>).</p>\n<p>Sous Android et VxWorks, Python utilise <code class=\"docutils literal notranslate\"><span class=\"pre\">&quot;utf-8&quot;</span></code> comme encodage r\u00e9gional.</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">locale.getencoding()</span></code> permet de r\u00e9cup\u00e9rer l'encodage r\u00e9gional.</p>\n<p>Voir aussi l'<a class=\"reference internal\" href=\"#term-filesystem-encoding-and-error-handler\"><span class=\"xref std std-term\">encodage du syst\u00e8mes de fichiers et gestionnaire d'erreurs associ\u00e9</span></a>.</p>\n</dd>\n</main>\n"}, "liste": {"title": "liste", "body": "<main>\n<dd><p>Un type natif de <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a> dans Python. En d\u00e9pit de son nom, une <code class=\"docutils literal notranslate\"><span class=\"pre\">list</span></code> ressemble plus \u00e0 un tableau (<em>array</em> dans la plupart des langages) qu'\u00e0 une liste cha\u00een\u00e9e puisque les acc\u00e8s se font en O(1).</p>\n</dd>\n</main>\n"}, "liste en compr\u00e9hension (ou liste en intension)": {"title": "liste en compr\u00e9hension (ou liste en intension)", "body": "<main>\n<dd><p>\u00c9criture concise pour manipuler tout ou partie des \u00e9l\u00e9ments d'une s\u00e9quence et renvoyer une liste contenant les r\u00e9sultats. <code class=\"docutils literal notranslate\"><span class=\"pre\">result</span> <span class=\"pre\">=</span> <span class=\"pre\">['{:#04x}'.format(x)</span> <span class=\"pre\">for</span> <span class=\"pre\">x</span> <span class=\"pre\">in</span> <span class=\"pre\">range(256)</span> <span class=\"pre\">if</span> <span class=\"pre\">x</span> <span class=\"pre\">%</span> <span class=\"pre\">2</span> <span class=\"pre\">==</span> <span class=\"pre\">0]</span></code> g\u00e9n\u00e8re la liste compos\u00e9e des nombres pairs de 0 \u00e0 255 \u00e9crits sous formes de cha\u00eenes de caract\u00e8res et en hexad\u00e9cimal (<code class=\"docutils literal notranslate\"><span class=\"pre\">0x\u2026</span></code>). La clause <a class=\"reference internal\" href=\"reference/compound_stmts.html#if\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code></a> est optionnelle. Si elle est omise, tous les \u00e9l\u00e9ments du <code class=\"docutils literal notranslate\"><span class=\"pre\">range(256)</span></code> seront utilis\u00e9s.</p>\n</dd>\n</main>\n"}, "chargeur": {"title": "chargeur", "body": "<main>\n<dd><p>Objet qui charge un module. Il doit d\u00e9finir une m\u00e9thode nomm\u00e9e <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">load_module()</span></code>. Un chargeur est typiquement donn\u00e9 par un <a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">chercheur</span></a>. Voir la <span class=\"target\" id=\"index-85\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0302/\"><strong>PEP 302</strong></a> pour plus de d\u00e9tails et <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.ABC.Loader</span></code> pour sa <a class=\"reference internal\" href=\"#term-abstract-base-class\"><span class=\"xref std std-term\">classe m\u00e8re abstraite</span></a>.</p>\n</dd>\n</main>\n"}, "m\u00e9thode magique": {"title": "m\u00e9thode magique", "body": "<main>\n<dd><p id=\"index-26\">Un synonyme informel de <a class=\"reference internal\" href=\"#term-special-method\"><span class=\"xref std std-term\">special method</span></a>.</p>\n</dd>\n</main>\n"}, "tableau de correspondances (mapping en anglais)": {"title": "tableau de correspondances (mapping en anglais)", "body": "<main>\n<dd><p>Conteneur permettant de rechercher des \u00e9l\u00e9ments \u00e0 partir de cl\u00e9s et impl\u00e9mentant les m\u00e9thodes sp\u00e9cifi\u00e9es dans les classes m\u00e8res abstraites des <a class=\"reference internal\" href=\"library/collections.abc.html#collections.abc.Mapping\" title=\"collections.abc.Mapping\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tableaux</span> <span class=\"pre\">de</span> <span class=\"pre\">correspondances</span></code></a> (immuables) ou <a class=\"reference internal\" href=\"library/collections.abc.html#collections.abc.MutableMapping\" title=\"collections.abc.MutableMapping\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tableaux</span> <span class=\"pre\">de</span> <span class=\"pre\">correspondances</span> <span class=\"pre\">muables</span></code></a> (voir les <a class=\"reference internal\" href=\"library/collections.abc.html#collections-abstract-base-classes\"><span class=\"std std-ref\">classes m\u00e8res abstraites</span></a>). Les classes suivantes sont des exemples de tableaux de correspondances\u00a0: <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>, <a class=\"reference internal\" href=\"library/collections.html#collections.defaultdict\" title=\"collections.defaultdict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.defaultdict</span></code></a>, <a class=\"reference internal\" href=\"library/collections.html#collections.OrderedDict\" title=\"collections.OrderedDict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.OrderedDict</span></code></a> et <a class=\"reference internal\" href=\"library/collections.html#collections.Counter\" title=\"collections.Counter\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.Counter</span></code></a>.</p>\n</dd>\n</main>\n"}, "chercheur dans les m\u00e9ta-chemins": {"title": "chercheur dans les m\u00e9ta-chemins", "body": "<main>\n<dd><p>Un <a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">chercheur</span></a> renvoy\u00e9 par une recherche dans <a class=\"reference internal\" href=\"library/sys.html#sys.meta_path\" title=\"sys.meta_path\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.meta_path</span></code></a>. Les chercheurs dans les m\u00e9ta-chemins ressemblent, mais sont diff\u00e9rents des <a class=\"reference internal\" href=\"#term-path-entry-finder\"><span class=\"xref std std-term\">chercheurs d'entr\u00e9e dans path</span></a>.</p>\n<p>Voir <a class=\"reference internal\" href=\"library/importlib.html#importlib.abc.MetaPathFinder\" title=\"importlib.abc.MetaPathFinder\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.abc.MetaPathFinder</span></code></a> pour les m\u00e9thodes que les chercheurs dans les m\u00e9ta-chemins doivent impl\u00e9menter.</p>\n</dd>\n</main>\n"}, "m\u00e9taclasse": {"title": "m\u00e9taclasse", "body": "<main>\n<dd><p>Classe d'une classe. Les d\u00e9finitions de classe cr\u00e9ent un nom pour la classe, un dictionnaire de classe et une liste de classes parentes. La m\u00e9taclasse a pour r\u00f4le de r\u00e9unir ces trois param\u00e8tres pour construire la classe. La plupart des langages orient\u00e9s objet fournissent une impl\u00e9mentation par d\u00e9faut. La particularit\u00e9 de Python est la possibilit\u00e9 de cr\u00e9er des m\u00e9taclasses personnalis\u00e9es. La plupart des utilisateurs n'auront jamais besoin de cet outil, mais lorsque le besoin survient, les m\u00e9taclasses offrent des solutions \u00e9l\u00e9gantes et puissantes. Elles sont utilis\u00e9es pour journaliser les acc\u00e8s \u00e0 des propri\u00e9t\u00e9s, rendre s\u00fbrs les environnements <em>multi-threads</em>, suivre la cr\u00e9ation d'objets, impl\u00e9menter des singletons et bien d'autres t\u00e2ches.</p>\n<p>Plus d'informations sont disponibles dans\u00a0: <a class=\"reference internal\" href=\"reference/datamodel.html#metaclasses\"><span class=\"std std-ref\">M\u00e9taclasses</span></a>.</p>\n</dd>\n</main>\n"}, "m\u00e9thode": {"title": "m\u00e9thode", "body": "<main>\n<dd><p>Fonction d\u00e9finie \u00e0 l'int\u00e9rieur d'une classe. Lorsqu'elle est appel\u00e9e comme un attribut d'une instance de cette classe, la m\u00e9thode re\u00e7oit l'instance en premier <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a> (qui, par convention, est habituellement nomm\u00e9 <code class=\"docutils literal notranslate\"><span class=\"pre\">self</span></code>). Voir <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a> et <a class=\"reference internal\" href=\"#term-nested-scope\"><span class=\"xref std std-term\">nested scope</span></a>.</p>\n</dd>\n</main>\n"}, "ordre de r\u00e9solution des m\u00e9thodes": {"title": "ordre de r\u00e9solution des m\u00e9thodes", "body": "<main>\n<dd><p>L'ordre de r\u00e9solution des m\u00e9thodes (<em>MRO</em> pour <em>Method Resolution Order</em> en anglais) est, lors de la recherche d'un attribut dans les classes parentes, la fa\u00e7on dont l'interpr\u00e9teur Python classe ces classes parentes. Voir <a class=\"reference external\" href=\"https://www.python.org/download/releases/2.3/mro/\">The Python 2.3 Method Resolution Order</a> pour plus de d\u00e9tails sur l'algorithme utilis\u00e9 par l'interpr\u00e9teur Python depuis la version 2.3.</p>\n</dd>\n</main>\n"}, "module": {"title": "module", "body": "<main>\n<dd><p>Objet utilis\u00e9 pour organiser une portion unitaire de code en Python. Les modules ont un espace de nommage et peuvent contenir n'importe quels objets Python. Charger des modules est appel\u00e9 <a class=\"reference internal\" href=\"#term-importing\"><span class=\"xref std std-term\">importer</span></a>.</p>\n<p>Voir aussi <a class=\"reference internal\" href=\"#term-package\"><span class=\"xref std std-term\">paquet</span></a>.</p>\n</dd>\n</main>\n"}, "sp\u00e9cificateur de module": {"title": "sp\u00e9cificateur de module", "body": "<main>\n<dd><p>Espace de nommage contenant les informations, relatives \u00e0 l'importation, utilis\u00e9es pour charger un module. C'est une instance de la classe <a class=\"reference internal\" href=\"library/importlib.html#importlib.machinery.ModuleSpec\" title=\"importlib.machinery.ModuleSpec\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.machinery.ModuleSpec</span></code></a>.</p>\n</dd>\n</main>\n"}, "mro": {"title": "MRO", "body": "<main>\n<dd><p>Voir <a class=\"reference internal\" href=\"#term-method-resolution-order\"><span class=\"xref std std-term\">ordre de r\u00e9solution des m\u00e9thodes</span></a>.</p>\n</dd>\n</main>\n"}, "muable": {"title": "muable", "body": "<main>\n<dd><p>Un objet muable peut changer de valeur tout en gardant le m\u00eame <a class=\"reference internal\" href=\"library/functions.html#id\" title=\"id\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">id()</span></code></a>. Voir aussi <a class=\"reference internal\" href=\"#term-immutable\"><span class=\"xref std std-term\">immuable</span></a>.</p>\n</dd>\n</main>\n"}, "n-uplet nomm\u00e9": {"title": "n-uplet nomm\u00e9", "body": "<main>\n<dd><p>Le terme &quot;n-uplet nomm\u00e9&quot; s'applique \u00e0 tous les types ou classes qui h\u00e9ritent de la classe <code class=\"docutils literal notranslate\"><span class=\"pre\">tuple</span></code> et dont les \u00e9l\u00e9ments indexables sont aussi accessibles en utilisant des attributs nomm\u00e9s. Les types et classes peuvent avoir aussi d'autres caract\u00e9ristiques.</p>\n<p>Plusieurs types natifs sont appel\u00e9s n-uplets, y compris les valeurs retourn\u00e9es par <a class=\"reference internal\" href=\"library/time.html#time.localtime\" title=\"time.localtime\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">time.localtime()</span></code></a> et <a class=\"reference internal\" href=\"library/os.html#os.stat\" title=\"os.stat\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.stat()</span></code></a>. Un autre exemple est <a class=\"reference internal\" href=\"library/sys.html#sys.float_info\" title=\"sys.float_info\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.float_info</span></code></a>\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">float_info</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>                   <span class=\"c1\"># indexed access</span>\n<span class=\"go\">1024</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">float_info</span><span class=\"o\">.</span><span class=\"n\">max_exp</span>              <span class=\"c1\"># named field access</span>\n<span class=\"go\">1024</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">float_info</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">)</span>   <span class=\"c1\"># kind of tuple</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n<p>Certains <em>n-uplets nomm\u00e9s</em> sont des types natifs (comme les exemples ci-dessus). Sinon, un <em>n-uplet nomm\u00e9</em> peut \u00eatre cr\u00e9\u00e9 \u00e0 partir d'une d\u00e9finition de classe habituelle qui h\u00e9rite de <a class=\"reference internal\" href=\"library/stdtypes.html#tuple\" title=\"tuple\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tuple</span></code></a> et qui d\u00e9finit les champs nomm\u00e9s. Une telle classe peut \u00eatre \u00e9crite \u00e0 la main ou \u00eatre cr\u00e9\u00e9e avec la fonction <a class=\"reference internal\" href=\"library/collections.html#collections.namedtuple\" title=\"collections.namedtuple\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">collections.namedtuple()</span></code></a>. Cette derni\u00e8re m\u00e9thode ajoute des m\u00e9thodes suppl\u00e9mentaires qui ne seront pas trouv\u00e9es dans celles \u00e9crites \u00e0 la main ni dans les n-uplets nomm\u00e9s natifs.</p>\n</dd>\n</main>\n"}, "espace de nommage": {"title": "espace de nommage", "body": "<main>\n<dd><p>L'endroit o\u00f9 une variable est stock\u00e9e. Les espaces de nommage sont impl\u00e9ment\u00e9s avec des dictionnaires. Il existe des espaces de nommage globaux, natifs ou imbriqu\u00e9s dans les objets (dans les m\u00e9thodes). Les espaces de nommage favorisent la modularit\u00e9 car ils permettent d'\u00e9viter les conflits de noms. Par exemple, les fonctions <a class=\"reference internal\" href=\"library/functions.html#open\" title=\"open\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">builtins.open</span></code></a> et <a class=\"reference internal\" href=\"library/os.html#os.open\" title=\"os.open\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.open()</span></code></a> sont diff\u00e9renci\u00e9es par leurs espaces de nom. Les espaces de nommage aident aussi \u00e0 la lisibilit\u00e9 et la maintenabilit\u00e9 en rendant clair quel module impl\u00e9mente une fonction. Par exemple, \u00e9crire <a class=\"reference internal\" href=\"library/random.html#random.seed\" title=\"random.seed\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">random.seed()</span></code></a> ou <a class=\"reference internal\" href=\"library/itertools.html#itertools.islice\" title=\"itertools.islice\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">itertools.islice()</span></code></a> affiche clairement que ces fonctions sont impl\u00e9ment\u00e9es respectivement dans les modules <a class=\"reference internal\" href=\"library/random.html#module-random\" title=\"random: Generate pseudo-random numbers with various common distributions.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">random</span></code></a> et <a class=\"reference internal\" href=\"library/itertools.html#module-itertools\" title=\"itertools: Functions creating iterators for efficient looping.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">itertools</span></code></a>.</p>\n</dd>\n</main>\n"}, "paquet-espace de nommage": {"title": "paquet-espace de nommage", "body": "<main>\n<dd><p>Un <a class=\"reference internal\" href=\"#term-package\"><span class=\"xref std std-term\">paquet</span></a> tel que d\u00e9fini dans la <span class=\"target\" id=\"index-86\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0421/\"><strong>PEP 421</strong></a> qui ne sert qu'\u00e0 contenir des sous-paquets. Les paquets-espace de nommage peuvent n'avoir aucune repr\u00e9sentation physique et, plus sp\u00e9cifiquement, ne sont pas comme un <a class=\"reference internal\" href=\"#term-regular-package\"><span class=\"xref std std-term\">paquet classique</span></a> puisqu'ils n'ont pas de fichier <code class=\"docutils literal notranslate\"><span class=\"pre\">__init__.py</span></code>.</p>\n<p>Voir aussi <a class=\"reference internal\" href=\"#term-module\"><span class=\"xref std std-term\">module</span></a>.</p>\n</dd>\n</main>\n"}, "port\u00e9e imbriqu\u00e9e": {"title": "port\u00e9e imbriqu\u00e9e", "body": "<main>\n<dd><p>Possibilit\u00e9 de faire r\u00e9f\u00e9rence \u00e0 une variable d\u00e9clar\u00e9e dans une d\u00e9finition englobante. Typiquement, une fonction d\u00e9finie \u00e0 l'int\u00e9rieur d'une autre fonction a acc\u00e8s aux variables de cette derni\u00e8re. Souvenez-vous cependant que cela ne fonctionne que pour acc\u00e9der \u00e0 des variables, pas pour les assigner. Les variables locales sont lues et assign\u00e9es dans l'espace de nommage le plus proche. Tout comme les variables globales qui sont stock\u00e9s dans l'espace de nommage global, le mot clef <a class=\"reference internal\" href=\"reference/simple_stmts.html#nonlocal\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">nonlocal</span></code></a> permet d'\u00e9crire dans l'espace de nommage dans lequel est d\u00e9clar\u00e9e la variable.</p>\n</dd>\n</main>\n"}, "nouvelle classe": {"title": "nouvelle classe", "body": "<main>\n<dd><p>Ancien nom pour l'impl\u00e9mentation actuelle des classes, pour tous les objets. Dans les anciennes versions de Python, seules les nouvelles classes pouvaient utiliser les nouvelles fonctionnalit\u00e9s telles que <a class=\"reference internal\" href=\"reference/datamodel.html#object.__slots__\" title=\"object.__slots__\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__slots__</span></code></a>, les descripteurs, les propri\u00e9t\u00e9s, <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getattribute__()</span></code>, les m\u00e9thodes de classe et les m\u00e9thodes statiques.</p>\n</dd>\n</main>\n"}, "objet": {"title": "objet", "body": "<main>\n<dd><p>N'importe quelle donn\u00e9e comportant des \u00e9tats (sous forme d'attributs ou d'une valeur) et un comportement (des m\u00e9thodes). C'est aussi (<code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code>) l'anc\u00eatre commun \u00e0 absolument toutes les <a class=\"reference internal\" href=\"#term-new-style-class\"><span class=\"xref std std-term\">nouvelles classes</span></a>.</p>\n</dd>\n</main>\n"}, "paquet": {"title": "paquet", "body": "<main>\n<dd><p><a class=\"reference internal\" href=\"#term-module\"><span class=\"xref std std-term\">module</span></a> Python qui peut contenir des sous-modules ou des sous-paquets. Techniquement, un paquet est un module qui poss\u00e8de un attribut <code class=\"docutils literal notranslate\"><span class=\"pre\">__path__</span></code>.</p>\n<p>Voir aussi <a class=\"reference internal\" href=\"#term-regular-package\"><span class=\"xref std std-term\">paquet classique</span></a> et <a class=\"reference internal\" href=\"#term-namespace-package\"><span class=\"xref std std-term\">namespace package</span></a>.</p>\n</dd>\n</main>\n"}, "param\u00e8tre": {"title": "param\u00e8tre", "body": "<main>\n<dd><p>Entit\u00e9 nomm\u00e9e dans la d\u00e9finition d'une <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">fonction</span></a> (ou m\u00e9thode), d\u00e9crivant un <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a> (ou dans certains cas des arguments) que la fonction accepte. Il existe cinq sortes de param\u00e8tres\u00a0:</p>\n<ul>\n<li><p><em class=\"dfn\">positional-or-keyword</em>\u00a0: l'argument peut \u00eatre pass\u00e9 soit par sa <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">position</span></a>, soit en tant que <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument nomm\u00e9</span></a>. C'est le type de param\u00e8tre par d\u00e9faut. Par exemple, <em>foo</em> et <em>bar</em> dans l'exemple suivant\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">bar</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n</ul>\n<ul id=\"positional-only-parameter\">\n<li><p><em class=\"dfn\">positional-only</em>\u00a0: d\u00e9finit un argument qui ne peut \u00eatre fourni que par position. Les param\u00e8tres <em>positional-only</em> peuvent \u00eatre d\u00e9finis en ins\u00e9rant un caract\u00e8re &quot;/&quot; dans la liste de param\u00e8tres de la d\u00e9finition de fonction apr\u00e8s eux. Par exemple\u00a0: <em>posonly1</em> et <em>posonly2</em> dans le code suivant\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">posonly1</span><span class=\"p\">,</span> <span class=\"n\">posonly2</span><span class=\"p\">,</span> <span class=\"o\">/</span><span class=\"p\">,</span> <span class=\"n\">positional_or_keyword</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n</ul>\n<ul id=\"keyword-only-parameter\">\n<li><p><em class=\"dfn\">keyword-only</em>\u00a0: l'argument ne peut \u00eatre fourni que nomm\u00e9. Les param\u00e8tres <em>keyword-only</em> peuvent \u00eatre d\u00e9finis en utilisant un seul param\u00e8tre <em>var-positional</em>, ou en ajoutant une \u00e9toile (<code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code>) seule dans la liste des param\u00e8tres avant eux. Par exemple, <em>kw_only1</em> et <em>kw_only2</em> dans le code suivant\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"n\">kw_only1</span><span class=\"p\">,</span> <span class=\"n\">kw_only2</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n<li><p><em class=\"dfn\">var-positional</em>\u00a0: une s\u00e9quence d'arguments positionnels peut \u00eatre fournie (en plus de tous les arguments positionnels d\u00e9j\u00e0 accept\u00e9s par d'autres param\u00e8tres). Un tel param\u00e8tre peut \u00eatre d\u00e9fini en pr\u00e9fixant son nom par une <code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code>. Par exemple <em>args</em> ci-apr\u00e8s\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n<li><p><em class=\"dfn\">var-keyword</em>\u00a0: une quantit\u00e9 arbitraire d'arguments peut \u00eatre pass\u00e9e, chacun \u00e9tant nomm\u00e9 (en plus de tous les arguments nomm\u00e9s d\u00e9j\u00e0 accept\u00e9s par d'autres param\u00e8tres). Un tel param\u00e8tre est d\u00e9fini en pr\u00e9fixant le nom du param\u00e8tre par <code class=\"docutils literal notranslate\"><span class=\"pre\">**</span></code>. Par exemple, <em>kwargs</em> ci-dessus.</p></li>\n</ul>\n<p>Les param\u00e8tres peuvent sp\u00e9cifier des arguments obligatoires ou optionnels, ainsi que des valeurs par d\u00e9faut pour les arguments optionnels.</p>\n<p>Voir aussi <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a> dans le glossaire, la question sur <a class=\"reference internal\" href=\"faq/programming.html#faq-argument-vs-parameter\"><span class=\"std std-ref\">la diff\u00e9rence entre les arguments et les param\u00e8tres</span></a> dans la FAQ, la classe <a class=\"reference internal\" href=\"library/inspect.html#inspect.Parameter\" title=\"inspect.Parameter\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">inspect.Parameter</span></code></a>, la section <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">D\u00e9finition de fonctions</span></a> et la <span class=\"target\" id=\"index-87\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0362/\"><strong>PEP 362</strong></a>.</p>\n</dd>\n</main>\n"}, "entr\u00e9e de chemin": {"title": "entr\u00e9e de chemin", "body": "<main>\n<dd><p>Emplacement dans le <a class=\"reference internal\" href=\"#term-import-path\"><span class=\"xref std std-term\">chemin des importations</span></a> (<em>import path</em> en anglais, d'o\u00f9 le <em>path</em>) que le <a class=\"reference internal\" href=\"#term-path-based-finder\"><span class=\"xref std std-term\">chercheur bas\u00e9 sur les chemins</span></a> consulte pour trouver des modules \u00e0 importer.</p>\n</dd>\n</main>\n"}, "chercheur de chemins": {"title": "chercheur de chemins", "body": "<main>\n<dd><p><a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">chercheur</span></a> renvoy\u00e9 par un appelable sur un <a class=\"reference internal\" href=\"library/sys.html#sys.path_hooks\" title=\"sys.path_hooks\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path_hooks</span></code></a> (c'est-\u00e0-dire un <a class=\"reference internal\" href=\"#term-path-entry-hook\"><span class=\"xref std std-term\">point d'entr\u00e9e pour la recherche dans path</span></a>) qui sait o\u00f9 trouver des modules lorsqu'on lui donne une <a class=\"reference internal\" href=\"#term-path-entry\"><span class=\"xref std std-term\">entr\u00e9e de path</span></a>.</p>\n<p>Voir <a class=\"reference internal\" href=\"library/importlib.html#importlib.abc.PathEntryFinder\" title=\"importlib.abc.PathEntryFinder\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.abc.PathEntryFinder</span></code></a> pour les m\u00e9thodes qu'un chercheur d'entr\u00e9e dans <em>path</em> doit impl\u00e9menter.</p>\n</dd>\n</main>\n"}, "point d'entr\u00e9e pour la recherche dans path": {"title": "point d'entr\u00e9e pour la recherche dans path", "body": "<main>\n<dd><p>Appelable dans la liste <code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path_hook</span></code> qui donne un <a class=\"reference internal\" href=\"#term-path-entry-finder\"><span class=\"xref std std-term\">chercheur d'entr\u00e9e dans path</span></a> s'il sait o\u00f9 trouver des modules pour une <a class=\"reference internal\" href=\"#term-path-entry\"><span class=\"xref std std-term\">entr\u00e9e dans path</span></a> donn\u00e9e.</p>\n</dd>\n</main>\n"}, "chercheur bas\u00e9 sur les chemins": {"title": "chercheur bas\u00e9 sur les chemins", "body": "<main>\n<dd><p>L'un des <a class=\"reference internal\" href=\"#term-meta-path-finder\"><span class=\"xref std std-term\">chercheurs dans les m\u00e9ta-chemins</span></a> par d\u00e9faut qui cherche des modules dans un <a class=\"reference internal\" href=\"#term-import-path\"><span class=\"xref std std-term\">chemin des importations</span></a>.</p>\n</dd>\n</main>\n"}, "objet simili-chemin": {"title": "objet simili-chemin", "body": "<main>\n<dd><p>Objet repr\u00e9sentant un chemin du syst\u00e8me de fichiers. Un objet simili-chemin est un objet <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> ou un objet <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> repr\u00e9sentant un chemin ou un objet impl\u00e9mentant le protocole <a class=\"reference internal\" href=\"library/os.html#os.PathLike\" title=\"os.PathLike\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">os.PathLike</span></code></a>. Un objet qui accepte le protocole <a class=\"reference internal\" href=\"library/os.html#os.PathLike\" title=\"os.PathLike\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">os.PathLike</span></code></a> peut \u00eatre converti en un chemin <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> ou <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> du syst\u00e8me de fichiers en appelant la fonction <a class=\"reference internal\" href=\"library/os.html#os.fspath\" title=\"os.fspath\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.fspath()</span></code></a>. <a class=\"reference internal\" href=\"library/os.html#os.fsdecode\" title=\"os.fsdecode\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.fsdecode()</span></code></a> et <a class=\"reference internal\" href=\"library/os.html#os.fsencode\" title=\"os.fsencode\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.fsencode()</span></code></a> peuvent \u00eatre utilis\u00e9es, respectivement, pour garantir un r\u00e9sultat de type <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> ou <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> \u00e0 la place. A \u00e9t\u00e9 Introduit par la <span class=\"target\" id=\"index-88\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0519/\"><strong>PEP 519</strong></a>.</p>\n</dd>\n</main>\n"}, "pep": {"title": "PEP", "body": "<main>\n<dd><p><em>Python Enhancement Proposal</em> (Proposition d'am\u00e9lioration de Python). Une PEP est un document de conception fournissant des informations \u00e0 la communaut\u00e9 Python ou d\u00e9crivant une nouvelle fonctionnalit\u00e9 pour Python, ses processus ou son environnement. Les PEP doivent fournir une sp\u00e9cification technique concise et une justification des fonctionnalit\u00e9s propos\u00e9es.</p>\n<p>Les PEP sont cens\u00e9es \u00eatre les principaux m\u00e9canismes pour proposer de nouvelles fonctionnalit\u00e9s majeures, pour recueillir les commentaires de la communaut\u00e9 sur une question et pour documenter les d\u00e9cisions de conception qui sont int\u00e9gr\u00e9es en Python. L\u2019auteur du PEP est responsable de l\u2019\u00e9tablissement d\u2019un consensus au sein de la communaut\u00e9 et de documenter les opinions contradictoires.</p>\n<p>Voir la\u00a0<span class=\"target\" id=\"index-89\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0001/\"><strong>PEP 1</strong></a>.</p>\n</dd>\n</main>\n"}, "portion": {"title": "portion", "body": "<main>\n<dd><p>Jeu de fichiers dans un seul dossier (pouvant \u00eatre stock\u00e9 sous forme de fichier zip) qui contribue \u00e0 l'espace de nommage d'un paquet, tel que d\u00e9fini dans la <span class=\"target\" id=\"index-90\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0420/\"><strong>PEP 420</strong></a>.</p>\n</dd>\n</main>\n"}, "argument positionnel": {"title": "argument positionnel", "body": "<main>\n<dd><p>Voir <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>.</p>\n</dd>\n</main>\n"}, "api provisoire": {"title": "API provisoire", "body": "<main>\n<dd><p>Une API provisoire est une API qui n'offre aucune garantie de r\u00e9trocompatibilit\u00e9 (la biblioth\u00e8que standard exige la r\u00e9trocompatibilit\u00e9). Bien que des changements majeurs d'une telle interface ne soient pas attendus, tant qu'elle est \u00e9tiquet\u00e9e provisoire, des changements cassant la r\u00e9trocompatibilit\u00e9 (y compris sa suppression compl\u00e8te) peuvent survenir si les d\u00e9veloppeurs principaux le jugent n\u00e9cessaire. Ces modifications ne surviendront que si de s\u00e9rieux probl\u00e8mes sont d\u00e9couverts et qu'ils n'avaient pas \u00e9t\u00e9 identifi\u00e9s avant l'ajout de l'API.</p>\n<p>M\u00eame pour les API provisoires, les changements cassant la r\u00e9trocompatibilit\u00e9 sont consid\u00e9r\u00e9s comme des &quot;solutions de dernier recours&quot;. Tout ce qui est possible sera fait pour tenter de r\u00e9soudre les probl\u00e8mes en conservant la r\u00e9trocompatibilit\u00e9.</p>\n<p>Ce processus permet \u00e0 la biblioth\u00e8que standard de continuer \u00e0 \u00e9voluer avec le temps, sans se bloquer longtemps sur des erreurs d'architecture. Voir la <span class=\"target\" id=\"index-91\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0411/\"><strong>PEP 411</strong></a> pour plus de d\u00e9tails.</p>\n</dd>\n</main>\n"}, "paquet provisoire": {"title": "paquet provisoire", "body": "<main>\n<dd><p>Voir <a class=\"reference internal\" href=\"#term-provisional-API\"><span class=\"xref std std-term\">provisional API</span></a>.</p>\n</dd>\n</main>\n"}, "python 3000": {"title": "Python 3000", "body": "<main>\n<dd><p>Surnom donn\u00e9 \u00e0 la s\u00e9rie des Python 3.x (tr\u00e8s vieux surnom donn\u00e9 \u00e0 l'\u00e9poque o\u00f9 Python 3 repr\u00e9sentait un futur lointain). Aussi abr\u00e9g\u00e9 <em>Py3k</em>.</p>\n</dd>\n</main>\n"}, "pythonique": {"title": "Pythonique", "body": "<main>\n<dd><p>Id\u00e9e, ou bout de code, qui colle aux idiomes de Python plut\u00f4t qu'aux concepts communs rencontr\u00e9s dans d'autres langages. Par exemple, il est idiomatique en Python de parcourir les \u00e9l\u00e9ments d'un it\u00e9rable en utilisant <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a>. Beaucoup d'autres langages n'ont pas cette possibilit\u00e9, donc les gens qui ne sont pas habitu\u00e9s \u00e0 Python utilisent parfois un compteur num\u00e9rique \u00e0 la place\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">food</span><span class=\"p\">)):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">food</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n</pre></div>\n</div>\n<p>Plut\u00f4t qu'utiliser la m\u00e9thode, plus propre et \u00e9l\u00e9gante, donc <em>Pythonique</em>\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">for</span> <span class=\"n\">piece</span> <span class=\"ow\">in</span> <span class=\"n\">food</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">piece</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "nom qualifi\u00e9": {"title": "nom qualifi\u00e9", "body": "<main>\n<dd><p>Nom, comprenant des points, montrant le &quot;chemin&quot; de l'espace de nommage global d'un module vers une classe, fonction ou m\u00e9thode d\u00e9finie dans ce module, tel que d\u00e9fini dans la <span class=\"target\" id=\"index-92\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-3155/\"><strong>PEP 3155</strong></a>. Pour les fonctions et classes de premier niveau, le nom qualifi\u00e9 est le m\u00eame que le nom de l'objet\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">class</span> <span class=\"nc\">C</span><span class=\"p\">:</span>\n<span class=\"gp\">... </span>    <span class=\"k\">class</span> <span class=\"nc\">D</span><span class=\"p\">:</span>\n<span class=\"gp\">... </span>        <span class=\"k\">def</span> <span class=\"nf\">meth</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>            <span class=\"k\">pass</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n<span class=\"go\">&#39;C&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">D</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n<span class=\"go\">&#39;C.D&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">D</span><span class=\"o\">.</span><span class=\"n\">meth</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n<span class=\"go\">&#39;C.D.meth&#39;</span>\n</pre></div>\n</div>\n<p>Lorsqu'il est utilis\u00e9 pour nommer des modules, le <em>nom qualifi\u00e9 complet</em> (<em>fully qualified name - FQN</em> en anglais) signifie le chemin complet (s\u00e9par\u00e9 par des points) vers le module, incluant tous les paquets parents. Par exemple\u00a0: <code class=\"docutils literal notranslate\"><span class=\"pre\">email.mime.text</span></code>\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">email.mime.text</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">email</span><span class=\"o\">.</span><span class=\"n\">mime</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n<span class=\"go\">&#39;email.mime.text&#39;</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "nombre de r\u00e9f\u00e9rences": {"title": "nombre de r\u00e9f\u00e9rences", "body": "<main>\n<dd><p>The number of references to an object.  When the reference count of an\nobject drops to zero, it is deallocated.  Some objects are\n&quot;immortal&quot; and have reference counts that are never modified, and\ntherefore the objects are never deallocated.  Reference counting is\ngenerally not visible to Python code, but it is a key element of the\n<a class=\"reference internal\" href=\"#term-CPython\"><span class=\"xref std std-term\">CPython</span></a> implementation.  Programmers can call the\n<a class=\"reference internal\" href=\"library/sys.html#sys.getrefcount\" title=\"sys.getrefcount\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sys.getrefcount()</span></code></a> function to return the\nreference count for a particular object.</p>\n</dd>\n</main>\n"}, "paquet classique": {"title": "paquet classique", "body": "<main>\n<dd><p><a class=\"reference internal\" href=\"#term-package\"><span class=\"xref std std-term\">paquet</span></a> traditionnel, tel qu'un dossier contenant un fichier <code class=\"docutils literal notranslate\"><span class=\"pre\">__init__.py</span></code>.</p>\n<p>Voir aussi <a class=\"reference internal\" href=\"#term-namespace-package\"><span class=\"xref std std-term\">paquet-espace de nommage</span></a>.</p>\n</dd>\n</main>\n"}, "__slots__": {"title": "__slots__", "body": "<main>\n<dd><p>D\u00e9claration dans une classe qui \u00e9conomise de la m\u00e9moire en pr\u00e9-allouant de l'espace pour les attributs des instances et qui \u00e9limine le dictionnaire (des attributs) des instances. Bien que populaire, cette technique est difficile \u00e0 ma\u00eetriser et devrait \u00eatre r\u00e9serv\u00e9e \u00e0 de rares cas o\u00f9 un grand nombre d'instances dans une application devient un sujet critique pour la m\u00e9moire.</p>\n</dd>\n</main>\n"}, "s\u00e9quence": {"title": "s\u00e9quence", "body": "<main>\n<dd><p>An <a class=\"reference internal\" href=\"#term-iterable\"><span class=\"xref std std-term\">iterable</span></a> which supports efficient element access using integer\nindices via the <a class=\"reference internal\" href=\"reference/datamodel.html#object.__getitem__\" title=\"object.__getitem__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code></a> special method and defines a\n<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__len__()</span></code> method that returns the length of the sequence.\nSome built-in sequence types are <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>,\n<a class=\"reference internal\" href=\"library/stdtypes.html#tuple\" title=\"tuple\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tuple</span></code></a>, and <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a>. Note that <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a> also\nsupports <a class=\"reference internal\" href=\"reference/datamodel.html#object.__getitem__\" title=\"object.__getitem__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code></a> and <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__len__()</span></code>, but is considered a\nmapping rather than a sequence because the lookups use arbitrary\n<a class=\"reference internal\" href=\"#term-immutable\"><span class=\"xref std std-term\">immutable</span></a> keys rather than integers.</p>\n<p>The <a class=\"reference internal\" href=\"library/collections.abc.html#collections.abc.Sequence\" title=\"collections.abc.Sequence\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.abc.Sequence</span></code></a> abstract base class\ndefines a much richer interface that goes beyond just\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__getitem__\" title=\"object.__getitem__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code></a> and <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__len__()</span></code>, adding <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">count()</span></code>,\n<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">index()</span></code>, <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__contains__()</span></code>, and\n<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__reversed__()</span></code>. Types that implement this expanded\ninterface can be registered explicitly using\n<a class=\"reference internal\" href=\"library/abc.html#abc.ABCMeta.register\" title=\"abc.ABCMeta.register\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">register()</span></code></a>.</p>\n</dd>\n</main>\n"}, "ensemble en compr\u00e9hension (ou ensemble en intension)": {"title": "ensemble en compr\u00e9hension (ou ensemble en intension)", "body": "<main>\n<dd><p>Une fa\u00e7on compacte de traiter tout ou partie des \u00e9l\u00e9ments d'un it\u00e9rable et de renvoyer un <em>set</em> avec les r\u00e9sultats. <code class=\"docutils literal notranslate\"><span class=\"pre\">results</span> <span class=\"pre\">=</span> <span class=\"pre\">{c</span> <span class=\"pre\">for</span> <span class=\"pre\">c</span> <span class=\"pre\">in</span> <span class=\"pre\">'abracadabra'</span> <span class=\"pre\">if</span> <span class=\"pre\">c</span> <span class=\"pre\">not</span> <span class=\"pre\">in</span> <span class=\"pre\">'abc'}</span></code> g\u00e9n\u00e8re l'ensemble contenant les lettres \u00ab\u00a0r\u00a0\u00bb et \u00ab\u00a0d\u00a0\u00bb <code class=\"docutils literal notranslate\"><span class=\"pre\">{'r',</span> <span class=\"pre\">'d'}</span></code>. Voir <a class=\"reference internal\" href=\"reference/expressions.html#comprehensions\"><span class=\"std std-ref\">Agencements des listes, ensembles et dictionnaires</span></a>.</p>\n</dd>\n</main>\n"}, "distribution simple": {"title": "distribution simple", "body": "<main>\n<dd><p>Forme de distribution, comme les <a class=\"reference internal\" href=\"#term-generic-function\"><span class=\"xref std std-term\">fonction g\u00e9n\u00e9riques</span></a>, o\u00f9 l'impl\u00e9mentation est choisie en fonction du type d'un seul argument.</p>\n</dd>\n</main>\n"}, "tranche": {"title": "tranche", "body": "<main>\n<dd><p>(<em>slice</em> en anglais), un objet contenant habituellement une portion de <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">s\u00e9quence</span></a>. Une tranche est cr\u00e9\u00e9e en utilisant la notation <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> avec des <code class=\"docutils literal notranslate\"><span class=\"pre\">:</span></code> entre les nombres lorsque plusieurs sont fournis, comme dans <code class=\"docutils literal notranslate\"><span class=\"pre\">variable_name[1:3:5]</span></code>. Cette notation utilise des objets <a class=\"reference internal\" href=\"library/functions.html#slice\" title=\"slice\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">slice</span></code></a> en interne.</p>\n</dd>\n</main>\n"}, "m\u00e9thode sp\u00e9ciale": {"title": "m\u00e9thode sp\u00e9ciale", "body": "<main>\n<dd><p id=\"index-34\">(<em>special method</em> en anglais) M\u00e9thode appel\u00e9e implicitement par Python pour ex\u00e9cuter une op\u00e9ration sur un type, comme une addition. De telles m\u00e9thodes ont des noms commen\u00e7ant et terminant par des doubles tirets bas. Les m\u00e9thodes sp\u00e9ciales sont document\u00e9es dans <a class=\"reference internal\" href=\"reference/datamodel.html#specialnames\"><span class=\"std std-ref\">M\u00e9thodes sp\u00e9ciales</span></a>.</p>\n</dd>\n</main>\n"}, "instruction": {"title": "instruction", "body": "<main>\n<dd><p>Une instruction (<em>statement</em> en anglais) est un composant d'un &quot;bloc&quot; de code. Une instruction est soit une <a class=\"reference internal\" href=\"#term-expression\"><span class=\"xref std std-term\">expression</span></a>, soit une ou plusieurs constructions bas\u00e9es sur un mot-cl\u00e9, comme <a class=\"reference internal\" href=\"reference/compound_stmts.html#if\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code></a>, <a class=\"reference internal\" href=\"reference/compound_stmts.html#while\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">while</span></code></a> ou <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a>.</p>\n</dd>\n</main>\n"}, "r\u00e9f\u00e9rence forte": {"title": "r\u00e9f\u00e9rence forte", "body": "<main>\n<dd><p>In Python's C API, a strong reference is a reference to an object\nwhich is owned by the code holding the reference.  The strong\nreference is taken by calling <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_INCREF\" title=\"Py_INCREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_INCREF()</span></code></a> when the\nreference is created and released with <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_DECREF\" title=\"Py_DECREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_DECREF()</span></code></a>\nwhen the reference is deleted.</p>\n<p>Une r\u00e9f\u00e9rence forte est cr\u00e9\u00e9e \u00e0 l'aide de la fonction <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_NewRef\" title=\"Py_NewRef\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_NewRef()</span></code></a>. Il faut normalement appeler <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_DECREF\" title=\"Py_DECREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_DECREF()</span></code></a> dessus avant de sortir de sa port\u00e9e lexicale, sans quoi il y a une fuite de r\u00e9f\u00e9rence.</p>\n<p>Voir aussi <a class=\"reference internal\" href=\"#term-borrowed-reference\"><span class=\"xref std std-term\">r\u00e9f\u00e9rence emprunt\u00e9e</span></a>.</p>\n</dd>\n</main>\n"}, "encodages de texte": {"title": "encodages de texte", "body": "<main>\n<dd><p>Une cha\u00eene de caract\u00e8res en Python est une suite de points de code Unicode (dans l'intervalle <code class=\"docutils literal notranslate\"><span class=\"pre\">U+0000</span></code>--<code class=\"docutils literal notranslate\"><span class=\"pre\">U+10FFFF</span></code>). Pour stocker ou transmettre une cha\u00eene, il est n\u00e9cessaire de la s\u00e9rialiser en suite d'octets.</p>\n<p>S\u00e9rialiser une cha\u00eene de caract\u00e8res en une suite d'octets s'appelle \u00ab\u00a0encoder\u00a0\u00bb et recr\u00e9er la cha\u00eene \u00e0 partir de la suite d'octets s'appelle \u00ab\u00a0d\u00e9coder\u00a0\u00bb.</p>\n<p>Il existe de multiples <a class=\"reference internal\" href=\"library/codecs.html#standard-encodings\"><span class=\"std std-ref\">codecs</span></a> pour la s\u00e9rialisation de texte, que l'on regroupe sous l'expression \u00ab\u00a0encodages de texte\u00a0\u00bb.</p>\n</dd>\n</main>\n"}, "fichier texte": {"title": "fichier texte", "body": "<main>\n<dd><p><a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">Objet fichier</span></a> capable de lire et d'\u00e9crire des objets <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>. Souvent, un fichier texte (<em>text file</em> en anglais) acc\u00e8de en fait \u00e0 un flux de donn\u00e9e en octets et g\u00e8re l'<a class=\"reference internal\" href=\"#term-text-encoding\"><span class=\"xref std std-term\">encodage de texte</span></a> automatiquement. Des exemples de fichiers textes sont les fichiers ouverts en mode texte (<code class=\"docutils literal notranslate\"><span class=\"pre\">'r'</span></code> ou <code class=\"docutils literal notranslate\"><span class=\"pre\">'w'</span></code>), <a class=\"reference internal\" href=\"library/sys.html#sys.stdin\" title=\"sys.stdin\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdin</span></code></a>, <a class=\"reference internal\" href=\"library/sys.html#sys.stdout\" title=\"sys.stdout\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdout</span></code></a> et les instances de <a class=\"reference internal\" href=\"library/io.html#io.StringIO\" title=\"io.StringIO\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">io.StringIO</span></code></a>.</p>\n<p>Voir aussi <a class=\"reference internal\" href=\"#term-binary-file\"><span class=\"xref std std-term\">fichier binaire</span></a> pour un objet fichier capable de lire et d'\u00e9crire des <a class=\"reference internal\" href=\"#term-bytes-like-object\"><span class=\"xref std std-term\">objets octets-compatibles</span></a>.</p>\n</dd>\n</main>\n"}, "cha\u00eene entre triple guillemets": {"title": "cha\u00eene entre triple guillemets", "body": "<main>\n<dd><p>Cha\u00eene qui est d\u00e9limit\u00e9e par trois guillemets simples (<code class=\"docutils literal notranslate\"><span class=\"pre\">'</span></code>) ou trois guillemets doubles (<code class=\"docutils literal notranslate\"><span class=\"pre\">&quot;</span></code>). Bien qu'elle ne fournisse aucune fonctionnalit\u00e9 qui ne soit pas disponible avec une cha\u00eene entre guillemets, elle est utile pour de nombreuses raisons. Elle vous autorise \u00e0 ins\u00e9rer des guillemets simples et doubles dans une cha\u00eene sans avoir \u00e0 les prot\u00e9ger et elle peut s'\u00e9tendre sur plusieurs lignes sans avoir \u00e0 terminer chaque ligne par un <code class=\"docutils literal notranslate\"><span class=\"pre\">\\</span></code>. Elle est ainsi particuli\u00e8rement utile pour les cha\u00eenes de documentation (<em>docstrings</em>).</p>\n</dd>\n</main>\n"}, "type": {"title": "type", "body": "<main>\n<dd><p>Le type d'un objet Python d\u00e9termine quel genre d'objet c'est. Tous les objets ont un type. Le type d'un objet peut \u00eatre obtenu via son attribut <a class=\"reference internal\" href=\"library/stdtypes.html#instance.__class__\" title=\"instance.__class__\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__class__</span></code></a> ou via <code class=\"docutils literal notranslate\"><span class=\"pre\">type(obj)</span></code>.</p>\n</dd>\n</main>\n"}, "alias de type": {"title": "alias de type", "body": "<main>\n<dd><p>Synonyme d'un type, cr\u00e9\u00e9 en affectant le type \u00e0 un identifiant.</p>\n<p>Les alias de types sont utiles pour simplifier\u00a0les <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">indications de types</span></a>. Par exemple\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">remove_gray_shades</span><span class=\"p\">(</span>\n        <span class=\"n\">colors</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]:</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>pourrait \u00eatre rendu plus lisible comme ceci\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">Color</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">remove_gray_shades</span><span class=\"p\">(</span><span class=\"n\">colors</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">Color</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">Color</span><span class=\"p\">]:</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>Voir <a class=\"reference internal\" href=\"library/typing.html#module-typing\" title=\"typing: Support for type hints (see :pep:`484`).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">typing</span></code></a> et la <span class=\"target\" id=\"index-93\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, qui d\u00e9crivent cette fonctionnalit\u00e9.</p>\n</dd>\n</main>\n"}, "indication de type": {"title": "indication de type", "body": "<main>\n<dd><p>L'<a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotation</span></a> qui sp\u00e9cifie le type attendu pour une variable, un attribut de classe, un param\u00e8tre de fonction ou une valeur de retour.</p>\n<p>Les indications de type sont facultatives et ne sont pas indispensables \u00e0 l'interpr\u00e9teur Python, mais elles sont utiles aux outils d'analyse de type statique et aident les IDE \u00e0 compl\u00e9ter et \u00e0 r\u00e9usiner (<em>code refactoring</em> en anglais) le code.</p>\n<p>Les indications de type de variables globales, d'attributs de classe et de fonctions, mais pas de variables locales, peuvent \u00eatre consult\u00e9es en utilisant <a class=\"reference internal\" href=\"library/typing.html#typing.get_type_hints\" title=\"typing.get_type_hints\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">typing.get_type_hints()</span></code></a>.</p>\n<p>Voir <a class=\"reference internal\" href=\"library/typing.html#module-typing\" title=\"typing: Support for type hints (see :pep:`484`).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">typing</span></code></a> et la <span class=\"target\" id=\"index-94\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, qui d\u00e9crivent cette fonctionnalit\u00e9.</p>\n</dd>\n</main>\n"}, "retours \u00e0 la ligne universels": {"title": "retours \u00e0 la ligne universels", "body": "<main>\n<dd><p>Une mani\u00e8re d'interpr\u00e9ter des flux de texte dans lesquels sont reconnues toutes les fins de ligne suivantes\u00a0: la convention Unix <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\n'</span></code>, la convention Windows <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\r\\n'</span></code> et l'ancienne convention Macintosh <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\r'</span></code>. Voir la <span class=\"target\" id=\"index-95\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0278/\"><strong>PEP 278</strong></a> et la <span class=\"target\" id=\"index-96\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-3116/\"><strong>PEP 3116</strong></a>, ainsi que la fonction <a class=\"reference internal\" href=\"library/stdtypes.html#bytes.splitlines\" title=\"bytes.splitlines\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">bytes.splitlines()</span></code></a> pour d'autres usages.</p>\n</dd>\n</main>\n"}, "annotation de variable": {"title": "annotation de variable", "body": "<main>\n<dd><p><a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotation</span></a> d'une variable ou d'un attribut de classe.</p>\n<p>Lorsque vous annotez une variable ou un attribut de classe, l'affectation est facultative\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">C</span><span class=\"p\">:</span>\n    <span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"s1\">&#39;annotation&#39;</span>\n</pre></div>\n</div>\n<p>Les annotations de variables sont g\u00e9n\u00e9ralement utilis\u00e9es pour des <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">indications de types</span></a>\u00a0: par exemple, cette variable devrait prendre des valeurs de type <a class=\"reference internal\" href=\"library/functions.html#int\" title=\"int\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">int</span></code></a>\u00a0:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n</pre></div>\n</div>\n<p>La syntaxe d'annotation de variable est expliqu\u00e9e dans la section\u00a0<a class=\"reference internal\" href=\"reference/simple_stmts.html#annassign\"><span class=\"std std-ref\">Les assignations annot\u00e9es</span></a>.</p>\n<p>Reportez-vous \u00e0 <a class=\"reference internal\" href=\"#term-function-annotation\"><span class=\"xref std std-term\">annotation de fonction</span></a>, \u00e0 la <span class=\"target\" id=\"index-97\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a> et \u00e0 la <span class=\"target\" id=\"index-98\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0526/\"><strong>PEP 526</strong></a> qui d\u00e9crivent cette fonctionnalit\u00e9. Voir aussi <a class=\"reference internal\" href=\"howto/annotations.html#annotations-howto\"><span class=\"std std-ref\">Bonnes pratiques concernant les annotations</span></a> sur les bonnes pratiques concernant les annotations.</p>\n</dd>\n</main>\n"}, "environnement virtuel": {"title": "environnement virtuel", "body": "<main>\n<dd><p>Environnement d'ex\u00e9cution isol\u00e9 (en mode coop\u00e9ratif) qui permet aux utilisateurs de Python et aux applications d'installer et de mettre \u00e0 jour des paquets sans interf\u00e9rer avec d'autres applications Python fonctionnant sur le m\u00eame syst\u00e8me.</p>\n<p>Voir aussi <a class=\"reference internal\" href=\"library/venv.html#module-venv\" title=\"venv: Creation of virtual environments.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">venv</span></code></a>.</p>\n</dd>\n</main>\n"}, "machine virtuelle": {"title": "machine virtuelle", "body": "<main>\n<dd><p>Ordinateur d\u00e9fini enti\u00e8rement par du logiciel. La machine virtuelle (<em>virtual machine</em>) de Python ex\u00e9cute le <a class=\"reference internal\" href=\"#term-bytecode\"><span class=\"xref std std-term\">code interm\u00e9diaire</span></a> produit par le compilateur de <em>bytecode</em>.</p>\n</dd>\n</main>\n"}, "le zen de python": {"title": "Le zen de Python", "body": "<main>\n<dd><p>Liste de principes et de pr\u00e9ceptes utiles pour comprendre et utiliser le langage. Cette liste peut \u00eatre obtenue en tapant &quot;<code class=\"docutils literal notranslate\"><span class=\"pre\">import</span> <span class=\"pre\">this</span></code>&quot; dans une invite Python interactive.</p>\n</dd>\n</main>\n"}}